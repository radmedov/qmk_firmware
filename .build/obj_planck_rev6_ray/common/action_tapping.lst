   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 2
  11              		.file	"action_tapping.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.debug_waiting_buffer,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	debug_waiting_buffer:
  23              	.LFB14:
  24              		.file 1 "tmk_core/common/action_tapping.c"
   1:tmk_core/common/action_tapping.c **** #include <stdint.h>
   2:tmk_core/common/action_tapping.c **** #include <stdbool.h>
   3:tmk_core/common/action_tapping.c **** #include "action.h"
   4:tmk_core/common/action_tapping.c **** #include "action_layer.h"
   5:tmk_core/common/action_tapping.c **** #include "action_tapping.h"
   6:tmk_core/common/action_tapping.c **** #include "keycode.h"
   7:tmk_core/common/action_tapping.c **** #include "timer.h"
   8:tmk_core/common/action_tapping.c **** 
   9:tmk_core/common/action_tapping.c **** #ifdef DEBUG_ACTION
  10:tmk_core/common/action_tapping.c **** #    include "debug.h"
  11:tmk_core/common/action_tapping.c **** #else
  12:tmk_core/common/action_tapping.c **** #    include "nodebug.h"
  13:tmk_core/common/action_tapping.c **** #endif
  14:tmk_core/common/action_tapping.c **** 
  15:tmk_core/common/action_tapping.c **** #ifndef NO_ACTION_TAPPING
  16:tmk_core/common/action_tapping.c **** 
  17:tmk_core/common/action_tapping.c **** #    define IS_TAPPING() !IS_NOEVENT(tapping_key.event)
  18:tmk_core/common/action_tapping.c **** #    define IS_TAPPING_PRESSED() (IS_TAPPING() && tapping_key.event.pressed)
  19:tmk_core/common/action_tapping.c **** #    define IS_TAPPING_RELEASED() (IS_TAPPING() && !tapping_key.event.pressed)
  20:tmk_core/common/action_tapping.c **** #    define IS_TAPPING_KEY(k) (IS_TAPPING() && KEYEQ(tapping_key.event.key, (k)))
  21:tmk_core/common/action_tapping.c **** 
  22:tmk_core/common/action_tapping.c **** __attribute__((weak)) uint16_t get_tapping_term(uint16_t keycode) { return TAPPING_TERM; }
  23:tmk_core/common/action_tapping.c **** 
  24:tmk_core/common/action_tapping.c **** #    ifdef TAPPING_TERM_PER_KEY
  25:tmk_core/common/action_tapping.c **** #        define WITHIN_TAPPING_TERM(e) (TIMER_DIFF_16(e.time, tapping_key.event.time) < get_tapping
  26:tmk_core/common/action_tapping.c **** #    else
  27:tmk_core/common/action_tapping.c **** #        define WITHIN_TAPPING_TERM(e) (TIMER_DIFF_16(e.time, tapping_key.event.time) < TAPPING_TER
  28:tmk_core/common/action_tapping.c **** #    endif
  29:tmk_core/common/action_tapping.c **** 
  30:tmk_core/common/action_tapping.c **** static keyrecord_t tapping_key                         = {};
  31:tmk_core/common/action_tapping.c **** static keyrecord_t waiting_buffer[WAITING_BUFFER_SIZE] = {};
  32:tmk_core/common/action_tapping.c **** static uint8_t     waiting_buffer_head                 = 0;
  33:tmk_core/common/action_tapping.c **** static uint8_t     waiting_buffer_tail                 = 0;
  34:tmk_core/common/action_tapping.c **** 
  35:tmk_core/common/action_tapping.c **** static bool process_tapping(keyrecord_t *record);
  36:tmk_core/common/action_tapping.c **** static bool waiting_buffer_enq(keyrecord_t record);
  37:tmk_core/common/action_tapping.c **** static void waiting_buffer_clear(void);
  38:tmk_core/common/action_tapping.c **** static bool waiting_buffer_typed(keyevent_t event);
  39:tmk_core/common/action_tapping.c **** static bool waiting_buffer_has_anykey_pressed(void);
  40:tmk_core/common/action_tapping.c **** static void waiting_buffer_scan_tap(void);
  41:tmk_core/common/action_tapping.c **** static void debug_tapping_key(void);
  42:tmk_core/common/action_tapping.c **** static void debug_waiting_buffer(void);
  43:tmk_core/common/action_tapping.c **** 
  44:tmk_core/common/action_tapping.c **** /** \brief Action Tapping Process
  45:tmk_core/common/action_tapping.c ****  *
  46:tmk_core/common/action_tapping.c ****  * FIXME: Needs doc
  47:tmk_core/common/action_tapping.c ****  */
  48:tmk_core/common/action_tapping.c **** void action_tapping_process(keyrecord_t record) {
  49:tmk_core/common/action_tapping.c ****     if (process_tapping(&record)) {
  50:tmk_core/common/action_tapping.c ****         if (!IS_NOEVENT(record.event)) {
  51:tmk_core/common/action_tapping.c ****             debug("processed: ");
  52:tmk_core/common/action_tapping.c ****             debug_record(record);
  53:tmk_core/common/action_tapping.c ****             debug("\n");
  54:tmk_core/common/action_tapping.c ****         }
  55:tmk_core/common/action_tapping.c ****     } else {
  56:tmk_core/common/action_tapping.c ****         if (!waiting_buffer_enq(record)) {
  57:tmk_core/common/action_tapping.c ****             // clear all in case of overflow.
  58:tmk_core/common/action_tapping.c ****             debug("OVERFLOW: CLEAR ALL STATES\n");
  59:tmk_core/common/action_tapping.c ****             clear_keyboard();
  60:tmk_core/common/action_tapping.c ****             waiting_buffer_clear();
  61:tmk_core/common/action_tapping.c ****             tapping_key = (keyrecord_t){};
  62:tmk_core/common/action_tapping.c ****         }
  63:tmk_core/common/action_tapping.c ****     }
  64:tmk_core/common/action_tapping.c **** 
  65:tmk_core/common/action_tapping.c ****     // process waiting_buffer
  66:tmk_core/common/action_tapping.c ****     if (!IS_NOEVENT(record.event) && waiting_buffer_head != waiting_buffer_tail) {
  67:tmk_core/common/action_tapping.c ****         debug("---- action_exec: process waiting_buffer -----\n");
  68:tmk_core/common/action_tapping.c ****     }
  69:tmk_core/common/action_tapping.c ****     for (; waiting_buffer_tail != waiting_buffer_head; waiting_buffer_tail = (waiting_buffer_tail +
  70:tmk_core/common/action_tapping.c ****         if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
  71:tmk_core/common/action_tapping.c ****             debug("processed: waiting_buffer[");
  72:tmk_core/common/action_tapping.c ****             debug_dec(waiting_buffer_tail);
  73:tmk_core/common/action_tapping.c ****             debug("] = ");
  74:tmk_core/common/action_tapping.c ****             debug_record(waiting_buffer[waiting_buffer_tail]);
  75:tmk_core/common/action_tapping.c ****             debug("\n\n");
  76:tmk_core/common/action_tapping.c ****         } else {
  77:tmk_core/common/action_tapping.c ****             break;
  78:tmk_core/common/action_tapping.c ****         }
  79:tmk_core/common/action_tapping.c ****     }
  80:tmk_core/common/action_tapping.c ****     if (!IS_NOEVENT(record.event)) {
  81:tmk_core/common/action_tapping.c ****         debug("\n");
  82:tmk_core/common/action_tapping.c ****     }
  83:tmk_core/common/action_tapping.c **** }
  84:tmk_core/common/action_tapping.c **** 
  85:tmk_core/common/action_tapping.c **** /** \brief Tapping
  86:tmk_core/common/action_tapping.c ****  *
  87:tmk_core/common/action_tapping.c ****  * Rule: Tap key is typed(pressed and released) within TAPPING_TERM.
  88:tmk_core/common/action_tapping.c ****  *       (without interfering by typing other key)
  89:tmk_core/common/action_tapping.c ****  */
  90:tmk_core/common/action_tapping.c **** /* return true when key event is processed or consumed. */
  91:tmk_core/common/action_tapping.c **** bool process_tapping(keyrecord_t *keyp) {
  92:tmk_core/common/action_tapping.c ****     keyevent_t event = keyp->event;
  93:tmk_core/common/action_tapping.c **** 
  94:tmk_core/common/action_tapping.c ****     // if tapping
  95:tmk_core/common/action_tapping.c ****     if (IS_TAPPING_PRESSED()) {
  96:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
  97:tmk_core/common/action_tapping.c ****             if (tapping_key.tap.count == 0) {
  98:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
  99:tmk_core/common/action_tapping.c ****                     // first tap!
 100:tmk_core/common/action_tapping.c ****                     debug("Tapping: First tap(0->1).\n");
 101:tmk_core/common/action_tapping.c ****                     tapping_key.tap.count = 1;
 102:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 103:tmk_core/common/action_tapping.c ****                     process_record(&tapping_key);
 104:tmk_core/common/action_tapping.c **** 
 105:tmk_core/common/action_tapping.c ****                     // copy tapping state
 106:tmk_core/common/action_tapping.c ****                     keyp->tap = tapping_key.tap;
 107:tmk_core/common/action_tapping.c ****                     // enqueue
 108:tmk_core/common/action_tapping.c ****                     return false;
 109:tmk_core/common/action_tapping.c ****                 }
 110:tmk_core/common/action_tapping.c ****                 /* Process a key typed within TAPPING_TERM
 111:tmk_core/common/action_tapping.c ****                  * This can register the key before settlement of tapping,
 112:tmk_core/common/action_tapping.c ****                  * useful for long TAPPING_TERM but may prevent fast typing.
 113:tmk_core/common/action_tapping.c ****                  */
 114:tmk_core/common/action_tapping.c **** #    if defined(TAPPING_TERM_PER_KEY) || (!defined(PER_KEY_TAPPING_TERM) && TAPPING_TERM >= 500) ||
 115:tmk_core/common/action_tapping.c **** #        ifdef TAPPING_TERM_PER_KEY
 116:tmk_core/common/action_tapping.c ****                 else if ((get_tapping_term(get_event_keycode(tapping_key.event)) >= 500) && IS_RELE
 117:tmk_core/common/action_tapping.c **** #        else
 118:tmk_core/common/action_tapping.c ****                 else if (IS_RELEASED(event) && waiting_buffer_typed(event))
 119:tmk_core/common/action_tapping.c **** #        endif
 120:tmk_core/common/action_tapping.c ****                 {
 121:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. No tap. Interfered by typing key\n");
 122:tmk_core/common/action_tapping.c ****                     process_record(&tapping_key);
 123:tmk_core/common/action_tapping.c ****                     tapping_key = (keyrecord_t){};
 124:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 125:tmk_core/common/action_tapping.c ****                     // enqueue
 126:tmk_core/common/action_tapping.c ****                     return false;
 127:tmk_core/common/action_tapping.c ****                 }
 128:tmk_core/common/action_tapping.c **** #    endif
 129:tmk_core/common/action_tapping.c ****                 /* Process release event of a key pressed before tapping starts
 130:tmk_core/common/action_tapping.c ****                  * Without this unexpected repeating will occur with having fast repeating setting
 131:tmk_core/common/action_tapping.c ****                  * https://github.com/tmk/tmk_keyboard/issues/60
 132:tmk_core/common/action_tapping.c ****                  */
 133:tmk_core/common/action_tapping.c ****                 else if (IS_RELEASED(event) && !waiting_buffer_typed(event)) {
 134:tmk_core/common/action_tapping.c ****                     // Modifier should be retained till end of this tapping.
 135:tmk_core/common/action_tapping.c ****                     action_t action = layer_switch_get_action(event.key);
 136:tmk_core/common/action_tapping.c ****                     switch (action.kind.id) {
 137:tmk_core/common/action_tapping.c ****                         case ACT_LMODS:
 138:tmk_core/common/action_tapping.c ****                         case ACT_RMODS:
 139:tmk_core/common/action_tapping.c ****                             if (action.key.mods && !action.key.code) return false;
 140:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 141:tmk_core/common/action_tapping.c ****                             break;
 142:tmk_core/common/action_tapping.c ****                         case ACT_LMODS_TAP:
 143:tmk_core/common/action_tapping.c ****                         case ACT_RMODS_TAP:
 144:tmk_core/common/action_tapping.c ****                             if (action.key.mods && keyp->tap.count == 0) return false;
 145:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 146:tmk_core/common/action_tapping.c ****                             break;
 147:tmk_core/common/action_tapping.c ****                     }
 148:tmk_core/common/action_tapping.c ****                     // Release of key should be process immediately.
 149:tmk_core/common/action_tapping.c ****                     debug("Tapping: release event of a key pressed before tapping\n");
 150:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 151:tmk_core/common/action_tapping.c ****                     return true;
 152:tmk_core/common/action_tapping.c ****                 } else {
 153:tmk_core/common/action_tapping.c ****                     // set interrupted flag when other key preesed during tapping
 154:tmk_core/common/action_tapping.c ****                     if (event.pressed) {
 155:tmk_core/common/action_tapping.c ****                         tapping_key.tap.interrupted = true;
 156:tmk_core/common/action_tapping.c ****                     }
 157:tmk_core/common/action_tapping.c ****                     // enqueue
 158:tmk_core/common/action_tapping.c ****                     return false;
 159:tmk_core/common/action_tapping.c ****                 }
 160:tmk_core/common/action_tapping.c ****             }
 161:tmk_core/common/action_tapping.c ****             // tap_count > 0
 162:tmk_core/common/action_tapping.c ****             else {
 163:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
 164:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 165:tmk_core/common/action_tapping.c ****                     debug_dec(tapping_key.tap.count);
 166:tmk_core/common/action_tapping.c ****                     debug(")\n");
 167:tmk_core/common/action_tapping.c ****                     keyp->tap = tapping_key.tap;
 168:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 169:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 170:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 171:tmk_core/common/action_tapping.c ****                     return true;
 172:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 173:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 174:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last tap(>1).\n");
 175:tmk_core/common/action_tapping.c ****                         // unregister key
 176:tmk_core/common/action_tapping.c ****                         process_record(&(keyrecord_t){.tap = tapping_key.tap, .event.key = tapping_
 177:tmk_core/common/action_tapping.c ****                     } else {
 178:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start while last tap(1).\n");
 179:tmk_core/common/action_tapping.c ****                     }
 180:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 181:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 182:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 183:tmk_core/common/action_tapping.c ****                     return true;
 184:tmk_core/common/action_tapping.c ****                 } else {
 185:tmk_core/common/action_tapping.c ****                     if (!IS_NOEVENT(event)) {
 186:tmk_core/common/action_tapping.c ****                         debug("Tapping: key event while last tap(>0).\n");
 187:tmk_core/common/action_tapping.c ****                     }
 188:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 189:tmk_core/common/action_tapping.c ****                     return true;
 190:tmk_core/common/action_tapping.c ****                 }
 191:tmk_core/common/action_tapping.c ****             }
 192:tmk_core/common/action_tapping.c ****         }
 193:tmk_core/common/action_tapping.c ****         // after TAPPING_TERM
 194:tmk_core/common/action_tapping.c ****         else {
 195:tmk_core/common/action_tapping.c ****             if (tapping_key.tap.count == 0) {
 196:tmk_core/common/action_tapping.c ****                 debug("Tapping: End. Timeout. Not tap(0): ");
 197:tmk_core/common/action_tapping.c ****                 debug_event(event);
 198:tmk_core/common/action_tapping.c ****                 debug("\n");
 199:tmk_core/common/action_tapping.c ****                 process_record(&tapping_key);
 200:tmk_core/common/action_tapping.c ****                 tapping_key = (keyrecord_t){};
 201:tmk_core/common/action_tapping.c ****                 debug_tapping_key();
 202:tmk_core/common/action_tapping.c ****                 return false;
 203:tmk_core/common/action_tapping.c ****             } else {
 204:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
 205:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 206:tmk_core/common/action_tapping.c ****                     keyp->tap = tapping_key.tap;
 207:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 208:tmk_core/common/action_tapping.c ****                     tapping_key = (keyrecord_t){};
 209:tmk_core/common/action_tapping.c ****                     return true;
 210:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 211:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 212:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last timeout tap(>1).\n");
 213:tmk_core/common/action_tapping.c ****                         // unregister key
 214:tmk_core/common/action_tapping.c ****                         process_record(&(keyrecord_t){.tap = tapping_key.tap, .event.key = tapping_
 215:tmk_core/common/action_tapping.c ****                     } else {
 216:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start while last timeout tap(1).\n");
 217:tmk_core/common/action_tapping.c ****                     }
 218:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 219:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 220:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 221:tmk_core/common/action_tapping.c ****                     return true;
 222:tmk_core/common/action_tapping.c ****                 } else {
 223:tmk_core/common/action_tapping.c ****                     if (!IS_NOEVENT(event)) {
 224:tmk_core/common/action_tapping.c ****                         debug("Tapping: key event while last timeout tap(>0).\n");
 225:tmk_core/common/action_tapping.c ****                     }
 226:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 227:tmk_core/common/action_tapping.c ****                     return true;
 228:tmk_core/common/action_tapping.c ****                 }
 229:tmk_core/common/action_tapping.c ****             }
 230:tmk_core/common/action_tapping.c ****         }
 231:tmk_core/common/action_tapping.c ****     } else if (IS_TAPPING_RELEASED()) {
 232:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 233:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 234:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key)) {
 235:tmk_core/common/action_tapping.c **** #    ifndef TAPPING_FORCE_HOLD
 236:tmk_core/common/action_tapping.c ****                     if (!tapping_key.tap.interrupted && tapping_key.tap.count > 0) {
 237:tmk_core/common/action_tapping.c ****                         // sequential tap.
 238:tmk_core/common/action_tapping.c ****                         keyp->tap = tapping_key.tap;
 239:tmk_core/common/action_tapping.c ****                         if (keyp->tap.count < 15) keyp->tap.count += 1;
 240:tmk_core/common/action_tapping.c ****                         debug("Tapping: Tap press(");
 241:tmk_core/common/action_tapping.c ****                         debug_dec(keyp->tap.count);
 242:tmk_core/common/action_tapping.c ****                         debug(")\n");
 243:tmk_core/common/action_tapping.c ****                         process_record(keyp);
 244:tmk_core/common/action_tapping.c ****                         tapping_key = *keyp;
 245:tmk_core/common/action_tapping.c ****                         debug_tapping_key();
 246:tmk_core/common/action_tapping.c ****                         return true;
 247:tmk_core/common/action_tapping.c ****                     }
 248:tmk_core/common/action_tapping.c **** #    endif
 249:tmk_core/common/action_tapping.c ****                     // FIX: start new tap again
 250:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 251:tmk_core/common/action_tapping.c ****                     return true;
 252:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key)) {
 253:tmk_core/common/action_tapping.c ****                     // Sequential tap can be interfered with other tap key.
 254:tmk_core/common/action_tapping.c ****                     debug("Tapping: Start with interfering other tap.\n");
 255:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 256:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 257:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 258:tmk_core/common/action_tapping.c ****                     return true;
 259:tmk_core/common/action_tapping.c ****                 } else {
 260:tmk_core/common/action_tapping.c ****                     // should none in buffer
 261:tmk_core/common/action_tapping.c ****                     // FIX: interrupted when other key is pressed
 262:tmk_core/common/action_tapping.c ****                     tapping_key.tap.interrupted = true;
 263:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 264:tmk_core/common/action_tapping.c ****                     return true;
 265:tmk_core/common/action_tapping.c ****                 }
 266:tmk_core/common/action_tapping.c ****             } else {
 267:tmk_core/common/action_tapping.c ****                 if (!IS_NOEVENT(event)) debug("Tapping: other key just after tap.\n");
 268:tmk_core/common/action_tapping.c ****                 process_record(keyp);
 269:tmk_core/common/action_tapping.c ****                 return true;
 270:tmk_core/common/action_tapping.c ****             }
 271:tmk_core/common/action_tapping.c ****         } else {
 272:tmk_core/common/action_tapping.c ****             // FIX: process_action here?
 273:tmk_core/common/action_tapping.c ****             // timeout. no sequential tap.
 274:tmk_core/common/action_tapping.c ****             debug("Tapping: End(Timeout after releasing last tap): ");
 275:tmk_core/common/action_tapping.c ****             debug_event(event);
 276:tmk_core/common/action_tapping.c ****             debug("\n");
 277:tmk_core/common/action_tapping.c ****             tapping_key = (keyrecord_t){};
 278:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 279:tmk_core/common/action_tapping.c ****             return false;
 280:tmk_core/common/action_tapping.c ****         }
 281:tmk_core/common/action_tapping.c ****     }
 282:tmk_core/common/action_tapping.c ****     // not tapping state
 283:tmk_core/common/action_tapping.c ****     else {
 284:tmk_core/common/action_tapping.c ****         if (event.pressed && is_tap_key(event.key)) {
 285:tmk_core/common/action_tapping.c ****             debug("Tapping: Start(Press tap key).\n");
 286:tmk_core/common/action_tapping.c ****             tapping_key = *keyp;
 287:tmk_core/common/action_tapping.c ****             process_record_tap_hint(&tapping_key);
 288:tmk_core/common/action_tapping.c ****             waiting_buffer_scan_tap();
 289:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 290:tmk_core/common/action_tapping.c ****             return true;
 291:tmk_core/common/action_tapping.c ****         } else {
 292:tmk_core/common/action_tapping.c ****             process_record(keyp);
 293:tmk_core/common/action_tapping.c ****             return true;
 294:tmk_core/common/action_tapping.c ****         }
 295:tmk_core/common/action_tapping.c ****     }
 296:tmk_core/common/action_tapping.c **** }
 297:tmk_core/common/action_tapping.c **** 
 298:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer enq
 299:tmk_core/common/action_tapping.c ****  *
 300:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 301:tmk_core/common/action_tapping.c ****  */
 302:tmk_core/common/action_tapping.c **** bool waiting_buffer_enq(keyrecord_t record) {
 303:tmk_core/common/action_tapping.c ****     if (IS_NOEVENT(record.event)) {
 304:tmk_core/common/action_tapping.c ****         return true;
 305:tmk_core/common/action_tapping.c ****     }
 306:tmk_core/common/action_tapping.c **** 
 307:tmk_core/common/action_tapping.c ****     if ((waiting_buffer_head + 1) % WAITING_BUFFER_SIZE == waiting_buffer_tail) {
 308:tmk_core/common/action_tapping.c ****         debug("waiting_buffer_enq: Over flow.\n");
 309:tmk_core/common/action_tapping.c ****         return false;
 310:tmk_core/common/action_tapping.c ****     }
 311:tmk_core/common/action_tapping.c **** 
 312:tmk_core/common/action_tapping.c ****     waiting_buffer[waiting_buffer_head] = record;
 313:tmk_core/common/action_tapping.c ****     waiting_buffer_head                 = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
 314:tmk_core/common/action_tapping.c **** 
 315:tmk_core/common/action_tapping.c ****     debug("waiting_buffer_enq: ");
 316:tmk_core/common/action_tapping.c ****     debug_waiting_buffer();
 317:tmk_core/common/action_tapping.c ****     return true;
 318:tmk_core/common/action_tapping.c **** }
 319:tmk_core/common/action_tapping.c **** 
 320:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer clear
 321:tmk_core/common/action_tapping.c ****  *
 322:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 323:tmk_core/common/action_tapping.c ****  */
 324:tmk_core/common/action_tapping.c **** void waiting_buffer_clear(void) {
 325:tmk_core/common/action_tapping.c ****     waiting_buffer_head = 0;
 326:tmk_core/common/action_tapping.c ****     waiting_buffer_tail = 0;
 327:tmk_core/common/action_tapping.c **** }
 328:tmk_core/common/action_tapping.c **** 
 329:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer typed
 330:tmk_core/common/action_tapping.c ****  *
 331:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 332:tmk_core/common/action_tapping.c ****  */
 333:tmk_core/common/action_tapping.c **** bool waiting_buffer_typed(keyevent_t event) {
 334:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
 335:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 336:tmk_core/common/action_tapping.c ****             return true;
 337:tmk_core/common/action_tapping.c ****         }
 338:tmk_core/common/action_tapping.c ****     }
 339:tmk_core/common/action_tapping.c ****     return false;
 340:tmk_core/common/action_tapping.c **** }
 341:tmk_core/common/action_tapping.c **** 
 342:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer has anykey pressed
 343:tmk_core/common/action_tapping.c ****  *
 344:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 345:tmk_core/common/action_tapping.c ****  */
 346:tmk_core/common/action_tapping.c **** __attribute__((unused)) bool waiting_buffer_has_anykey_pressed(void) {
 347:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
 348:tmk_core/common/action_tapping.c ****         if (waiting_buffer[i].event.pressed) return true;
 349:tmk_core/common/action_tapping.c ****     }
 350:tmk_core/common/action_tapping.c ****     return false;
 351:tmk_core/common/action_tapping.c **** }
 352:tmk_core/common/action_tapping.c **** 
 353:tmk_core/common/action_tapping.c **** /** \brief Scan buffer for tapping
 354:tmk_core/common/action_tapping.c ****  *
 355:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 356:tmk_core/common/action_tapping.c ****  */
 357:tmk_core/common/action_tapping.c **** void waiting_buffer_scan_tap(void) {
 358:tmk_core/common/action_tapping.c ****     // tapping already is settled
 359:tmk_core/common/action_tapping.c ****     if (tapping_key.tap.count > 0) return;
 360:tmk_core/common/action_tapping.c ****     // invalid state: tapping_key released && tap.count == 0
 361:tmk_core/common/action_tapping.c ****     if (!tapping_key.event.pressed) return;
 362:tmk_core/common/action_tapping.c **** 
 363:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
 364:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 365:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 366:tmk_core/common/action_tapping.c ****             waiting_buffer[i].tap.count = 1;
 367:tmk_core/common/action_tapping.c ****             process_record(&tapping_key);
 368:tmk_core/common/action_tapping.c **** 
 369:tmk_core/common/action_tapping.c ****             debug("waiting_buffer_scan_tap: found at [");
 370:tmk_core/common/action_tapping.c ****             debug_dec(i);
 371:tmk_core/common/action_tapping.c ****             debug("]\n");
 372:tmk_core/common/action_tapping.c ****             debug_waiting_buffer();
 373:tmk_core/common/action_tapping.c ****             return;
 374:tmk_core/common/action_tapping.c ****         }
 375:tmk_core/common/action_tapping.c ****     }
 376:tmk_core/common/action_tapping.c **** }
 377:tmk_core/common/action_tapping.c **** 
 378:tmk_core/common/action_tapping.c **** /** \brief Tapping key debug print
 379:tmk_core/common/action_tapping.c ****  *
 380:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 381:tmk_core/common/action_tapping.c ****  */
 382:tmk_core/common/action_tapping.c **** static void debug_tapping_key(void) {
 383:tmk_core/common/action_tapping.c ****     debug("TAPPING_KEY=");
 384:tmk_core/common/action_tapping.c ****     debug_record(tapping_key);
 385:tmk_core/common/action_tapping.c ****     debug("\n");
 386:tmk_core/common/action_tapping.c **** }
 387:tmk_core/common/action_tapping.c **** 
 388:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer debug print
 389:tmk_core/common/action_tapping.c ****  *
 390:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 391:tmk_core/common/action_tapping.c ****  */
 392:tmk_core/common/action_tapping.c **** static void debug_waiting_buffer(void) {
  25              		.loc 1 392 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29 0000 70B5     		push	{r4, r5, r6, lr}
  30              		.cfi_def_cfa_offset 16
  31              		.cfi_offset 4, -16
  32              		.cfi_offset 5, -12
  33              		.cfi_offset 6, -8
  34              		.cfi_offset 14, -4
  35              	.LBB40:
 393:tmk_core/common/action_tapping.c ****     debug("{ ");
 394:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
  36              		.loc 1 394 0
  37 0002 094B     		ldr	r3, .L4
  38 0004 094E     		ldr	r6, .L4+4
  39 0006 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
  40              	.LVL0:
 395:tmk_core/common/action_tapping.c ****         debug("[");
 396:tmk_core/common/action_tapping.c ****         debug_dec(i);
 397:tmk_core/common/action_tapping.c ****         debug("]=");
 398:tmk_core/common/action_tapping.c ****         debug_record(waiting_buffer[i]);
  41              		.loc 1 398 0
  42 0008 094D     		ldr	r5, .L4+8
  43              	.L2:
 394:tmk_core/common/action_tapping.c ****         debug("[");
  44              		.loc 1 394 0 discriminator 1
  45 000a 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
  46 000c A342     		cmp	r3, r4
  47 000e 00D1     		bne	.L3
  48              	.LBE40:
 399:tmk_core/common/action_tapping.c ****         debug(" ");
 400:tmk_core/common/action_tapping.c ****     }
 401:tmk_core/common/action_tapping.c ****     debug("}\n");
 402:tmk_core/common/action_tapping.c **** }
  49              		.loc 1 402 0
  50 0010 70BD     		pop	{r4, r5, r6, pc}
  51              	.LVL1:
  52              	.L3:
  53              	.LBB41:
 398:tmk_core/common/action_tapping.c ****         debug(" ");
  54              		.loc 1 398 0 discriminator 3
  55 0012 05EBC403 		add	r3, r5, r4, lsl #3
  56 0016 55F83400 		ldr	r0, [r5, r4, lsl #3]	@ unaligned
  57 001a 5968     		ldr	r1, [r3, #4]	@ unaligned
 394:tmk_core/common/action_tapping.c ****         debug("[");
  58              		.loc 1 394 0 discriminator 3
  59 001c 0134     		adds	r4, r4, #1
  60              	.LVL2:
 398:tmk_core/common/action_tapping.c ****         debug(" ");
  61              		.loc 1 398 0 discriminator 3
  62 001e FFF7FEFF 		bl	debug_record
  63              	.LVL3:
 394:tmk_core/common/action_tapping.c ****         debug("[");
  64              		.loc 1 394 0 discriminator 3
  65 0022 04F00704 		and	r4, r4, #7
  66              	.LVL4:
  67 0026 F0E7     		b	.L2
  68              	.L5:
  69              		.align	2
  70              	.L4:
  71 0028 00000000 		.word	.LANCHOR0
  72 002c 00000000 		.word	.LANCHOR2
  73 0030 00000000 		.word	.LANCHOR1
  74              	.LBE41:
  75              		.cfi_endproc
  76              	.LFE14:
  78              		.section	.text.debug_tapping_key,"ax",%progbits
  79              		.align	1
  80              		.syntax unified
  81              		.thumb
  82              		.thumb_func
  83              		.fpu softvfp
  85              	debug_tapping_key:
  86              	.LFB13:
 382:tmk_core/common/action_tapping.c ****     debug("TAPPING_KEY=");
  87              		.loc 1 382 0
  88              		.cfi_startproc
  89              		@ args = 0, pretend = 0, frame = 0
  90              		@ frame_needed = 0, uses_anonymous_args = 0
  91              		@ link register save eliminated.
 384:tmk_core/common/action_tapping.c ****     debug("\n");
  92              		.loc 1 384 0
  93 0000 024B     		ldr	r3, .L7
  94 0002 1868     		ldr	r0, [r3]	@ unaligned
  95 0004 5968     		ldr	r1, [r3, #4]	@ unaligned
  96 0006 FFF7FEBF 		b	debug_record
  97              	.LVL5:
  98              	.L8:
  99 000a 00BF     		.align	2
 100              	.L7:
 101 000c 00000000 		.word	.LANCHOR3
 102              		.cfi_endproc
 103              	.LFE13:
 105              		.section	.text.waiting_buffer_scan_tap,"ax",%progbits
 106              		.align	1
 107              		.syntax unified
 108              		.thumb
 109              		.thumb_func
 110              		.fpu softvfp
 112              	waiting_buffer_scan_tap:
 113              	.LFB12:
 357:tmk_core/common/action_tapping.c ****     // tapping already is settled
 114              		.loc 1 357 0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 8
 117              		@ frame_needed = 0, uses_anonymous_args = 0
 359:tmk_core/common/action_tapping.c ****     // invalid state: tapping_key released && tap.count == 0
 118              		.loc 1 359 0
 119 0000 284A     		ldr	r2, .L28
 120 0002 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 121 0004 13F0F00F 		tst	r3, #240
 357:tmk_core/common/action_tapping.c ****     // tapping already is settled
 122              		.loc 1 357 0
 123 0008 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 124              		.cfi_def_cfa_offset 32
 125              		.cfi_offset 4, -24
 126              		.cfi_offset 5, -20
 127              		.cfi_offset 6, -16
 128              		.cfi_offset 7, -12
 129              		.cfi_offset 8, -8
 130              		.cfi_offset 14, -4
 359:tmk_core/common/action_tapping.c ****     // invalid state: tapping_key released && tap.count == 0
 131              		.loc 1 359 0
 132 000c 0CD1     		bne	.L9
 361:tmk_core/common/action_tapping.c **** 
 133              		.loc 1 361 0
 134 000e 9378     		ldrb	r3, [r2, #2]	@ zero_extendqisi2
 135 0010 53B1     		cbz	r3, .L9
 136              	.LBB47:
 137              	.LBB48:
 363:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 138              		.loc 1 363 0
 139 0012 254B     		ldr	r3, .L28+4
 140 0014 DFF898C0 		ldr	ip, .L28+12
 141 0018 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 142              	.LVL6:
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 143              		.loc 1 364 0
 144 001a 244D     		ldr	r5, .L28+8
 145 001c 4FF6FF76 		movw	r6, #65535
 146              	.L13:
 363:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 147              		.loc 1 363 0
 148 0020 9CF80030 		ldrb	r3, [ip]	@ zero_extendqisi2
 149 0024 8B42     		cmp	r3, r1
 150 0026 02D1     		bne	.L17
 151              	.LVL7:
 152              	.L9:
 153              	.LBE48:
 154              	.LBE47:
 376:tmk_core/common/action_tapping.c **** 
 155              		.loc 1 376 0
 156 0028 02B0     		add	sp, sp, #8
 157              		.cfi_remember_state
 158              		.cfi_def_cfa_offset 24
 159              		@ sp needed
 160 002a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 161              	.LVL8:
 162              	.L17:
 163              		.cfi_restore_state
 164              	.LBB53:
 165              	.LBB51:
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 166              		.loc 1 364 0
 167 002e 9388     		ldrh	r3, [r2, #4]
 168              	.LBB49:
 169              	.LBB50:
 170              		.file 2 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 171              		.loc 2 48 0
 172 0030 002B     		cmp	r3, #0
 173 0032 33D0     		beq	.L14
 174 0034 1778     		ldrb	r7, [r2]	@ zero_extendqisi2
 175 0036 92F801E0 		ldrb	lr, [r2, #1]	@ zero_extendqisi2
 176 003a 8DF80470 		strb	r7, [sp, #4]
 177 003e 8DF805E0 		strb	lr, [sp, #5]
 178              	.LBE50:
 179              	.LBE49:
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 180              		.loc 1 364 0
 181 0042 BDF80400 		ldrh	r0, [sp, #4]
 182 0046 B042     		cmp	r0, r6
 183 0048 28D0     		beq	.L14
 184 004a C800     		lsls	r0, r1, #3
 185 004c 2C18     		adds	r4, r5, r0
 186 004e 94F80180 		ldrb	r8, [r4, #1]	@ zero_extendqisi2
 187 0052 F045     		cmp	r8, lr
 188 0054 22D1     		bne	.L14
 189 0056 15F831E0 		ldrb	lr, [r5, r1, lsl #3]	@ zero_extendqisi2
 190 005a BE45     		cmp	lr, r7
 191 005c 1ED1     		bne	.L14
 192 005e A778     		ldrb	r7, [r4, #2]	@ zero_extendqisi2
 193 0060 E7B9     		cbnz	r7, .L14
 194 0062 A488     		ldrh	r4, [r4, #4]
 195 0064 A342     		cmp	r3, r4
 196 0066 8ABF     		itet	hi
 197 0068 F31A     		subhi	r3, r6, r3
 198 006a E31A     		subls	r3, r4, r3
 199 006c 1B19     		addhi	r3, r3, r4
 200 006e C72B     		cmp	r3, #199
 201 0070 CCBF     		ite	gt
 202 0072 0023     		movgt	r3, #0
 203 0074 0123     		movle	r3, #1
 204 0076 8BB1     		cbz	r3, .L14
 365:tmk_core/common/action_tapping.c ****             waiting_buffer[i].tap.count = 1;
 205              		.loc 1 365 0
 206 0078 9379     		ldrb	r3, [r2, #6]	@ zero_extendqisi2
 207 007a 0121     		movs	r1, #1
 208              	.LVL9:
 209 007c 61F30713 		bfi	r3, r1, #4, #4
 210 0080 9371     		strb	r3, [r2, #6]
 366:tmk_core/common/action_tapping.c ****             process_record(&tapping_key);
 211              		.loc 1 366 0
 212 0082 2B18     		adds	r3, r5, r0
 367:tmk_core/common/action_tapping.c **** 
 213              		.loc 1 367 0
 214 0084 0748     		ldr	r0, .L28
 366:tmk_core/common/action_tapping.c ****             process_record(&tapping_key);
 215              		.loc 1 366 0
 216 0086 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 217 0088 61F30712 		bfi	r2, r1, #4, #4
 218 008c 9A71     		strb	r2, [r3, #6]
 367:tmk_core/common/action_tapping.c **** 
 219              		.loc 1 367 0
 220 008e FFF7FEFF 		bl	process_record
 221              	.LVL10:
 222              	.LBE51:
 223              	.LBE53:
 376:tmk_core/common/action_tapping.c **** 
 224              		.loc 1 376 0
 225 0092 02B0     		add	sp, sp, #8
 226              		.cfi_remember_state
 227              		.cfi_def_cfa_offset 24
 228              		@ sp needed
 229 0094 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 230              		.cfi_restore 14
 231              		.cfi_restore 8
 232              		.cfi_restore 7
 233              		.cfi_restore 6
 234              		.cfi_restore 5
 235              		.cfi_restore 4
 236              		.cfi_def_cfa_offset 0
 237              	.LBB54:
 238              	.LBB52:
 372:tmk_core/common/action_tapping.c ****             return;
 239              		.loc 1 372 0
 240 0098 FFF7FEBF 		b	debug_waiting_buffer
 241              	.LVL11:
 242              	.L14:
 243              		.cfi_restore_state
 363:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 244              		.loc 1 363 0
 245 009c 0131     		adds	r1, r1, #1
 246              	.LVL12:
 247 009e 01F00701 		and	r1, r1, #7
 248              	.LVL13:
 249 00a2 BDE7     		b	.L13
 250              	.L29:
 251              		.align	2
 252              	.L28:
 253 00a4 00000000 		.word	.LANCHOR3
 254 00a8 00000000 		.word	.LANCHOR0
 255 00ac 00000000 		.word	.LANCHOR1
 256 00b0 00000000 		.word	.LANCHOR2
 257              	.LBE52:
 258              	.LBE54:
 259              		.cfi_endproc
 260              	.LFE12:
 262              		.section	.text.process_tapping,"ax",%progbits
 263              		.align	1
 264              		.syntax unified
 265              		.thumb
 266              		.thumb_func
 267              		.fpu softvfp
 269              	process_tapping:
 270              	.LFB7:
  91:tmk_core/common/action_tapping.c ****     keyevent_t event = keyp->event;
 271              		.loc 1 91 0
 272              		.cfi_startproc
 273              		@ args = 0, pretend = 0, frame = 56
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              	.LVL14:
 276 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 277              		.cfi_def_cfa_offset 32
 278              		.cfi_offset 4, -32
 279              		.cfi_offset 5, -28
 280              		.cfi_offset 6, -24
 281              		.cfi_offset 7, -20
 282              		.cfi_offset 8, -16
 283              		.cfi_offset 9, -12
 284              		.cfi_offset 10, -8
 285              		.cfi_offset 14, -4
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 286              		.loc 1 95 0
 287 0004 A54C     		ldr	r4, .L124
  91:tmk_core/common/action_tapping.c ****     keyevent_t event = keyp->event;
 288              		.loc 1 91 0
 289 0006 0546     		mov	r5, r0
 290 0008 8EB0     		sub	sp, sp, #56
 291              		.cfi_def_cfa_offset 88
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 292              		.loc 1 95 0
 293 000a A788     		ldrh	r7, [r4, #4]
  92:tmk_core/common/action_tapping.c **** 
 294              		.loc 1 92 0
 295 000c 0068     		ldr	r0, [r0]	@ unaligned
 296              	.LVL15:
 297 000e 2188     		ldrh	r1, [r4]
 298 0010 0890     		str	r0, [sp, #32]
 299 0012 0DF1200C 		add	ip, sp, #32
 300 0016 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 301              	.LVL16:
 302 0018 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 303              	.LVL17:
 304 001a 95F80280 		ldrb	r8, [r5, #2]	@ zero_extendqisi2
 305              	.LVL18:
 306 001e B5F80490 		ldrh	r9, [r5, #4]
 307              	.LVL19:
 308 0022 ADF80410 		strh	r1, [sp, #4]	@ movhi
 309 0026 94F800E0 		ldrb	lr, [r4]	@ zero_extendqisi2
 310 002a 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 311              	.LBB75:
 312              	.LBB76:
 313              		.loc 2 48 0
 314 002c 002F     		cmp	r7, #0
 315 002e 00F03D81 		beq	.L31
 316              	.LBE76:
 317              	.LBE75:
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 318              		.loc 1 95 0
 319 0032 8EB2     		uxth	r6, r1
 320 0034 4FF6FF71 		movw	r1, #65535
 321 0038 8E42     		cmp	r6, r1
 322 003a 00F03781 		beq	.L31
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 323              		.loc 1 95 0 is_stmt 0 discriminator 1
 324 003e A678     		ldrb	r6, [r4, #2]	@ zero_extendqisi2
 325 0040 002E     		cmp	r6, #0
 326 0042 00F03381 		beq	.L31
  96:tmk_core/common/action_tapping.c ****             if (tapping_key.tap.count == 0) {
 327              		.loc 1 96 0 is_stmt 1
 328 0046 4F45     		cmp	r7, r9
 329 0048 8ABF     		itet	hi
 330 004a CF1B     		subhi	r7, r1, r7
 331 004c A9EB0707 		subls	r7, r9, r7
 332 0050 4F44     		addhi	r7, r7, r9
 333 0052 C72F     		cmp	r7, #199
 334 0054 A179     		ldrb	r1, [r4, #6]	@ zero_extendqisi2
 335 0056 CCBF     		ite	gt
 336 0058 0027     		movgt	r7, #0
 337 005a 0127     		movle	r7, #1
 338 005c 01F0F00A 		and	r10, r1, #240
 339 0060 002F     		cmp	r7, #0
 340 0062 00F0C980 		beq	.L34
  97:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
 341              		.loc 1 97 0
 342 0066 BAF1000F 		cmp	r10, #0
 343 006a 7BD1     		bne	.L35
 344              	.LBB77:
 345              	.LBB78:
 346              		.loc 2 48 0
 347 006c 8DF80900 		strb	r0, [sp, #9]
 348 0070 8DF808E0 		strb	lr, [sp, #8]
 349              	.LBE78:
 350              	.LBE77:
  98:tmk_core/common/action_tapping.c ****                     // first tap!
 351              		.loc 1 98 0
 352 0074 BDF808C0 		ldrh	ip, [sp, #8]
 353 0078 4FF6FF70 		movw	r0, #65535
 354 007c 8445     		cmp	ip, r0
 355 007e 4646     		mov	r6, r8
 356 0080 18D0     		beq	.L36
  98:tmk_core/common/action_tapping.c ****                     // first tap!
 357              		.loc 1 98 0 is_stmt 0 discriminator 1
 358 0082 8DF82020 		strb	r2, [sp, #32]
 359 0086 8DF82130 		strb	r3, [sp, #33]
 360 008a 2088     		ldrh	r0, [r4]
 361 008c BDF820C0 		ldrh	ip, [sp, #32]
 362 0090 8445     		cmp	ip, r0
 363 0092 0FD1     		bne	.L36
  98:tmk_core/common/action_tapping.c ****                     // first tap!
 364              		.loc 1 98 0 discriminator 2
 365 0094 76B9     		cbnz	r6, .L36
 101:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 366              		.loc 1 101 0 is_stmt 1
 367 0096 0123     		movs	r3, #1
 368              	.LVL20:
 369 0098 63F30711 		bfi	r1, r3, #4, #4
 370 009c A171     		strb	r1, [r4, #6]
 102:tmk_core/common/action_tapping.c ****                     process_record(&tapping_key);
 371              		.loc 1 102 0
 372 009e FFF7FEFF 		bl	debug_tapping_key
 373              	.LVL21:
 103:tmk_core/common/action_tapping.c **** 
 374              		.loc 1 103 0
 375 00a2 7E48     		ldr	r0, .L124
 376 00a4 FFF7FEFF 		bl	process_record
 377              	.LVL22:
 106:tmk_core/common/action_tapping.c ****                     // enqueue
 378              		.loc 1 106 0
 379 00a8 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 380 00aa AB71     		strb	r3, [r5, #6]
 381              	.LVL23:
 382              	.L67:
 296:tmk_core/common/action_tapping.c **** 
 383              		.loc 1 296 0
 384 00ac 3046     		mov	r0, r6
 385              	.LVL24:
 386 00ae 0EB0     		add	sp, sp, #56
 387              		.cfi_remember_state
 388              		.cfi_def_cfa_offset 32
 389              		@ sp needed
 390 00b0 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 391              	.LVL25:
 392              	.L36:
 393              		.cfi_restore_state
 394              	.LBB79:
 395              	.LBB80:
 396              	.LBB81:
 397              	.LBB82:
 398              		.loc 2 48 0
 399 00b4 B9F1000F 		cmp	r9, #0
 400 00b8 08D1     		bne	.L38
 401              	.L40:
 402              	.LBE82:
 403              	.LBE81:
 404              	.LBE80:
 405              	.LBE79:
 154:tmk_core/common/action_tapping.c ****                         tapping_key.tap.interrupted = true;
 406              		.loc 1 154 0
 407 00ba B8F1000F 		cmp	r8, #0
 408 00be F5D0     		beq	.L67
 409              	.L39:
 155:tmk_core/common/action_tapping.c ****                     }
 410              		.loc 1 155 0
 411 00c0 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 412              	.LVL26:
 413 00c2 43F00103 		orr	r3, r3, #1
 414 00c6 A371     		strb	r3, [r4, #6]
 415              	.LVL27:
 416              	.L122:
 158:tmk_core/common/action_tapping.c ****                 }
 417              		.loc 1 158 0
 418 00c8 0026     		movs	r6, #0
 419 00ca EFE7     		b	.L67
 420              	.LVL28:
 421              	.L38:
 422              	.LBB86:
 423              	.LBB85:
 424              	.LBB84:
 425              	.LBB83:
 426              		.loc 2 48 0
 427 00cc 8DF81C20 		strb	r2, [sp, #28]
 428 00d0 8DF81D30 		strb	r3, [sp, #29]
 429              	.LBE83:
 430              	.LBE84:
  49:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  50:tmk_core/common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
 431              		.loc 2 50 0
 432 00d4 BDF81C00 		ldrh	r0, [sp, #28]
 433 00d8 4FF6FF71 		movw	r1, #65535
 434 00dc 8842     		cmp	r0, r1
 435 00de ECD0     		beq	.L40
 436              	.LBE85:
 437              	.LBE86:
 133:tmk_core/common/action_tapping.c ****                     // Modifier should be retained till end of this tapping.
 438              		.loc 1 133 0
 439 00e0 B8F1000F 		cmp	r8, #0
 440 00e4 ECD1     		bne	.L39
 441              	.LBB87:
 442              	.LBB88:
 334:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 443              		.loc 1 334 0
 444 00e6 6E48     		ldr	r0, .L124+4
 445 00e8 6E49     		ldr	r1, .L124+8
 446 00ea 90F800C0 		ldrb	ip, [r0]	@ zero_extendqisi2
 447 00ee 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 448              	.LVL29:
 335:tmk_core/common/action_tapping.c ****             return true;
 449              		.loc 1 335 0
 450 00f0 6D48     		ldr	r0, .L124+12
 451              	.L41:
 334:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 452              		.loc 1 334 0
 453 00f2 6145     		cmp	r1, ip
 454 00f4 0FD1     		bne	.L43
 455              	.LVL30:
 456              	.LBE88:
 457              	.LBE87:
 458              	.LBB90:
 135:tmk_core/common/action_tapping.c ****                     switch (action.kind.id) {
 459              		.loc 1 135 0
 460 00f6 8DF82020 		strb	r2, [sp, #32]
 461 00fa 8DF82130 		strb	r3, [sp, #33]
 462 00fe 0898     		ldr	r0, [sp, #32]
 463 0100 FFF7FEFF 		bl	layer_switch_get_action
 464              	.LVL31:
 136:tmk_core/common/action_tapping.c ****                         case ACT_LMODS:
 465              		.loc 1 136 0
 466 0104 C0F30332 		ubfx	r2, r0, #12, #4
 135:tmk_core/common/action_tapping.c ****                     switch (action.kind.id) {
 467              		.loc 1 135 0
 468 0108 C3B2     		uxtb	r3, r0
 469              	.LVL32:
 136:tmk_core/common/action_tapping.c ****                         case ACT_LMODS:
 470              		.loc 1 136 0
 471 010a 032A     		cmp	r2, #3
 472 010c 1DD8     		bhi	.L48
 473 010e DFE802F0 		tbb	[pc, r2]
 474              	.L66:
 475 0112 13       		.byte	(.L45-.L66)/2
 476 0113 13       		.byte	(.L45-.L66)/2
 477 0114 21       		.byte	(.L49-.L66)/2
 478 0115 21       		.byte	(.L49-.L66)/2
 479              	.LVL33:
 480              		.p2align 1
 481              	.L43:
 482              	.LBE90:
 483              	.LBB91:
 484              	.LBB89:
 335:tmk_core/common/action_tapping.c ****             return true;
 485              		.loc 1 335 0
 486 0116 00EBC104 		add	r4, r0, r1, lsl #3
 487 011a 94F801E0 		ldrb	lr, [r4, #1]	@ zero_extendqisi2
 488 011e 9E45     		cmp	lr, r3
 489 0120 06D1     		bne	.L42
 490 0122 10F831E0 		ldrb	lr, [r0, r1, lsl #3]	@ zero_extendqisi2
 491 0126 9645     		cmp	lr, r2
 492 0128 02D1     		bne	.L42
 493 012a A478     		ldrb	r4, [r4, #2]	@ zero_extendqisi2
 494 012c 002C     		cmp	r4, #0
 495 012e BDD1     		bne	.L67
 496              	.L42:
 334:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 497              		.loc 1 334 0
 498 0130 0131     		adds	r1, r1, #1
 499              	.LVL34:
 500 0132 01F00701 		and	r1, r1, #7
 501              	.LVL35:
 502 0136 DCE7     		b	.L41
 503              	.LVL36:
 504              	.L45:
 505              	.LBE89:
 506              	.LBE91:
 507              	.LBB92:
 139:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 508              		.loc 1 139 0
 509 0138 10F4706F 		tst	r0, #3840
 510 013c 01D0     		beq	.L50
 139:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 511              		.loc 1 139 0 is_stmt 0 discriminator 1
 512 013e 002B     		cmp	r3, #0
 513 0140 B4D0     		beq	.L67
 514              	.L50:
 145:tmk_core/common/action_tapping.c ****                             break;
 515              		.loc 1 145 0 is_stmt 1
 516 0142 2033     		adds	r3, r3, #32
 517              	.LVL37:
 518 0144 DBB2     		uxtb	r3, r3
 519              	.LVL38:
 520 0146 072B     		cmp	r3, #7
 521 0148 B0D9     		bls	.L67
 522              	.L48:
 150:tmk_core/common/action_tapping.c ****                     return true;
 523              		.loc 1 150 0
 524 014a 2846     		mov	r0, r5
 525              	.LVL39:
 526 014c FFF7FEFF 		bl	process_record
 527              	.LVL40:
 528              	.L121:
 529              	.LBE92:
 171:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 530              		.loc 1 171 0
 531 0150 3E46     		mov	r6, r7
 532 0152 ABE7     		b	.L67
 533              	.LVL41:
 534              	.L49:
 535              	.LBB93:
 144:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 536              		.loc 1 144 0
 537 0154 10F4706F 		tst	r0, #3840
 538 0158 F3D0     		beq	.L50
 144:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 539              		.loc 1 144 0 is_stmt 0 discriminator 1
 540 015a AA79     		ldrb	r2, [r5, #6]	@ zero_extendqisi2
 541 015c 12F0F00F 		tst	r2, #240
 542 0160 EFD1     		bne	.L50
 543 0162 A3E7     		b	.L67
 544              	.LVL42:
 545              	.L35:
 546              	.LBE93:
 547              	.LBB94:
 548              	.LBB95:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 549              		.loc 2 48 0 is_stmt 1
 550 0164 8DF80D00 		strb	r0, [sp, #13]
 551 0168 8DF80CE0 		strb	lr, [sp, #12]
 552              	.LBE95:
 553              	.LBE94:
 163:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 554              		.loc 1 163 0
 555 016c BDF80C60 		ldrh	r6, [sp, #12]
 556 0170 4FF6FF70 		movw	r0, #65535
 557 0174 8642     		cmp	r6, r0
 558 0176 16D0     		beq	.L51
 163:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 559              		.loc 1 163 0 is_stmt 0 discriminator 1
 560 0178 8DF82020 		strb	r2, [sp, #32]
 561 017c 8DF82130 		strb	r3, [sp, #33]
 562 0180 2088     		ldrh	r0, [r4]
 563              	.LVL43:
 564 0182 BDF82060 		ldrh	r6, [sp, #32]
 565 0186 8642     		cmp	r6, r0
 566 0188 0DD1     		bne	.L51
 567              	.LVL44:
 163:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 568              		.loc 1 163 0 discriminator 2
 569 018a B8F1000F 		cmp	r8, #0
 570 018e 0AD1     		bne	.L51
 167:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 571              		.loc 1 167 0 is_stmt 1
 572 0190 A971     		strb	r1, [r5, #6]
 168:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 573              		.loc 1 168 0
 574 0192 2846     		mov	r0, r5
 575 0194 FFF7FEFF 		bl	process_record
 576              	.LVL45:
 169:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 577              		.loc 1 169 0
 578 0198 2B68     		ldr	r3, [r5]	@ unaligned
 579 019a 2360     		str	r3, [r4]	@ unaligned
 580 019c 6B68     		ldr	r3, [r5, #4]	@ unaligned
 581 019e 6360     		str	r3, [r4, #4]	@ unaligned
 170:tmk_core/common/action_tapping.c ****                     return true;
 582              		.loc 1 170 0
 583 01a0 FFF7FEFF 		bl	debug_tapping_key
 584              	.LVL46:
 585 01a4 D4E7     		b	.L121
 586              	.LVL47:
 587              	.L51:
 172:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 588              		.loc 1 172 0
 589 01a6 8DF82020 		strb	r2, [sp, #32]
 590 01aa 8DF82130 		strb	r3, [sp, #33]
 591 01ae 0898     		ldr	r0, [sp, #32]
 592 01b0 FFF7FEFF 		bl	is_tap_key
 593              	.LVL48:
 594 01b4 E0B1     		cbz	r0, .L62
 172:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 595              		.loc 1 172 0 is_stmt 0 discriminator 1
 596 01b6 B8F1000F 		cmp	r8, #0
 597 01ba 19D0     		beq	.L62
 173:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last tap(>1).\n");
 598              		.loc 1 173 0 is_stmt 1
 599 01bc A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 600 01be 1F2B     		cmp	r3, #31
 601 01c0 0CD9     		bls	.L54
 176:tmk_core/common/action_tapping.c ****                     } else {
 602              		.loc 1 176 0
 603 01c2 2288     		ldrh	r2, [r4]
 604 01c4 ADF82820 		strh	r2, [sp, #40]	@ movhi
 605 01c8 0022     		movs	r2, #0
 606 01ca 8DF82A20 		strb	r2, [sp, #42]
 607 01ce ADF82C90 		strh	r9, [sp, #44]	@ movhi
 608 01d2 8DF82E30 		strb	r3, [sp, #46]
 609 01d6 0AA8     		add	r0, sp, #40
 610              	.L118:
 611 01d8 FFF7FEFF 		bl	process_record
 612              	.LVL49:
 613              	.L54:
 180:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 614              		.loc 1 180 0
 615 01dc 2B68     		ldr	r3, [r5]	@ unaligned
 616 01de 2360     		str	r3, [r4]	@ unaligned
 617 01e0 6B68     		ldr	r3, [r5, #4]	@ unaligned
 618 01e2 6360     		str	r3, [r4, #4]	@ unaligned
 181:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 619              		.loc 1 181 0
 620 01e4 FFF7FEFF 		bl	waiting_buffer_scan_tap
 621              	.LVL50:
 182:tmk_core/common/action_tapping.c ****                     return true;
 622              		.loc 1 182 0
 623 01e8 FFF7FEFF 		bl	debug_tapping_key
 624              	.LVL51:
 625              	.L123:
 189:tmk_core/common/action_tapping.c ****                 }
 626              		.loc 1 189 0
 627 01ec 0126     		movs	r6, #1
 628 01ee 5DE7     		b	.L67
 629              	.L62:
 188:tmk_core/common/action_tapping.c ****                     return true;
 630              		.loc 1 188 0
 631 01f0 2846     		mov	r0, r5
 632 01f2 FFF7FEFF 		bl	process_record
 633              	.LVL52:
 634 01f6 F9E7     		b	.L123
 635              	.LVL53:
 636              	.L34:
 195:tmk_core/common/action_tapping.c ****                 debug("Tapping: End. Timeout. Not tap(0): ");
 637              		.loc 1 195 0
 638 01f8 BAF1000F 		cmp	r10, #0
 639 01fc 13D1     		bne	.L55
 197:tmk_core/common/action_tapping.c ****                 debug("\n");
 640              		.loc 1 197 0
 641 01fe 8DF82020 		strb	r2, [sp, #32]
 642 0202 8DF82130 		strb	r3, [sp, #33]
 643 0206 8DF82280 		strb	r8, [sp, #34]
 644 020a ADF82490 		strh	r9, [sp, #36]	@ movhi
 645 020e 9CE80300 		ldm	ip, {r0, r1}
 646 0212 FFF7FEFF 		bl	debug_event
 647              	.LVL54:
 199:tmk_core/common/action_tapping.c ****                 tapping_key = (keyrecord_t){};
 648              		.loc 1 199 0
 649 0216 2148     		ldr	r0, .L124
 650 0218 FFF7FEFF 		bl	process_record
 651              	.LVL55:
 200:tmk_core/common/action_tapping.c ****                 debug_tapping_key();
 652              		.loc 1 200 0
 653 021c 2760     		str	r7, [r4]	@ unaligned
 654 021e 6760     		str	r7, [r4, #4]	@ unaligned
 201:tmk_core/common/action_tapping.c ****                 return false;
 655              		.loc 1 201 0
 656 0220 FFF7FEFF 		bl	debug_tapping_key
 657              	.LVL56:
 658 0224 50E7     		b	.L122
 659              	.LVL57:
 660              	.L55:
 661              	.LBB96:
 662              	.LBB97:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 663              		.loc 2 48 0
 664 0226 8DF81100 		strb	r0, [sp, #17]
 665 022a 8DF810E0 		strb	lr, [sp, #16]
 666              	.LBE97:
 667              	.LBE96:
 204:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 668              		.loc 1 204 0
 669 022e BDF81070 		ldrh	r7, [sp, #16]
 670 0232 4FF6FF70 		movw	r0, #65535
 671 0236 8742     		cmp	r7, r0
 672 0238 14D0     		beq	.L56
 204:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 673              		.loc 1 204 0 is_stmt 0 discriminator 1
 674 023a 8DF82020 		strb	r2, [sp, #32]
 675 023e 8DF82130 		strb	r3, [sp, #33]
 676 0242 2088     		ldrh	r0, [r4]
 677              	.LVL58:
 678 0244 BDF82070 		ldrh	r7, [sp, #32]
 679 0248 8742     		cmp	r7, r0
 680 024a 0BD1     		bne	.L56
 681              	.LVL59:
 204:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 682              		.loc 1 204 0 discriminator 2
 683 024c B8F1000F 		cmp	r8, #0
 684 0250 08D1     		bne	.L56
 206:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 685              		.loc 1 206 0 is_stmt 1
 686 0252 A971     		strb	r1, [r5, #6]
 207:tmk_core/common/action_tapping.c ****                     tapping_key = (keyrecord_t){};
 687              		.loc 1 207 0
 688 0254 2846     		mov	r0, r5
 689 0256 FFF7FEFF 		bl	process_record
 690              	.LVL60:
 208:tmk_core/common/action_tapping.c ****                     return true;
 691              		.loc 1 208 0
 692 025a C4F80080 		str	r8, [r4]	@ unaligned
 693 025e C4F80480 		str	r8, [r4, #4]	@ unaligned
 209:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 694              		.loc 1 209 0
 695 0262 23E7     		b	.L67
 696              	.LVL61:
 697              	.L56:
 210:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 698              		.loc 1 210 0
 699 0264 8DF82020 		strb	r2, [sp, #32]
 700 0268 8DF82130 		strb	r3, [sp, #33]
 701 026c 0898     		ldr	r0, [sp, #32]
 702 026e FFF7FEFF 		bl	is_tap_key
 703              	.LVL62:
 704 0272 0028     		cmp	r0, #0
 705 0274 BCD0     		beq	.L62
 210:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 706              		.loc 1 210 0 is_stmt 0 discriminator 1
 707 0276 B8F1000F 		cmp	r8, #0
 708 027a B9D0     		beq	.L62
 211:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last timeout tap(>1).\n");
 709              		.loc 1 211 0 is_stmt 1
 710 027c A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 711 027e 1F2B     		cmp	r3, #31
 712 0280 ACD9     		bls	.L54
 214:tmk_core/common/action_tapping.c ****                     } else {
 713              		.loc 1 214 0
 714 0282 2288     		ldrh	r2, [r4]
 715 0284 ADF83020 		strh	r2, [sp, #48]	@ movhi
 716 0288 0022     		movs	r2, #0
 717 028a 8DF83220 		strb	r2, [sp, #50]
 718 028e ADF83490 		strh	r9, [sp, #52]	@ movhi
 719 0292 8DF83630 		strb	r3, [sp, #54]
 720 0296 0CA8     		add	r0, sp, #48
 721 0298 9EE7     		b	.L118
 722              	.L125:
 723 029a 00BF     		.align	2
 724              	.L124:
 725 029c 00000000 		.word	.LANCHOR3
 726 02a0 00000000 		.word	.LANCHOR2
 727 02a4 00000000 		.word	.LANCHOR0
 728 02a8 00000000 		.word	.LANCHOR1
 729              	.LVL63:
 730              	.L31:
 731              	.LBB98:
 732              	.LBB99:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 733              		.loc 2 48 0
 734 02ac 002F     		cmp	r7, #0
 735 02ae 72D0     		beq	.L58
 736 02b0 8DF814E0 		strb	lr, [sp, #20]
 737 02b4 8DF81500 		strb	r0, [sp, #21]
 738              	.LBE99:
 739              	.LBE98:
 231:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 740              		.loc 1 231 0
 741 02b8 BDF81410 		ldrh	r1, [sp, #20]
 742 02bc 4FF6FF76 		movw	r6, #65535
 743 02c0 B142     		cmp	r1, r6
 744 02c2 68D0     		beq	.L58
 231:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 745              		.loc 1 231 0 is_stmt 0 discriminator 1
 746 02c4 A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 747 02c6 0029     		cmp	r1, #0
 748 02c8 65D1     		bne	.L58
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 749              		.loc 1 232 0 is_stmt 1
 750 02ca 4F45     		cmp	r7, r9
 751 02cc 39D8     		bhi	.L59
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 752              		.loc 1 232 0 is_stmt 0 discriminator 1
 753 02ce A9EB0707 		sub	r7, r9, r7
 754 02d2 C72F     		cmp	r7, #199
 755              	.L119:
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 756              		.loc 1 232 0 discriminator 2
 757 02d4 CCBF     		ite	gt
 758 02d6 0026     		movgt	r6, #0
 759 02d8 0126     		movle	r6, #1
 760 02da 002E     		cmp	r6, #0
 761 02dc 4CD0     		beq	.L61
 233:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key)) {
 762              		.loc 1 233 0 is_stmt 1
 763 02de 4646     		mov	r6, r8
 764 02e0 002E     		cmp	r6, #0
 765 02e2 85D0     		beq	.L62
 766              	.LBB100:
 767              	.LBB101:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 768              		.loc 2 48 0
 769 02e4 8DF818E0 		strb	lr, [sp, #24]
 770 02e8 8DF81900 		strb	r0, [sp, #25]
 771              	.LBE101:
 772              	.LBE100:
 234:tmk_core/common/action_tapping.c **** #    ifndef TAPPING_FORCE_HOLD
 773              		.loc 1 234 0
 774 02ec BDF81800 		ldrh	r0, [sp, #24]
 775 02f0 4FF6FF71 		movw	r1, #65535
 776 02f4 8842     		cmp	r0, r1
 777 02f6 2DD0     		beq	.L63
 234:tmk_core/common/action_tapping.c **** #    ifndef TAPPING_FORCE_HOLD
 778              		.loc 1 234 0 is_stmt 0 discriminator 1
 779 02f8 8DF82020 		strb	r2, [sp, #32]
 780 02fc 8DF82130 		strb	r3, [sp, #33]
 781 0300 2188     		ldrh	r1, [r4]
 782              	.LVL64:
 783 0302 BDF82000 		ldrh	r0, [sp, #32]
 784 0306 8842     		cmp	r0, r1
 785 0308 24D1     		bne	.L63
 786              	.LVL65:
 236:tmk_core/common/action_tapping.c ****                         // sequential tap.
 787              		.loc 1 236 0 is_stmt 1
 788 030a A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 789              	.LVL66:
 790 030c DA07     		lsls	r2, r3, #31
 791              	.LVL67:
 792 030e 1CD4     		bmi	.L64
 236:tmk_core/common/action_tapping.c ****                         // sequential tap.
 793              		.loc 1 236 0 is_stmt 0 discriminator 1
 794 0310 13F0F00F 		tst	r3, #240
 795 0314 19D0     		beq	.L64
 239:tmk_core/common/action_tapping.c ****                         debug("Tapping: Tap press(");
 796              		.loc 1 239 0 is_stmt 1
 797 0316 03F0F002 		and	r2, r3, #240
 798 031a F02A     		cmp	r2, #240
 799 031c 1CBF     		itt	ne
 800 031e C3F30312 		ubfxne	r2, r3, #4, #4
 801 0322 0132     		addne	r2, r2, #1
 238:tmk_core/common/action_tapping.c ****                         if (keyp->tap.count < 15) keyp->tap.count += 1;
 802              		.loc 1 238 0
 803 0324 AB71     		strb	r3, [r5, #6]
 239:tmk_core/common/action_tapping.c ****                         debug("Tapping: Tap press(");
 804              		.loc 1 239 0
 805 0326 1CBF     		itt	ne
 806 0328 62F30713 		bfine	r3, r2, #4, #4
 807 032c AB71     		strbne	r3, [r5, #6]
 243:tmk_core/common/action_tapping.c ****                         tapping_key = *keyp;
 808              		.loc 1 243 0
 809 032e 2846     		mov	r0, r5
 810 0330 FFF7FEFF 		bl	process_record
 811              	.LVL68:
 244:tmk_core/common/action_tapping.c ****                         debug_tapping_key();
 812              		.loc 1 244 0
 813 0334 2B68     		ldr	r3, [r5]	@ unaligned
 814 0336 2360     		str	r3, [r4]	@ unaligned
 815 0338 6B68     		ldr	r3, [r5, #4]	@ unaligned
 816 033a 6360     		str	r3, [r4, #4]	@ unaligned
 817              	.L120:
 289:tmk_core/common/action_tapping.c ****             return true;
 818              		.loc 1 289 0
 819 033c FFF7FEFF 		bl	debug_tapping_key
 820              	.LVL69:
 290:tmk_core/common/action_tapping.c ****         } else {
 821              		.loc 1 290 0
 822 0340 B4E6     		b	.L67
 823              	.LVL70:
 824              	.L59:
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 825              		.loc 1 232 0 discriminator 2
 826 0342 F61B     		subs	r6, r6, r7
 827 0344 4E44     		add	r6, r6, r9
 828 0346 C72E     		cmp	r6, #199
 829 0348 C4E7     		b	.L119
 830              	.LVL71:
 831              	.L64:
 250:tmk_core/common/action_tapping.c ****                     return true;
 832              		.loc 1 250 0
 833 034a 2B68     		ldr	r3, [r5]	@ unaligned
 834 034c 2360     		str	r3, [r4]	@ unaligned
 835 034e 6B68     		ldr	r3, [r5, #4]	@ unaligned
 836 0350 6360     		str	r3, [r4, #4]	@ unaligned
 251:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key)) {
 837              		.loc 1 251 0
 838 0352 ABE6     		b	.L67
 839              	.LVL72:
 840              	.L63:
 252:tmk_core/common/action_tapping.c ****                     // Sequential tap can be interfered with other tap key.
 841              		.loc 1 252 0
 842 0354 8DF82020 		strb	r2, [sp, #32]
 843 0358 8DF82130 		strb	r3, [sp, #33]
 844 035c 0898     		ldr	r0, [sp, #32]
 845 035e FFF7FEFF 		bl	is_tap_key
 846              	.LVL73:
 847 0362 0028     		cmp	r0, #0
 848 0364 7FF43AAF 		bne	.L54
 262:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 849              		.loc 1 262 0
 850 0368 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 263:tmk_core/common/action_tapping.c ****                     return true;
 851              		.loc 1 263 0
 852 036a 2846     		mov	r0, r5
 262:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 853              		.loc 1 262 0
 854 036c 43F00103 		orr	r3, r3, #1
 855 0370 A371     		strb	r3, [r4, #6]
 263:tmk_core/common/action_tapping.c ****                     return true;
 856              		.loc 1 263 0
 857 0372 FFF7FEFF 		bl	process_record
 858              	.LVL74:
 264:tmk_core/common/action_tapping.c ****                 }
 859              		.loc 1 264 0
 860 0376 99E6     		b	.L67
 861              	.LVL75:
 862              	.L61:
 275:tmk_core/common/action_tapping.c ****             debug("\n");
 863              		.loc 1 275 0
 864 0378 8DF82280 		strb	r8, [sp, #34]
 865 037c ADF82490 		strh	r9, [sp, #36]	@ movhi
 866 0380 8DF82020 		strb	r2, [sp, #32]
 867 0384 8DF82130 		strb	r3, [sp, #33]
 868 0388 9CE80300 		ldm	ip, {r0, r1}
 869 038c FFF7FEFF 		bl	debug_event
 870              	.LVL76:
 277:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 871              		.loc 1 277 0
 872 0390 2660     		str	r6, [r4]	@ unaligned
 873 0392 6660     		str	r6, [r4, #4]	@ unaligned
 874 0394 D2E7     		b	.L120
 875              	.LVL77:
 876              	.L58:
 284:tmk_core/common/action_tapping.c ****             debug("Tapping: Start(Press tap key).\n");
 877              		.loc 1 284 0
 878 0396 B8F1000F 		cmp	r8, #0
 879 039a 3FF429AF 		beq	.L62
 284:tmk_core/common/action_tapping.c ****             debug("Tapping: Start(Press tap key).\n");
 880              		.loc 1 284 0 is_stmt 0 discriminator 1
 881 039e 8DF82020 		strb	r2, [sp, #32]
 882 03a2 8DF82130 		strb	r3, [sp, #33]
 883 03a6 0898     		ldr	r0, [sp, #32]
 884 03a8 FFF7FEFF 		bl	is_tap_key
 885              	.LVL78:
 886 03ac 0646     		mov	r6, r0
 887 03ae 0028     		cmp	r0, #0
 888 03b0 3FF41EAF 		beq	.L62
 286:tmk_core/common/action_tapping.c ****             process_record_tap_hint(&tapping_key);
 889              		.loc 1 286 0 is_stmt 1
 890 03b4 2B68     		ldr	r3, [r5]	@ unaligned
 891 03b6 2360     		str	r3, [r4]	@ unaligned
 892 03b8 6B68     		ldr	r3, [r5, #4]	@ unaligned
 287:tmk_core/common/action_tapping.c ****             waiting_buffer_scan_tap();
 893              		.loc 1 287 0
 894 03ba 0348     		ldr	r0, .L126
 286:tmk_core/common/action_tapping.c ****             process_record_tap_hint(&tapping_key);
 895              		.loc 1 286 0
 896 03bc 6360     		str	r3, [r4, #4]	@ unaligned
 287:tmk_core/common/action_tapping.c ****             waiting_buffer_scan_tap();
 897              		.loc 1 287 0
 898 03be FFF7FEFF 		bl	process_record_tap_hint
 899              	.LVL79:
 288:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 900              		.loc 1 288 0
 901 03c2 FFF7FEFF 		bl	waiting_buffer_scan_tap
 902              	.LVL80:
 903 03c6 B9E7     		b	.L120
 904              	.L127:
 905              		.align	2
 906              	.L126:
 907 03c8 00000000 		.word	.LANCHOR3
 908              		.cfi_endproc
 909              	.LFE7:
 911              		.section	.text.get_tapping_term,"ax",%progbits
 912              		.align	1
 913              		.weak	get_tapping_term
 914              		.syntax unified
 915              		.thumb
 916              		.thumb_func
 917              		.fpu softvfp
 919              	get_tapping_term:
 920              	.LFB5:
  22:tmk_core/common/action_tapping.c **** 
 921              		.loc 1 22 0
 922              		.cfi_startproc
 923              		@ args = 0, pretend = 0, frame = 0
 924              		@ frame_needed = 0, uses_anonymous_args = 0
 925              		@ link register save eliminated.
 926              	.LVL81:
  22:tmk_core/common/action_tapping.c **** 
 927              		.loc 1 22 0
 928 0000 C820     		movs	r0, #200
 929              	.LVL82:
 930 0002 7047     		bx	lr
 931              		.cfi_endproc
 932              	.LFE5:
 934              		.section	.text.action_tapping_process,"ax",%progbits
 935              		.align	1
 936              		.global	action_tapping_process
 937              		.syntax unified
 938              		.thumb
 939              		.thumb_func
 940              		.fpu softvfp
 942              	action_tapping_process:
 943              	.LFB6:
  48:tmk_core/common/action_tapping.c ****     if (process_tapping(&record)) {
 944              		.loc 1 48 0
 945              		.cfi_startproc
 946              		@ args = 0, pretend = 0, frame = 24
 947              		@ frame_needed = 0, uses_anonymous_args = 0
 948 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 949              		.cfi_def_cfa_offset 20
 950              		.cfi_offset 4, -20
 951              		.cfi_offset 5, -16
 952              		.cfi_offset 6, -12
 953              		.cfi_offset 7, -8
 954              		.cfi_offset 14, -4
 955 0002 87B0     		sub	sp, sp, #28
 956              		.cfi_def_cfa_offset 48
  48:tmk_core/common/action_tapping.c ****     if (process_tapping(&record)) {
 957              		.loc 1 48 0
 958 0004 6C46     		mov	r4, sp
 959 0006 84E80300 		stm	r4, {r0, r1}
  49:tmk_core/common/action_tapping.c ****         if (!IS_NOEVENT(record.event)) {
 960              		.loc 1 49 0
 961 000a 2046     		mov	r0, r4
 962 000c FFF7FEFF 		bl	process_tapping
 963              	.LVL83:
 964 0010 2D4E     		ldr	r6, .L145
 965 0012 2E4D     		ldr	r5, .L145+4
 966 0014 0746     		mov	r7, r0
 967 0016 88B1     		cbz	r0, .L130
  50:tmk_core/common/action_tapping.c ****             debug("processed: ");
 968              		.loc 1 50 0
 969 0018 BDF80430 		ldrh	r3, [sp, #4]
 970 001c BDF80020 		ldrh	r2, [sp]
 971 0020 ADF80820 		strh	r2, [sp, #8]	@ movhi
 972              	.LBB110:
 973              	.LBB111:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 974              		.loc 2 48 0
 975 0024 43B1     		cbz	r3, .L132
 976              	.LBE111:
 977              	.LBE110:
  50:tmk_core/common/action_tapping.c ****             debug("processed: ");
 978              		.loc 1 50 0
 979 0026 92B2     		uxth	r2, r2
 980 0028 4FF6FF73 		movw	r3, #65535
 981 002c 9A42     		cmp	r2, r3
 982 002e 03D0     		beq	.L132
  52:tmk_core/common/action_tapping.c ****             debug("\n");
 983              		.loc 1 52 0
 984 0030 94E80300 		ldm	r4, {r0, r1}
 985 0034 FFF7FEFF 		bl	debug_record
 986              	.LVL84:
 987              	.L132:
  70:tmk_core/common/action_tapping.c ****             debug("processed: waiting_buffer[");
 988              		.loc 1 70 0 discriminator 1
 989 0038 254C     		ldr	r4, .L145+8
 990 003a 40E0     		b	.L136
 991              	.L130:
 992 003c 94E80300 		ldm	r4, {r0, r1}
 993 0040 04AB     		add	r3, sp, #16
 994 0042 83E80300 		stm	r3, {r0, r1}
 995 0046 BDF80420 		ldrh	r2, [sp, #4]
 996              	.LVL85:
 997 004a BDF81010 		ldrh	r1, [sp, #16]
 998 004e ADF80C10 		strh	r1, [sp, #12]	@ movhi
 999              	.LBB112:
 1000              	.LBB113:
 1001              	.LBB114:
 1002              	.LBB115:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 1003              		.loc 2 48 0
 1004 0052 002A     		cmp	r2, #0
 1005 0054 F0D0     		beq	.L132
 1006              	.LBE115:
 1007              	.LBE114:
 303:tmk_core/common/action_tapping.c ****         return true;
 1008              		.loc 1 303 0
 1009 0056 89B2     		uxth	r1, r1
 1010 0058 4FF6FF72 		movw	r2, #65535
 1011              	.LVL86:
 1012 005c 9142     		cmp	r1, r2
 1013 005e EBD0     		beq	.L132
 307:tmk_core/common/action_tapping.c ****         debug("waiting_buffer_enq: Over flow.\n");
 1014              		.loc 1 307 0
 1015 0060 3478     		ldrb	r4, [r6]	@ zero_extendqisi2
 1016 0062 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 1017 0064 621C     		adds	r2, r4, #1
 1018 0066 02F00702 		and	r2, r2, #7
 1019 006a 8A42     		cmp	r2, r1
 1020 006c 0BD0     		beq	.L133
 312:tmk_core/common/action_tapping.c ****     waiting_buffer_head                 = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
 1021              		.loc 1 312 0
 1022 006e 184F     		ldr	r7, .L145+8
 313:tmk_core/common/action_tapping.c **** 
 1023              		.loc 1 313 0
 1024 0070 3270     		strb	r2, [r6]
 312:tmk_core/common/action_tapping.c ****     waiting_buffer_head                 = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
 1025              		.loc 1 312 0
 1026 0072 03CB     		ldmia	r3!, {r0, r1}
 1027 0074 07EBC40C 		add	ip, r7, r4, lsl #3
 1028 0078 47F83400 		str	r0, [r7, r4, lsl #3]	@ unaligned
 1029 007c CCF80410 		str	r1, [ip, #4]	@ unaligned
 316:tmk_core/common/action_tapping.c ****     return true;
 1030              		.loc 1 316 0
 1031 0080 FFF7FEFF 		bl	debug_waiting_buffer
 1032              	.LVL87:
 1033 0084 D8E7     		b	.L132
 1034              	.LVL88:
 1035              	.L133:
 1036              	.LBE113:
 1037              	.LBE112:
  59:tmk_core/common/action_tapping.c ****             waiting_buffer_clear();
 1038              		.loc 1 59 0
 1039 0086 FFF7FEFF 		bl	clear_keyboard
 1040              	.LVL89:
  61:tmk_core/common/action_tapping.c ****         }
 1041              		.loc 1 61 0
 1042 008a 124B     		ldr	r3, .L145+12
 1043              	.LBB116:
 1044              	.LBB117:
 325:tmk_core/common/action_tapping.c ****     waiting_buffer_tail = 0;
 1045              		.loc 1 325 0
 1046 008c 3770     		strb	r7, [r6]
 326:tmk_core/common/action_tapping.c **** }
 1047              		.loc 1 326 0
 1048 008e 2F70     		strb	r7, [r5]
 1049              	.LBE117:
 1050              	.LBE116:
  61:tmk_core/common/action_tapping.c ****         }
 1051              		.loc 1 61 0
 1052 0090 1F60     		str	r7, [r3]	@ unaligned
 1053 0092 5F60     		str	r7, [r3, #4]	@ unaligned
 1054              	.L129:
  83:tmk_core/common/action_tapping.c **** 
 1055              		.loc 1 83 0
 1056 0094 07B0     		add	sp, sp, #28
 1057              		.cfi_remember_state
 1058              		.cfi_def_cfa_offset 20
 1059              		@ sp needed
 1060 0096 F0BD     		pop	{r4, r5, r6, r7, pc}
 1061              	.L137:
 1062              		.cfi_restore_state
  70:tmk_core/common/action_tapping.c ****             debug("processed: waiting_buffer[");
 1063              		.loc 1 70 0
 1064 0098 04EBC000 		add	r0, r4, r0, lsl #3
 1065 009c FFF7FEFF 		bl	process_tapping
 1066              	.LVL90:
 1067 00a0 0028     		cmp	r0, #0
 1068 00a2 F7D0     		beq	.L129
  74:tmk_core/common/action_tapping.c ****             debug("\n\n");
 1069              		.loc 1 74 0
 1070 00a4 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1071 00a6 04EBC302 		add	r2, r4, r3, lsl #3
 1072 00aa 54F83300 		ldr	r0, [r4, r3, lsl #3]	@ unaligned
 1073 00ae 5168     		ldr	r1, [r2, #4]	@ unaligned
 1074 00b0 FFF7FEFF 		bl	debug_record
 1075              	.LVL91:
  69:tmk_core/common/action_tapping.c ****         if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
 1076              		.loc 1 69 0
 1077 00b4 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1078 00b6 0133     		adds	r3, r3, #1
 1079 00b8 03F00703 		and	r3, r3, #7
 1080 00bc 2B70     		strb	r3, [r5]
 1081              	.L136:
  69:tmk_core/common/action_tapping.c ****         if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
 1082              		.loc 1 69 0 is_stmt 0 discriminator 1
 1083 00be 2878     		ldrb	r0, [r5]	@ zero_extendqisi2
 1084 00c0 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1085 00c2 8342     		cmp	r3, r0
 1086 00c4 E8D1     		bne	.L137
 1087 00c6 E5E7     		b	.L129
 1088              	.L146:
 1089              		.align	2
 1090              	.L145:
 1091 00c8 00000000 		.word	.LANCHOR2
 1092 00cc 00000000 		.word	.LANCHOR0
 1093 00d0 00000000 		.word	.LANCHOR1
 1094 00d4 00000000 		.word	.LANCHOR3
 1095              		.cfi_endproc
 1096              	.LFE6:
 1098              		.section	.bss.tapping_key,"aw",%nobits
 1099              		.align	1
 1100              		.set	.LANCHOR3,. + 0
 1103              	tapping_key:
 1104 0000 00000000 		.space	8
 1104      00000000 
 1105              		.section	.bss.waiting_buffer,"aw",%nobits
 1106              		.align	1
 1107              		.set	.LANCHOR1,. + 0
 1110              	waiting_buffer:
 1111 0000 00000000 		.space	64
 1111      00000000 
 1111      00000000 
 1111      00000000 
 1111      00000000 
 1112              		.section	.bss.waiting_buffer_head,"aw",%nobits
 1113              		.set	.LANCHOR2,. + 0
 1116              	waiting_buffer_head:
 1117 0000 00       		.space	1
 1118              		.section	.bss.waiting_buffer_tail,"aw",%nobits
 1119              		.set	.LANCHOR0,. + 0
 1122              	waiting_buffer_tail:
 1123 0000 00       		.space	1
 1124              		.text
 1125              	.Letext0:
 1126              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 1127              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 1128              		.file 5 "tmk_core/common/keycode.h"
 1129              		.file 6 "tmk_core/common/action_code.h"
 1130              		.file 7 "tmk_core/common/action.h"
 1131              		.file 8 "tmk_core/common/action_layer.h"
 1132              		.file 9 "tmk_core/common/timer.h"
 1133              		.file 10 "tmk_core/common/debug.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action_tapping.c
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:16     .text.debug_waiting_buffer:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:22     .text.debug_waiting_buffer:0000000000000000 debug_waiting_buffer
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:71     .text.debug_waiting_buffer:0000000000000028 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:79     .text.debug_tapping_key:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:85     .text.debug_tapping_key:0000000000000000 debug_tapping_key
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:101    .text.debug_tapping_key:000000000000000c $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:106    .text.waiting_buffer_scan_tap:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:112    .text.waiting_buffer_scan_tap:0000000000000000 waiting_buffer_scan_tap
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:253    .text.waiting_buffer_scan_tap:00000000000000a4 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:263    .text.process_tapping:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:269    .text.process_tapping:0000000000000000 process_tapping
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:475    .text.process_tapping:0000000000000112 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:480    .text.process_tapping:0000000000000116 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:725    .text.process_tapping:000000000000029c $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:734    .text.process_tapping:00000000000002ac $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:907    .text.process_tapping:00000000000003c8 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:912    .text.get_tapping_term:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:919    .text.get_tapping_term:0000000000000000 get_tapping_term
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:935    .text.action_tapping_process:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:942    .text.action_tapping_process:0000000000000000 action_tapping_process
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1091   .text.action_tapping_process:00000000000000c8 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1099   .bss.tapping_key:0000000000000000 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1103   .bss.tapping_key:0000000000000000 tapping_key
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1106   .bss.waiting_buffer:0000000000000000 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1110   .bss.waiting_buffer:0000000000000000 waiting_buffer
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1116   .bss.waiting_buffer_head:0000000000000000 waiting_buffer_head
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1117   .bss.waiting_buffer_head:0000000000000000 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1122   .bss.waiting_buffer_tail:0000000000000000 waiting_buffer_tail
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccXps0Rw.s:1123   .bss.waiting_buffer_tail:0000000000000000 $d

UNDEFINED SYMBOLS
debug_record
process_record
layer_switch_get_action
is_tap_key
debug_event
process_record_tap_hint
clear_keyboard

   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 2
  11              		.file	"action.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.action_exec,"ax",%progbits
  16              		.align	1
  17              		.global	action_exec
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	action_exec:
  24              	.LFB285:
  25              		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #    include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #    include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #    include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  48:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  49:tmk_core/common/action.c **** #endif
  50:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  51:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** /** \brief Called to execute an action.
  54:tmk_core/common/action.c ****  *
  55:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  56:tmk_core/common/action.c ****  */
  57:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  26              		.loc 1 57 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 16
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 84B0     		sub	sp, sp, #16
  32              		.cfi_def_cfa_offset 16
  33              	.LVL0:
  34              		.loc 1 57 0
  35 0002 6B46     		mov	r3, sp
  36 0004 83E80300 		stm	r3, {r0, r1}
  37              	.LVL1:
  58:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  59:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  60:tmk_core/common/action.c ****         dprint("EVENT: ");
  61:tmk_core/common/action.c ****         debug_event(event);
  62:tmk_core/common/action.c ****         dprintln();
  63:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  64:tmk_core/common/action.c ****         retro_tapping_counter++;
  65:tmk_core/common/action.c **** #endif
  66:tmk_core/common/action.c ****     }
  67:tmk_core/common/action.c **** 
  68:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  69:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  70:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  71:tmk_core/common/action.c ****     }
  72:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  73:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c ****     fauxclicky_check();
  76:tmk_core/common/action.c **** #endif
  77:tmk_core/common/action.c **** 
  78:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  79:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  80:tmk_core/common/action.c ****         process_hand_swap(&event);
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** #endif
  83:tmk_core/common/action.c **** 
  84:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  38              		.loc 1 84 0
  39 0008 0022     		movs	r2, #0
  40 000a ADF80E20 		strh	r2, [sp, #14]	@ movhi
  41 000e 93E80300 		ldm	r3, {r0, r1}
  85:tmk_core/common/action.c **** 
  86:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  87:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  88:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  91:tmk_core/common/action.c ****         clear_oneshot_mods();
  92:tmk_core/common/action.c ****     }
  93:tmk_core/common/action.c **** #endif
  94:tmk_core/common/action.c **** 
  95:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  96:tmk_core/common/action.c ****     action_tapping_process(record);
  42              		.loc 1 96 0
  43 0012 04AB     		add	r3, sp, #16
  84:tmk_core/common/action.c **** 
  44              		.loc 1 84 0
  45 0014 0290     		str	r0, [sp, #8]
  46 0016 ADF80C10 		strh	r1, [sp, #12]	@ movhi
  47              		.loc 1 96 0
  48 001a 13E90300 		ldmdb	r3, {r0, r1}
  97:tmk_core/common/action.c **** #else
  98:tmk_core/common/action.c ****     process_record(&record);
  99:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 100:tmk_core/common/action.c ****         dprint("processed: ");
 101:tmk_core/common/action.c ****         debug_record(record);
 102:tmk_core/common/action.c ****         dprintln();
 103:tmk_core/common/action.c ****     }
 104:tmk_core/common/action.c **** #endif
 105:tmk_core/common/action.c **** }
  49              		.loc 1 105 0
  50 001e 04B0     		add	sp, sp, #16
  51              		.cfi_def_cfa_offset 0
  52              		@ sp needed
  96:tmk_core/common/action.c **** #else
  53              		.loc 1 96 0
  54 0020 FFF7FEBF 		b	action_tapping_process
  55              	.LVL2:
  56              		.cfi_endproc
  57              	.LFE285:
  59              		.section	.text.process_record_quantum,"ax",%progbits
  60              		.align	1
  61              		.weak	process_record_quantum
  62              		.syntax unified
  63              		.thumb
  64              		.thumb_func
  65              		.fpu softvfp
  67              	process_record_quantum:
  68              	.LFB287:
 106:tmk_core/common/action.c **** 
 107:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 108:tmk_core/common/action.c **** bool swap_hands = false;
 109:tmk_core/common/action.c **** bool swap_held  = false;
 110:tmk_core/common/action.c **** 
 111:tmk_core/common/action.c **** /** \brief Process Hand Swap
 112:tmk_core/common/action.c ****  *
 113:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 114:tmk_core/common/action.c ****  */
 115:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 116:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 117:tmk_core/common/action.c **** 
 118:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 119:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 120:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 121:tmk_core/common/action.c **** 
 122:tmk_core/common/action.c ****     if (do_swap) {
 123:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 124:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 125:tmk_core/common/action.c ****     } else {
 126:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 127:tmk_core/common/action.c ****     }
 128:tmk_core/common/action.c **** }
 129:tmk_core/common/action.c **** #endif
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 132:tmk_core/common/action.c **** bool disable_action_cache = false;
 133:tmk_core/common/action.c **** 
 134:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 135:tmk_core/common/action.c ****     disable_action_cache = true;
 136:tmk_core/common/action.c ****     process_record(record);
 137:tmk_core/common/action.c ****     disable_action_cache = false;
 138:tmk_core/common/action.c **** }
 139:tmk_core/common/action.c **** #else
 140:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 141:tmk_core/common/action.c **** #endif
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  69              		.loc 1 143 0
  70              		.cfi_startproc
  71              		@ args = 0, pretend = 0, frame = 0
  72              		@ frame_needed = 0, uses_anonymous_args = 0
  73              		@ link register save eliminated.
  74              	.LVL3:
  75              		.loc 1 143 0
  76 0000 0120     		movs	r0, #1
  77              	.LVL4:
  78 0002 7047     		bx	lr
  79              		.cfi_endproc
  80              	.LFE287:
  82              		.section	.text.process_record_tap_hint,"ax",%progbits
  83              		.align	1
  84              		.global	process_record_tap_hint
  85              		.syntax unified
  86              		.thumb
  87              		.thumb_func
  88              		.fpu softvfp
  90              	process_record_tap_hint:
  91              	.LFB288:
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 146:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 147:tmk_core/common/action.c ****  *
 148:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 149:tmk_core/common/action.c ****  */
 150:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
  92              		.loc 1 150 0
  93              		.cfi_startproc
  94              		@ args = 0, pretend = 0, frame = 0
  95              		@ frame_needed = 0, uses_anonymous_args = 0
  96              		@ link register save eliminated.
  97              	.LVL5:
 151:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
  98              		.loc 1 151 0
  99 0000 0088     		ldrh	r0, [r0]
 100              	.LVL6:
 101 0002 FFF7FEBF 		b	layer_switch_get_action
 102              	.LVL7:
 103              		.cfi_endproc
 104              	.LFE288:
 106              		.section	.text.register_code,"ax",%progbits
 107              		.align	1
 108              		.global	register_code
 109              		.syntax unified
 110              		.thumb
 111              		.thumb_func
 112              		.fpu softvfp
 114              	register_code:
 115              	.LFB291:
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c ****     switch (action.kind.id) {
 154:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 155:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:tmk_core/common/action.c ****             switch (action.swap.code) {
 157:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:tmk_core/common/action.c ****                 default:
 159:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:tmk_core/common/action.c ****                     swap_held  = true;
 161:tmk_core/common/action.c ****             }
 162:tmk_core/common/action.c ****             break;
 163:tmk_core/common/action.c **** #    endif
 164:tmk_core/common/action.c ****     }
 165:tmk_core/common/action.c **** }
 166:tmk_core/common/action.c **** #endif
 167:tmk_core/common/action.c **** 
 168:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:tmk_core/common/action.c ****  *
 170:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:tmk_core/common/action.c ****  */
 172:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 173:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 174:tmk_core/common/action.c ****         return;
 175:tmk_core/common/action.c ****     }
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:tmk_core/common/action.c ****     dprint("ACTION: ");
 181:tmk_core/common/action.c ****     debug_action(action);
 182:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 183:tmk_core/common/action.c ****     dprint(" layer_state: ");
 184:tmk_core/common/action.c ****     layer_debug();
 185:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 186:tmk_core/common/action.c ****     default_layer_debug();
 187:tmk_core/common/action.c **** #endif
 188:tmk_core/common/action.c ****     dprintln();
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c ****     process_action(record, action);
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 194:tmk_core/common/action.c ****  *
 195:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 196:tmk_core/common/action.c ****  */
 197:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 198:tmk_core/common/action.c ****     keyevent_t event = record->event;
 199:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 200:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 201:tmk_core/common/action.c **** #endif
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (event.pressed) {
 204:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 205:tmk_core/common/action.c ****         clear_weak_mods();
 206:tmk_core/common/action.c ****     }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 209:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 210:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 211:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 212:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 213:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 214:tmk_core/common/action.c ****     }
 215:tmk_core/common/action.c **** #endif
 216:tmk_core/common/action.c **** 
 217:tmk_core/common/action.c ****     switch (action.kind.id) {
 218:tmk_core/common/action.c ****         /* Key and Mods */
 219:tmk_core/common/action.c ****         case ACT_LMODS:
 220:tmk_core/common/action.c ****         case ACT_RMODS: {
 221:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 222:tmk_core/common/action.c ****             if (event.pressed) {
 223:tmk_core/common/action.c ****                 if (mods) {
 224:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 226:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 227:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 228:tmk_core/common/action.c ****                         add_mods(mods);
 229:tmk_core/common/action.c ****                     } else {
 230:tmk_core/common/action.c ****                         add_weak_mods(mods);
 231:tmk_core/common/action.c ****                     }
 232:tmk_core/common/action.c ****                     send_keyboard_report();
 233:tmk_core/common/action.c ****                 }
 234:tmk_core/common/action.c ****                 register_code(action.key.code);
 235:tmk_core/common/action.c ****             } else {
 236:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 237:tmk_core/common/action.c ****                 if (mods) {
 238:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:tmk_core/common/action.c ****                         del_mods(mods);
 240:tmk_core/common/action.c ****                     } else {
 241:tmk_core/common/action.c ****                         del_weak_mods(mods);
 242:tmk_core/common/action.c ****                     }
 243:tmk_core/common/action.c ****                     send_keyboard_report();
 244:tmk_core/common/action.c ****                 }
 245:tmk_core/common/action.c ****             }
 246:tmk_core/common/action.c ****         } break;
 247:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 248:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 249:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 250:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 251:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 252:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 253:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 254:tmk_core/common/action.c ****                     // Oneshot modifier
 255:tmk_core/common/action.c ****                     if (event.pressed) {
 256:tmk_core/common/action.c ****                         if (tap_count == 0) {
 257:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 258:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 259:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 260:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 261:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 263:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 264:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 265:tmk_core/common/action.c ****                             clear_oneshot_mods();
 266:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 267:tmk_core/common/action.c ****                             register_mods(mods);
 268:tmk_core/common/action.c **** #        endif
 269:tmk_core/common/action.c ****                         } else {
 270:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 271:tmk_core/common/action.c ****                         }
 272:tmk_core/common/action.c ****                     } else {
 273:tmk_core/common/action.c ****                         if (tap_count == 0) {
 274:tmk_core/common/action.c ****                             clear_oneshot_mods();
 275:tmk_core/common/action.c ****                             unregister_mods(mods);
 276:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 277:tmk_core/common/action.c ****                             // Retain Oneshot mods
 278:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 279:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 280:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 281:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 282:tmk_core/common/action.c ****                                 unregister_mods(mods);
 283:tmk_core/common/action.c ****                             }
 284:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 285:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 286:tmk_core/common/action.c **** #        endif
 287:tmk_core/common/action.c ****                         } else {
 288:tmk_core/common/action.c ****                             clear_oneshot_mods();
 289:tmk_core/common/action.c ****                             unregister_mods(mods);
 290:tmk_core/common/action.c ****                         }
 291:tmk_core/common/action.c ****                     }
 292:tmk_core/common/action.c ****                     break;
 293:tmk_core/common/action.c **** #    endif
 294:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 295:tmk_core/common/action.c ****                     if (event.pressed) {
 296:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 297:tmk_core/common/action.c ****                             register_mods(mods);
 298:tmk_core/common/action.c ****                         }
 299:tmk_core/common/action.c ****                     } else {
 300:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 301:tmk_core/common/action.c ****                             unregister_mods(mods);
 302:tmk_core/common/action.c ****                         }
 303:tmk_core/common/action.c ****                     }
 304:tmk_core/common/action.c ****                     break;
 305:tmk_core/common/action.c ****                 default:
 306:tmk_core/common/action.c ****                     if (event.pressed) {
 307:tmk_core/common/action.c ****                         if (tap_count > 0) {
 308:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 309:tmk_core/common/action.c ****                             if (record->tap.interrupted) {
 310:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 311:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 312:tmk_core/common/action.c ****                                 record->tap.count = 0;
 313:tmk_core/common/action.c ****                                 register_mods(mods);
 314:tmk_core/common/action.c ****                             } else
 315:tmk_core/common/action.c **** #    endif
 316:tmk_core/common/action.c ****                             {
 317:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 318:tmk_core/common/action.c ****                                 register_code(action.key.code);
 319:tmk_core/common/action.c ****                             }
 320:tmk_core/common/action.c ****                         } else {
 321:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c ****                         }
 324:tmk_core/common/action.c ****                     } else {
 325:tmk_core/common/action.c ****                         if (tap_count > 0) {
 326:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 327:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 328:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 329:tmk_core/common/action.c ****                             }
 330:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 331:tmk_core/common/action.c ****                         } else {
 332:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 333:tmk_core/common/action.c ****                             unregister_mods(mods);
 334:tmk_core/common/action.c ****                         }
 335:tmk_core/common/action.c ****                     }
 336:tmk_core/common/action.c ****                     break;
 337:tmk_core/common/action.c ****             }
 338:tmk_core/common/action.c ****         } break;
 339:tmk_core/common/action.c **** #endif
 340:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 341:tmk_core/common/action.c ****         /* other HID usage */
 342:tmk_core/common/action.c ****         case ACT_USAGE:
 343:tmk_core/common/action.c ****             switch (action.usage.page) {
 344:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 345:tmk_core/common/action.c ****                     if (event.pressed) {
 346:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 347:tmk_core/common/action.c ****                     } else {
 348:tmk_core/common/action.c ****                         host_system_send(0);
 349:tmk_core/common/action.c ****                     }
 350:tmk_core/common/action.c ****                     break;
 351:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 352:tmk_core/common/action.c ****                     if (event.pressed) {
 353:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         host_consumer_send(0);
 356:tmk_core/common/action.c ****                     }
 357:tmk_core/common/action.c ****                     break;
 358:tmk_core/common/action.c ****             }
 359:tmk_core/common/action.c ****             break;
 360:tmk_core/common/action.c **** #endif
 361:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 362:tmk_core/common/action.c ****         /* Mouse key */
 363:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 364:tmk_core/common/action.c ****             if (event.pressed) {
 365:tmk_core/common/action.c ****                 switch (action.key.code) {
 366:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 367:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 368:tmk_core/common/action.c ****                         break;
 369:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 370:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 371:tmk_core/common/action.c ****                         break;
 372:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 373:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 374:tmk_core/common/action.c ****                         break;
 375:tmk_core/common/action.c ****                     default:
 376:tmk_core/common/action.c ****                         break;
 377:tmk_core/common/action.c ****                 }
 378:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 379:tmk_core/common/action.c ****                 mousekey_send();
 380:tmk_core/common/action.c ****             } else {
 381:tmk_core/common/action.c ****                 switch (action.key.code) {
 382:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 383:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 384:tmk_core/common/action.c ****                         break;
 385:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 386:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 389:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 390:tmk_core/common/action.c ****                         break;
 391:tmk_core/common/action.c ****                     default:
 392:tmk_core/common/action.c ****                         break;
 393:tmk_core/common/action.c ****                 }
 394:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 395:tmk_core/common/action.c ****                 mousekey_send();
 396:tmk_core/common/action.c ****             }
 397:tmk_core/common/action.c ****             break;
 398:tmk_core/common/action.c **** #endif
 399:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 400:tmk_core/common/action.c ****         case ACT_LAYER:
 401:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 403:tmk_core/common/action.c ****                 if (!event.pressed) {
 404:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 405:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 406:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 408:tmk_core/common/action.c ****                         case OP_BIT_AND:
 409:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 410:tmk_core/common/action.c ****                             break;
 411:tmk_core/common/action.c ****                         case OP_BIT_OR:
 412:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 413:tmk_core/common/action.c ****                             break;
 414:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 415:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 416:tmk_core/common/action.c ****                             break;
 417:tmk_core/common/action.c ****                         case OP_BIT_SET:
 418:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 419:tmk_core/common/action.c ****                             break;
 420:tmk_core/common/action.c ****                     }
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 424:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 425:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 426:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 427:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 428:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 429:tmk_core/common/action.c ****                         case OP_BIT_AND:
 430:tmk_core/common/action.c ****                             layer_and(bits | mask);
 431:tmk_core/common/action.c ****                             break;
 432:tmk_core/common/action.c ****                         case OP_BIT_OR:
 433:tmk_core/common/action.c ****                             layer_or(bits | mask);
 434:tmk_core/common/action.c ****                             break;
 435:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 436:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 437:tmk_core/common/action.c ****                             break;
 438:tmk_core/common/action.c ****                         case OP_BIT_SET:
 439:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 440:tmk_core/common/action.c ****                             break;
 441:tmk_core/common/action.c ****                     }
 442:tmk_core/common/action.c ****                 }
 443:tmk_core/common/action.c ****             }
 444:tmk_core/common/action.c ****             break;
 445:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 446:tmk_core/common/action.c ****             if (event.pressed) {
 447:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 448:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 449:tmk_core/common/action.c ****             } else {
 450:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 451:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 452:tmk_core/common/action.c ****             }
 453:tmk_core/common/action.c ****             break;
 454:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 455:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 456:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 457:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 458:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 459:tmk_core/common/action.c ****                     /* tap toggle */
 460:tmk_core/common/action.c ****                     if (event.pressed) {
 461:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 462:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 463:tmk_core/common/action.c ****                         }
 464:tmk_core/common/action.c ****                     } else {
 465:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 466:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 467:tmk_core/common/action.c ****                         }
 468:tmk_core/common/action.c ****                     }
 469:tmk_core/common/action.c ****                     break;
 470:tmk_core/common/action.c ****                 case OP_ON_OFF:
 471:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_OFF_ON:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 475:tmk_core/common/action.c ****                     break;
 476:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 477:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 478:tmk_core/common/action.c ****                     break;
 479:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 480:tmk_core/common/action.c ****                 case OP_ONESHOT:
 481:tmk_core/common/action.c ****                     // Oneshot modifier
 482:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 483:tmk_core/common/action.c ****                     do_release_oneshot = false;
 484:tmk_core/common/action.c ****                     if (event.pressed) {
 485:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 486:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 487:tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 489:tmk_core/common/action.c ****                             break;
 490:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 491:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 492:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 493:tmk_core/common/action.c ****                         }
 494:tmk_core/common/action.c ****                     } else {
 495:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 496:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 497:tmk_core/common/action.c ****                             reset_oneshot_layer();
 498:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 499:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 500:tmk_core/common/action.c ****                         } else {
 501:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 502:tmk_core/common/action.c ****                         }
 503:tmk_core/common/action.c ****                     }
 504:tmk_core/common/action.c **** #            else
 505:tmk_core/common/action.c ****                     if (event.pressed) {
 506:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 510:tmk_core/common/action.c ****                         if (tap_count > 1) {
 511:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 512:tmk_core/common/action.c ****                         }
 513:tmk_core/common/action.c ****                     }
 514:tmk_core/common/action.c **** #            endif
 515:tmk_core/common/action.c ****                     break;
 516:tmk_core/common/action.c **** #        endif
 517:tmk_core/common/action.c ****                 default:
 518:tmk_core/common/action.c ****                     /* tap key */
 519:tmk_core/common/action.c ****                     if (event.pressed) {
 520:tmk_core/common/action.c ****                         if (tap_count > 0) {
 521:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 522:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 523:tmk_core/common/action.c ****                         } else {
 524:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 525:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 526:tmk_core/common/action.c ****                         }
 527:tmk_core/common/action.c ****                     } else {
 528:tmk_core/common/action.c ****                         if (tap_count > 0) {
 529:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 530:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 531:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 532:tmk_core/common/action.c ****                             } else {
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 534:tmk_core/common/action.c ****                             }
 535:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 536:tmk_core/common/action.c ****                         } else {
 537:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 538:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 539:tmk_core/common/action.c ****                         }
 540:tmk_core/common/action.c ****                     }
 541:tmk_core/common/action.c ****                     break;
 542:tmk_core/common/action.c ****             }
 543:tmk_core/common/action.c ****             break;
 544:tmk_core/common/action.c **** #    endif
 545:tmk_core/common/action.c **** #endif
 546:tmk_core/common/action.c ****             /* Extentions */
 547:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 548:tmk_core/common/action.c ****         case ACT_MACRO:
 549:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 550:tmk_core/common/action.c ****             break;
 551:tmk_core/common/action.c **** #endif
 552:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 553:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 554:tmk_core/common/action.c ****             if (!event.pressed) {
 555:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 556:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 557:tmk_core/common/action.c ****                         backlight_increase();
 558:tmk_core/common/action.c ****                         break;
 559:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 560:tmk_core/common/action.c ****                         backlight_decrease();
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 563:tmk_core/common/action.c ****                         backlight_toggle();
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 566:tmk_core/common/action.c ****                         backlight_step();
 567:tmk_core/common/action.c ****                         break;
 568:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 569:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 570:tmk_core/common/action.c ****                         break;
 571:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 572:tmk_core/common/action.c ****                         backlight_level(0);
 573:tmk_core/common/action.c ****                         break;
 574:tmk_core/common/action.c ****                 }
 575:tmk_core/common/action.c ****             }
 576:tmk_core/common/action.c ****             break;
 577:tmk_core/common/action.c **** #endif
 578:tmk_core/common/action.c ****         case ACT_COMMAND:
 579:tmk_core/common/action.c ****             break;
 580:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 581:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 582:tmk_core/common/action.c ****             switch (action.swap.code) {
 583:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 584:tmk_core/common/action.c ****                     if (event.pressed) {
 585:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 586:tmk_core/common/action.c ****                     }
 587:tmk_core/common/action.c ****                     break;
 588:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 589:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 592:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_ON:
 595:tmk_core/common/action.c ****                     if (!event.pressed) {
 596:tmk_core/common/action.c ****                         swap_hands = true;
 597:tmk_core/common/action.c ****                     }
 598:tmk_core/common/action.c ****                     break;
 599:tmk_core/common/action.c ****                 case OP_SH_OFF:
 600:tmk_core/common/action.c ****                     if (!event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = false;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 605:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 606:tmk_core/common/action.c ****                     /* tap toggle */
 607:tmk_core/common/action.c **** 
 608:tmk_core/common/action.c ****                     if (event.pressed) {
 609:tmk_core/common/action.c ****                         if (swap_held) {
 610:tmk_core/common/action.c ****                             swap_held = false;
 611:tmk_core/common/action.c ****                         } else {
 612:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 613:tmk_core/common/action.c ****                         }
 614:tmk_core/common/action.c ****                     } else {
 615:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 616:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 617:tmk_core/common/action.c ****                         }
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c ****                 default:
 621:tmk_core/common/action.c ****                     /* tap key */
 622:tmk_core/common/action.c ****                     if (tap_count > 0) {
 623:tmk_core/common/action.c ****                         if (swap_held) {
 624:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 625:tmk_core/common/action.c ****                             swap_held  = false;
 626:tmk_core/common/action.c ****                         }
 627:tmk_core/common/action.c ****                         if (event.pressed) {
 628:tmk_core/common/action.c ****                             register_code(action.swap.code);
 629:tmk_core/common/action.c ****                         } else {
 630:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 631:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 632:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 633:tmk_core/common/action.c ****                         }
 634:tmk_core/common/action.c ****                     } else {
 635:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 636:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 637:tmk_core/common/action.c ****                             swap_held  = false;
 638:tmk_core/common/action.c ****                         }
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c **** #    endif
 641:tmk_core/common/action.c ****             }
 642:tmk_core/common/action.c **** #endif
 643:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 644:tmk_core/common/action.c ****         case ACT_FUNCTION:
 645:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 646:tmk_core/common/action.c ****             break;
 647:tmk_core/common/action.c **** #endif
 648:tmk_core/common/action.c ****         default:
 649:tmk_core/common/action.c ****             break;
 650:tmk_core/common/action.c ****     }
 651:tmk_core/common/action.c **** 
 652:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 653:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 654:tmk_core/common/action.c ****     switch (action.kind.id) {
 655:tmk_core/common/action.c ****         case ACT_LAYER:
 656:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 658:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 659:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 660:tmk_core/common/action.c **** #    endif
 661:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c ****         default:
 664:tmk_core/common/action.c ****             break;
 665:tmk_core/common/action.c ****     }
 666:tmk_core/common/action.c **** #endif
 667:tmk_core/common/action.c **** 
 668:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 669:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 670:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 671:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 672:tmk_core/common/action.c ****     } else {
 673:tmk_core/common/action.c ****         if (event.pressed) {
 674:tmk_core/common/action.c ****             if (tap_count > 0) {
 675:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 676:tmk_core/common/action.c ****             } else {
 677:tmk_core/common/action.c ****             }
 678:tmk_core/common/action.c ****         } else {
 679:tmk_core/common/action.c ****             if (tap_count > 0) {
 680:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 681:tmk_core/common/action.c ****             } else {
 682:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 683:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 684:tmk_core/common/action.c ****                 }
 685:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 686:tmk_core/common/action.c ****             }
 687:tmk_core/common/action.c ****         }
 688:tmk_core/common/action.c ****     }
 689:tmk_core/common/action.c **** #    endif
 690:tmk_core/common/action.c **** #endif
 691:tmk_core/common/action.c **** 
 692:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 693:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 694:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 695:tmk_core/common/action.c ****      */
 696:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 697:tmk_core/common/action.c ****         record->event.pressed = false;
 698:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 699:tmk_core/common/action.c ****         process_record(record);
 700:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 701:tmk_core/common/action.c ****     }
 702:tmk_core/common/action.c **** #endif
 703:tmk_core/common/action.c **** }
 704:tmk_core/common/action.c **** 
 705:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 706:tmk_core/common/action.c ****  *
 707:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 708:tmk_core/common/action.c ****  */
 709:tmk_core/common/action.c **** void register_code(uint8_t code) {
 116              		.loc 1 709 0
 117              		.cfi_startproc
 118              		@ args = 0, pretend = 0, frame = 0
 119              		@ frame_needed = 0, uses_anonymous_args = 0
 120              	.LVL8:
 121 0000 10B5     		push	{r4, lr}
 122              		.cfi_def_cfa_offset 8
 123              		.cfi_offset 4, -8
 124              		.cfi_offset 14, -4
 710:tmk_core/common/action.c ****     if (code == KC_NO) {
 125              		.loc 1 710 0
 126 0002 0446     		mov	r4, r0
 127 0004 0028     		cmp	r0, #0
 128 0006 00F0DE80 		beq	.L4
 711:tmk_core/common/action.c ****         return;
 712:tmk_core/common/action.c ****     }
 713:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 714:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 129              		.loc 1 714 0
 130 000a 8228     		cmp	r0, #130
 131 000c 14D1     		bne	.L7
 715:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 716:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 717:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 132              		.loc 1 717 0
 133 000e FFF7FEFF 		bl	host_keyboard_leds
 134              	.LVL9:
 135 0012 8107     		lsls	r1, r0, #30
 136 0014 00F1D780 		bmi	.L4
 718:tmk_core/common/action.c **** #    endif
 719:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 137              		.loc 1 719 0
 138 0018 3920     		movs	r0, #57
 139 001a FFF7FEFF 		bl	add_key
 140              	.LVL10:
 720:tmk_core/common/action.c ****         send_keyboard_report();
 141              		.loc 1 720 0
 142 001e FFF7FEFF 		bl	send_keyboard_report
 143              	.LVL11:
 721:tmk_core/common/action.c ****         wait_ms(100);
 144              		.loc 1 721 0
 145 0022 42F21070 		movw	r0, #10000
 146 0026 FFF7FEFF 		bl	chThdSleep
 147              	.LVL12:
 722:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 148              		.loc 1 722 0
 149 002a 3920     		movs	r0, #57
 150              	.L42:
 723:tmk_core/common/action.c ****         send_keyboard_report();
 724:tmk_core/common/action.c ****     }
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 727:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 728:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 729:tmk_core/common/action.c **** #    endif
 730:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 731:tmk_core/common/action.c ****         send_keyboard_report();
 732:tmk_core/common/action.c ****         wait_ms(100);
 733:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 151              		.loc 1 733 0
 152 002c FFF7FEFF 		bl	del_key
 153              	.LVL13:
 154              	.L43:
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** 
 737:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 738:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 739:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 740:tmk_core/common/action.c **** #    endif
 741:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 742:tmk_core/common/action.c ****         send_keyboard_report();
 743:tmk_core/common/action.c ****         wait_ms(100);
 744:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 745:tmk_core/common/action.c ****         send_keyboard_report();
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #endif
 748:tmk_core/common/action.c **** 
 749:tmk_core/common/action.c ****     else if
 750:tmk_core/common/action.c ****         IS_KEY(code) {
 751:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 752:tmk_core/common/action.c ****             if (command_proc(code)) return;
 753:tmk_core/common/action.c **** 
 754:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 755:tmk_core/common/action.c **** /* TODO: remove
 756:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 757:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 758:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****             add_key(code);
 761:tmk_core/common/action.c ****             send_keyboard_report();
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             set_mods(tmp_mods);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c ****             oneshot_cancel();
 766:tmk_core/common/action.c ****         } else
 767:tmk_core/common/action.c **** */
 768:tmk_core/common/action.c **** #endif
 769:tmk_core/common/action.c ****             {
 770:tmk_core/common/action.c ****                 add_key(code);
 771:tmk_core/common/action.c ****                 send_keyboard_report();
 772:tmk_core/common/action.c ****             }
 773:tmk_core/common/action.c ****         }
 774:tmk_core/common/action.c ****     else if
 775:tmk_core/common/action.c ****         IS_MOD(code) {
 776:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 777:tmk_core/common/action.c ****             send_keyboard_report();
 778:tmk_core/common/action.c ****         }
 779:tmk_core/common/action.c ****     else if
 780:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 781:tmk_core/common/action.c ****     else if
 782:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 783:tmk_core/common/action.c **** 
 784:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 785:tmk_core/common/action.c ****     else if
 786:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 787:tmk_core/common/action.c ****             mousekey_on(code);
 788:tmk_core/common/action.c ****             mousekey_send();
 789:tmk_core/common/action.c ****         }
 790:tmk_core/common/action.c **** #endif
 791:tmk_core/common/action.c **** }
 155              		.loc 1 791 0
 156 0030 BDE81040 		pop	{r4, lr}
 157              		.cfi_remember_state
 158              		.cfi_restore 14
 159              		.cfi_restore 4
 160              		.cfi_def_cfa_offset 0
 734:tmk_core/common/action.c ****         send_keyboard_report();
 161              		.loc 1 734 0
 162 0034 FFF7FEBF 		b	send_keyboard_report
 163              	.LVL14:
 164              	.L7:
 165              		.cfi_restore_state
 726:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 166              		.loc 1 726 0
 167 0038 8328     		cmp	r0, #131
 168 003a 0FD1     		bne	.L9
 728:tmk_core/common/action.c **** #    endif
 169              		.loc 1 728 0
 170 003c FFF7FEFF 		bl	host_keyboard_leds
 171              	.LVL15:
 172 0040 C207     		lsls	r2, r0, #31
 173 0042 00F1C080 		bmi	.L4
 730:tmk_core/common/action.c ****         send_keyboard_report();
 174              		.loc 1 730 0
 175 0046 5320     		movs	r0, #83
 176 0048 FFF7FEFF 		bl	add_key
 177              	.LVL16:
 731:tmk_core/common/action.c ****         wait_ms(100);
 178              		.loc 1 731 0
 179 004c FFF7FEFF 		bl	send_keyboard_report
 180              	.LVL17:
 732:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 181              		.loc 1 732 0
 182 0050 42F21070 		movw	r0, #10000
 183 0054 FFF7FEFF 		bl	chThdSleep
 184              	.LVL18:
 733:tmk_core/common/action.c ****         send_keyboard_report();
 185              		.loc 1 733 0
 186 0058 5320     		movs	r0, #83
 187 005a E7E7     		b	.L42
 188              	.LVL19:
 189              	.L9:
 190              	.LBB17:
 191              	.LBB18:
 737:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 192              		.loc 1 737 0
 193 005c 8428     		cmp	r0, #132
 194 005e 0FD1     		bne	.L10
 739:tmk_core/common/action.c **** #    endif
 195              		.loc 1 739 0
 196 0060 FFF7FEFF 		bl	host_keyboard_leds
 197              	.LVL20:
 198 0064 4307     		lsls	r3, r0, #29
 199 0066 00F1AE80 		bmi	.L4
 741:tmk_core/common/action.c ****         send_keyboard_report();
 200              		.loc 1 741 0
 201 006a 4720     		movs	r0, #71
 202 006c FFF7FEFF 		bl	add_key
 203              	.LVL21:
 742:tmk_core/common/action.c ****         wait_ms(100);
 204              		.loc 1 742 0
 205 0070 FFF7FEFF 		bl	send_keyboard_report
 206              	.LVL22:
 743:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 207              		.loc 1 743 0
 208 0074 42F21070 		movw	r0, #10000
 209 0078 FFF7FEFF 		bl	chThdSleep
 210              	.LVL23:
 744:tmk_core/common/action.c ****         send_keyboard_report();
 211              		.loc 1 744 0
 212 007c 4720     		movs	r0, #71
 213 007e D5E7     		b	.L42
 214              	.LVL24:
 215              	.L10:
 750:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 216              		.loc 1 750 0
 217 0080 031F     		subs	r3, r0, #4
 218 0082 DBB2     		uxtb	r3, r3
 219 0084 A02B     		cmp	r3, #160
 220 0086 08D8     		bhi	.L11
 752:tmk_core/common/action.c **** 
 221              		.loc 1 752 0
 222 0088 FFF7FEFF 		bl	command_proc
 223              	.LVL25:
 224 008c 0028     		cmp	r0, #0
 225 008e 40F09A80 		bne	.L4
 770:tmk_core/common/action.c ****                 send_keyboard_report();
 226              		.loc 1 770 0
 227 0092 2046     		mov	r0, r4
 228 0094 FFF7FEFF 		bl	add_key
 229              	.LVL26:
 230 0098 CAE7     		b	.L43
 231              	.LVL27:
 232              	.L11:
 775:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 233              		.loc 1 775 0
 234 009a 00F12003 		add	r3, r0, #32
 235 009e DBB2     		uxtb	r3, r3
 236 00a0 072B     		cmp	r3, #7
 237 00a2 07D8     		bhi	.L12
 776:tmk_core/common/action.c ****             send_keyboard_report();
 238              		.loc 1 776 0
 239 00a4 00F00704 		and	r4, r0, #7
 240 00a8 0120     		movs	r0, #1
 241              	.LVL28:
 242 00aa A040     		lsls	r0, r0, r4
 243 00ac C0B2     		uxtb	r0, r0
 244 00ae FFF7FEFF 		bl	add_mods
 245              	.LVL29:
 246 00b2 BDE7     		b	.L43
 247              	.LVL30:
 248              	.L12:
 780:tmk_core/common/action.c ****     else if
 249              		.loc 1 780 0
 250 00b4 00F15B03 		add	r3, r0, #91
 251 00b8 DBB2     		uxtb	r3, r3
 252 00ba 022B     		cmp	r3, #2
 253 00bc 0BD8     		bhi	.L13
 254 00be A528     		cmp	r0, #165
 255 00c0 07D0     		beq	.L17
 256 00c2 A628     		cmp	r0, #166
 257 00c4 0CBF     		ite	eq
 258 00c6 8220     		moveq	r0, #130
 259              	.LVL31:
 260 00c8 8320     		movne	r0, #131
 261              	.L14:
 262              	.LBE18:
 263              	.LBE17:
 264              		.loc 1 791 0
 265 00ca BDE81040 		pop	{r4, lr}
 266              		.cfi_remember_state
 267              		.cfi_restore 14
 268              		.cfi_restore 4
 269              		.cfi_def_cfa_offset 0
 270              	.LBB22:
 271              	.LBB19:
 780:tmk_core/common/action.c ****     else if
 272              		.loc 1 780 0
 273 00ce FFF7FEBF 		b	host_system_send
 274              	.LVL32:
 275              	.L17:
 276              		.cfi_restore_state
 277 00d2 8120     		movs	r0, #129
 278              	.LVL33:
 279 00d4 F9E7     		b	.L14
 280              	.LVL34:
 281              	.L13:
 782:tmk_core/common/action.c **** 
 282              		.loc 1 782 0
 283 00d6 00F15803 		add	r3, r0, #88
 284 00da DBB2     		uxtb	r3, r3
 285 00dc 162B     		cmp	r3, #22
 286 00de 6AD8     		bhi	.L15
 287 00e0 A828     		cmp	r0, #168
 288 00e2 32D0     		beq	.L19
 289 00e4 A928     		cmp	r0, #169
 290 00e6 32D0     		beq	.L20
 291 00e8 AA28     		cmp	r0, #170
 292 00ea 32D0     		beq	.L21
 293 00ec AB28     		cmp	r0, #171
 294 00ee 32D0     		beq	.L22
 295 00f0 AC28     		cmp	r0, #172
 296 00f2 32D0     		beq	.L23
 297 00f4 BB28     		cmp	r0, #187
 298 00f6 32D0     		beq	.L24
 299 00f8 BC28     		cmp	r0, #188
 300 00fa 32D0     		beq	.L25
 301 00fc AD28     		cmp	r0, #173
 302 00fe 32D0     		beq	.L26
 303 0100 B028     		cmp	r0, #176
 304 0102 32D0     		beq	.L27
 305 0104 AE28     		cmp	r0, #174
 306 0106 32D0     		beq	.L28
 307 0108 AF28     		cmp	r0, #175
 308 010a 32D0     		beq	.L29
 309 010c B128     		cmp	r0, #177
 310 010e 33D0     		beq	.L30
 311 0110 B228     		cmp	r0, #178
 312 0112 34D0     		beq	.L31
 313 0114 B328     		cmp	r0, #179
 314 0116 35D0     		beq	.L32
 315 0118 B428     		cmp	r0, #180
 316 011a 36D0     		beq	.L33
 317 011c B528     		cmp	r0, #181
 318 011e 37D0     		beq	.L34
 319 0120 B628     		cmp	r0, #182
 320 0122 38D0     		beq	.L35
 321 0124 B728     		cmp	r0, #183
 322 0126 39D0     		beq	.L36
 323 0128 B828     		cmp	r0, #184
 324 012a 3AD0     		beq	.L37
 325 012c B928     		cmp	r0, #185
 326 012e 3BD0     		beq	.L38
 327 0130 BD28     		cmp	r0, #189
 328 0132 3CD0     		beq	.L39
 329 0134 BE28     		cmp	r0, #190
 330 0136 3CD0     		beq	.L40
 331 0138 BA28     		cmp	r0, #186
 332 013a 40F22A20 		movw	r0, #554
 333              	.LVL35:
 334 013e 18BF     		it	ne
 335 0140 0020     		movne	r0, #0
 336              	.L16:
 337              	.LBE19:
 338              	.LBE22:
 339              		.loc 1 791 0
 340 0142 BDE81040 		pop	{r4, lr}
 341              		.cfi_remember_state
 342              		.cfi_restore 14
 343              		.cfi_restore 4
 344              		.cfi_def_cfa_offset 0
 345              	.LBB23:
 346              	.LBB20:
 782:tmk_core/common/action.c **** 
 347              		.loc 1 782 0
 348 0146 FFF7FEBF 		b	host_consumer_send
 349              	.LVL36:
 350              	.L19:
 351              		.cfi_restore_state
 352 014a E220     		movs	r0, #226
 353              	.LVL37:
 354 014c F9E7     		b	.L16
 355              	.LVL38:
 356              	.L20:
 357 014e E920     		movs	r0, #233
 358              	.LVL39:
 359 0150 F7E7     		b	.L16
 360              	.LVL40:
 361              	.L21:
 362 0152 EA20     		movs	r0, #234
 363              	.LVL41:
 364 0154 F5E7     		b	.L16
 365              	.LVL42:
 366              	.L22:
 367 0156 B520     		movs	r0, #181
 368              	.LVL43:
 369 0158 F3E7     		b	.L16
 370              	.LVL44:
 371              	.L23:
 372 015a B620     		movs	r0, #182
 373              	.LVL45:
 374 015c F1E7     		b	.L16
 375              	.LVL46:
 376              	.L24:
 377 015e B320     		movs	r0, #179
 378              	.LVL47:
 379 0160 EFE7     		b	.L16
 380              	.LVL48:
 381              	.L25:
 382 0162 B420     		movs	r0, #180
 383              	.LVL49:
 384 0164 EDE7     		b	.L16
 385              	.LVL50:
 386              	.L26:
 387 0166 B720     		movs	r0, #183
 388              	.LVL51:
 389 0168 EBE7     		b	.L16
 390              	.LVL52:
 391              	.L27:
 392 016a CC20     		movs	r0, #204
 393              	.LVL53:
 394 016c E9E7     		b	.L16
 395              	.LVL54:
 396              	.L28:
 397 016e CD20     		movs	r0, #205
 398              	.LVL55:
 399 0170 E7E7     		b	.L16
 400              	.LVL56:
 401              	.L29:
 402 0172 40F28310 		movw	r0, #387
 403              	.LVL57:
 404 0176 E4E7     		b	.L16
 405              	.LVL58:
 406              	.L30:
 407 0178 4FF4C570 		mov	r0, #394
 408              	.LVL59:
 409 017c E1E7     		b	.L16
 410              	.LVL60:
 411              	.L31:
 412 017e 4FF4C970 		mov	r0, #402
 413              	.LVL61:
 414 0182 DEE7     		b	.L16
 415              	.LVL62:
 416              	.L32:
 417 0184 4FF4CA70 		mov	r0, #404
 418              	.LVL63:
 419 0188 DBE7     		b	.L16
 420              	.LVL64:
 421              	.L33:
 422 018a 40F22120 		movw	r0, #545
 423              	.LVL65:
 424 018e D8E7     		b	.L16
 425              	.LVL66:
 426              	.L34:
 427 0190 40F22320 		movw	r0, #547
 428              	.LVL67:
 429 0194 D5E7     		b	.L16
 430              	.LVL68:
 431              	.L35:
 432 0196 4FF40970 		mov	r0, #548
 433              	.LVL69:
 434 019a D2E7     		b	.L16
 435              	.LVL70:
 436              	.L36:
 437 019c 40F22520 		movw	r0, #549
 438              	.LVL71:
 439 01a0 CFE7     		b	.L16
 440              	.LVL72:
 441              	.L37:
 442 01a2 40F22620 		movw	r0, #550
 443              	.LVL73:
 444 01a6 CCE7     		b	.L16
 445              	.LVL74:
 446              	.L38:
 447 01a8 40F22720 		movw	r0, #551
 448              	.LVL75:
 449 01ac C9E7     		b	.L16
 450              	.LVL76:
 451              	.L39:
 452 01ae 6F20     		movs	r0, #111
 453              	.LVL77:
 454 01b0 C7E7     		b	.L16
 455              	.LVL78:
 456              	.L40:
 457 01b2 7020     		movs	r0, #112
 458              	.LVL79:
 459 01b4 C5E7     		b	.L16
 460              	.LVL80:
 461              	.L15:
 786:tmk_core/common/action.c ****             mousekey_on(code);
 462              		.loc 1 786 0
 463 01b6 EF28     		cmp	r0, #239
 464 01b8 05D9     		bls	.L4
 787:tmk_core/common/action.c ****             mousekey_send();
 465              		.loc 1 787 0
 466 01ba FFF7FEFF 		bl	mousekey_on
 467              	.LVL81:
 468              	.LBE20:
 469              	.LBE23:
 470              		.loc 1 791 0
 471 01be BDE81040 		pop	{r4, lr}
 472              		.cfi_remember_state
 473              		.cfi_restore 14
 474              		.cfi_restore 4
 475              		.cfi_def_cfa_offset 0
 476              	.LBB24:
 477              	.LBB21:
 788:tmk_core/common/action.c ****         }
 478              		.loc 1 788 0
 479 01c2 FFF7FEBF 		b	mousekey_send
 480              	.LVL82:
 481              	.L4:
 482              		.cfi_restore_state
 483              	.LBE21:
 484              	.LBE24:
 485              		.loc 1 791 0
 486 01c6 10BD     		pop	{r4, pc}
 487              		.cfi_endproc
 488              	.LFE291:
 490              		.section	.text.unregister_code,"ax",%progbits
 491              		.align	1
 492              		.global	unregister_code
 493              		.syntax unified
 494              		.thumb
 495              		.thumb_func
 496              		.fpu softvfp
 498              	unregister_code:
 499              	.LFB292:
 792:tmk_core/common/action.c **** 
 793:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 794:tmk_core/common/action.c ****  *
 795:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 796:tmk_core/common/action.c ****  */
 797:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 500              		.loc 1 797 0
 501              		.cfi_startproc
 502              		@ args = 0, pretend = 0, frame = 0
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              	.LVL83:
 505 0000 08B5     		push	{r3, lr}
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 3, -8
 508              		.cfi_offset 14, -4
 798:tmk_core/common/action.c ****     if (code == KC_NO) {
 509              		.loc 1 798 0
 510 0002 0028     		cmp	r0, #0
 511 0004 58D0     		beq	.L44
 799:tmk_core/common/action.c ****         return;
 800:tmk_core/common/action.c ****     }
 801:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 802:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 512              		.loc 1 802 0
 513 0006 8228     		cmp	r0, #130
 514 0008 0FD1     		bne	.L47
 803:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 804:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 805:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 515              		.loc 1 805 0
 516 000a FFF7FEFF 		bl	host_keyboard_leds
 517              	.LVL84:
 518 000e 8107     		lsls	r1, r0, #30
 519 0010 52D5     		bpl	.L44
 806:tmk_core/common/action.c **** #    endif
 807:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 520              		.loc 1 807 0
 521 0012 3920     		movs	r0, #57
 522 0014 FFF7FEFF 		bl	add_key
 523              	.LVL85:
 808:tmk_core/common/action.c ****         send_keyboard_report();
 524              		.loc 1 808 0
 525 0018 FFF7FEFF 		bl	send_keyboard_report
 526              	.LVL86:
 809:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 527              		.loc 1 809 0
 528 001c 3920     		movs	r0, #57
 529              	.L64:
 810:tmk_core/common/action.c ****         send_keyboard_report();
 811:tmk_core/common/action.c ****     }
 812:tmk_core/common/action.c **** 
 813:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 814:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 815:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 816:tmk_core/common/action.c **** #    endif
 817:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 818:tmk_core/common/action.c ****         send_keyboard_report();
 819:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 530              		.loc 1 819 0
 531 001e FFF7FEFF 		bl	del_key
 532              	.LVL87:
 533              	.L65:
 820:tmk_core/common/action.c ****         send_keyboard_report();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 824:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 825:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 826:tmk_core/common/action.c **** #    endif
 827:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 828:tmk_core/common/action.c ****         send_keyboard_report();
 829:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 830:tmk_core/common/action.c ****         send_keyboard_report();
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****     else if
 835:tmk_core/common/action.c ****         IS_KEY(code) {
 836:tmk_core/common/action.c ****             del_key(code);
 837:tmk_core/common/action.c ****             send_keyboard_report();
 838:tmk_core/common/action.c ****         }
 839:tmk_core/common/action.c ****     else if
 840:tmk_core/common/action.c ****         IS_MOD(code) {
 841:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 842:tmk_core/common/action.c ****             send_keyboard_report();
 843:tmk_core/common/action.c ****         }
 844:tmk_core/common/action.c ****     else if
 845:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 846:tmk_core/common/action.c ****     else if
 847:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 848:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 849:tmk_core/common/action.c ****     else if
 850:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 851:tmk_core/common/action.c ****             mousekey_off(code);
 852:tmk_core/common/action.c ****             mousekey_send();
 853:tmk_core/common/action.c ****         }
 854:tmk_core/common/action.c **** #endif
 855:tmk_core/common/action.c **** }
 534              		.loc 1 855 0
 535 0022 BDE80840 		pop	{r3, lr}
 536              		.cfi_remember_state
 537              		.cfi_restore 14
 538              		.cfi_restore 3
 539              		.cfi_def_cfa_offset 0
 820:tmk_core/common/action.c ****         send_keyboard_report();
 540              		.loc 1 820 0
 541 0026 FFF7FEBF 		b	send_keyboard_report
 542              	.LVL88:
 543              	.L47:
 544              		.cfi_restore_state
 813:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 545              		.loc 1 813 0
 546 002a 8328     		cmp	r0, #131
 547 002c 0AD1     		bne	.L49
 815:tmk_core/common/action.c **** #    endif
 548              		.loc 1 815 0
 549 002e FFF7FEFF 		bl	host_keyboard_leds
 550              	.LVL89:
 551 0032 C207     		lsls	r2, r0, #31
 552 0034 40D5     		bpl	.L44
 817:tmk_core/common/action.c ****         send_keyboard_report();
 553              		.loc 1 817 0
 554 0036 5320     		movs	r0, #83
 555 0038 FFF7FEFF 		bl	add_key
 556              	.LVL90:
 818:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 557              		.loc 1 818 0
 558 003c FFF7FEFF 		bl	send_keyboard_report
 559              	.LVL91:
 819:tmk_core/common/action.c ****         send_keyboard_report();
 560              		.loc 1 819 0
 561 0040 5320     		movs	r0, #83
 562 0042 ECE7     		b	.L64
 563              	.LVL92:
 564              	.L49:
 565              	.LBB27:
 566              	.LBB28:
 823:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 567              		.loc 1 823 0
 568 0044 8428     		cmp	r0, #132
 569 0046 0AD1     		bne	.L50
 825:tmk_core/common/action.c **** #    endif
 570              		.loc 1 825 0
 571 0048 FFF7FEFF 		bl	host_keyboard_leds
 572              	.LVL93:
 573 004c 4307     		lsls	r3, r0, #29
 574 004e 33D5     		bpl	.L44
 827:tmk_core/common/action.c ****         send_keyboard_report();
 575              		.loc 1 827 0
 576 0050 4720     		movs	r0, #71
 577 0052 FFF7FEFF 		bl	add_key
 578              	.LVL94:
 828:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 579              		.loc 1 828 0
 580 0056 FFF7FEFF 		bl	send_keyboard_report
 581              	.LVL95:
 829:tmk_core/common/action.c ****         send_keyboard_report();
 582              		.loc 1 829 0
 583 005a 4720     		movs	r0, #71
 584 005c DFE7     		b	.L64
 585              	.LVL96:
 586              	.L50:
 835:tmk_core/common/action.c ****             del_key(code);
 587              		.loc 1 835 0
 588 005e 021F     		subs	r2, r0, #4
 589 0060 D2B2     		uxtb	r2, r2
 590 0062 A02A     		cmp	r2, #160
 591 0064 DBD9     		bls	.L64
 840:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 592              		.loc 1 840 0
 593 0066 00F12002 		add	r2, r0, #32
 594 006a D2B2     		uxtb	r2, r2
 595 006c 072A     		cmp	r2, #7
 596 006e 07D8     		bhi	.L52
 841:tmk_core/common/action.c ****             send_keyboard_report();
 597              		.loc 1 841 0
 598 0070 00F00703 		and	r3, r0, #7
 599 0074 0120     		movs	r0, #1
 600              	.LVL97:
 601 0076 9840     		lsls	r0, r0, r3
 602 0078 C0B2     		uxtb	r0, r0
 603 007a FFF7FEFF 		bl	del_mods
 604              	.LVL98:
 605 007e D0E7     		b	.L65
 606              	.LVL99:
 607              	.L52:
 845:tmk_core/common/action.c ****     else if
 608              		.loc 1 845 0
 609 0080 00F15B02 		add	r2, r0, #91
 610 0084 D2B2     		uxtb	r2, r2
 611 0086 022A     		cmp	r2, #2
 612 0088 04D8     		bhi	.L53
 613 008a 0020     		movs	r0, #0
 614              	.LVL100:
 615              	.LBE28:
 616              	.LBE27:
 617              		.loc 1 855 0
 618 008c BDE80840 		pop	{r3, lr}
 619              		.cfi_remember_state
 620              		.cfi_restore 14
 621              		.cfi_restore 3
 622              		.cfi_def_cfa_offset 0
 623              	.LBB32:
 624              	.LBB29:
 845:tmk_core/common/action.c ****     else if
 625              		.loc 1 845 0
 626 0090 FFF7FEBF 		b	host_system_send
 627              	.LVL101:
 628              	.L53:
 629              		.cfi_restore_state
 847:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 630              		.loc 1 847 0
 631 0094 00F15802 		add	r2, r0, #88
 632 0098 D2B2     		uxtb	r2, r2
 633 009a 162A     		cmp	r2, #22
 634 009c 04D8     		bhi	.L54
 635 009e 0020     		movs	r0, #0
 636              	.LVL102:
 637              	.LBE29:
 638              	.LBE32:
 639              		.loc 1 855 0
 640 00a0 BDE80840 		pop	{r3, lr}
 641              		.cfi_remember_state
 642              		.cfi_restore 14
 643              		.cfi_restore 3
 644              		.cfi_def_cfa_offset 0
 645              	.LBB33:
 646              	.LBB30:
 847:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 647              		.loc 1 847 0
 648 00a4 FFF7FEBF 		b	host_consumer_send
 649              	.LVL103:
 650              	.L54:
 651              		.cfi_restore_state
 850:tmk_core/common/action.c ****             mousekey_off(code);
 652              		.loc 1 850 0
 653 00a8 EF28     		cmp	r0, #239
 654 00aa 05D9     		bls	.L44
 851:tmk_core/common/action.c ****             mousekey_send();
 655              		.loc 1 851 0
 656 00ac FFF7FEFF 		bl	mousekey_off
 657              	.LVL104:
 658              	.LBE30:
 659              	.LBE33:
 660              		.loc 1 855 0
 661 00b0 BDE80840 		pop	{r3, lr}
 662              		.cfi_remember_state
 663              		.cfi_restore 14
 664              		.cfi_restore 3
 665              		.cfi_def_cfa_offset 0
 666              	.LBB34:
 667              	.LBB31:
 852:tmk_core/common/action.c ****         }
 668              		.loc 1 852 0
 669 00b4 FFF7FEBF 		b	mousekey_send
 670              	.LVL105:
 671              	.L44:
 672              		.cfi_restore_state
 673              	.LBE31:
 674              	.LBE34:
 675              		.loc 1 855 0
 676 00b8 08BD     		pop	{r3, pc}
 677              		.cfi_endproc
 678              	.LFE292:
 680              		.section	.text.tap_code,"ax",%progbits
 681              		.align	1
 682              		.global	tap_code
 683              		.syntax unified
 684              		.thumb
 685              		.thumb_func
 686              		.fpu softvfp
 688              	tap_code:
 689              	.LFB293:
 856:tmk_core/common/action.c **** 
 857:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 858:tmk_core/common/action.c ****  *
 859:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 860:tmk_core/common/action.c ****  */
 861:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 690              		.loc 1 861 0
 691              		.cfi_startproc
 692              		@ args = 0, pretend = 0, frame = 0
 693              		@ frame_needed = 0, uses_anonymous_args = 0
 694              	.LVL106:
 695 0000 10B5     		push	{r4, lr}
 696              		.cfi_def_cfa_offset 8
 697              		.cfi_offset 4, -8
 698              		.cfi_offset 14, -4
 699              		.loc 1 861 0
 700 0002 0446     		mov	r4, r0
 862:tmk_core/common/action.c ****     register_code(code);
 701              		.loc 1 862 0
 702 0004 FFF7FEFF 		bl	register_code
 703              	.LVL107:
 863:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 704              		.loc 1 863 0
 705 0008 392C     		cmp	r4, #57
 864:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 706              		.loc 1 864 0
 707 000a 0CBF     		ite	eq
 708 000c 4FF4FA50 		moveq	r0, #8000
 865:tmk_core/common/action.c ****     } else {
 866:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 709              		.loc 1 866 0
 710 0010 0120     		movne	r0, #1
 711 0012 FFF7FEFF 		bl	chThdSleep
 712              	.LVL108:
 867:tmk_core/common/action.c ****     }
 868:tmk_core/common/action.c ****     unregister_code(code);
 713              		.loc 1 868 0
 714 0016 2046     		mov	r0, r4
 869:tmk_core/common/action.c **** }
 715              		.loc 1 869 0
 716 0018 BDE81040 		pop	{r4, lr}
 717              		.cfi_restore 14
 718              		.cfi_restore 4
 719              		.cfi_def_cfa_offset 0
 868:tmk_core/common/action.c **** }
 720              		.loc 1 868 0
 721 001c FFF7FEBF 		b	unregister_code
 722              	.LVL109:
 723              		.cfi_endproc
 724              	.LFE293:
 726              		.section	.text.register_mods,"ax",%progbits
 727              		.align	1
 728              		.global	register_mods
 729              		.syntax unified
 730              		.thumb
 731              		.thumb_func
 732              		.fpu softvfp
 734              	register_mods:
 735              	.LFB294:
 870:tmk_core/common/action.c **** 
 871:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:tmk_core/common/action.c ****  *
 873:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:tmk_core/common/action.c ****  */
 875:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 736              		.loc 1 875 0
 737              		.cfi_startproc
 738              		@ args = 0, pretend = 0, frame = 0
 739              		@ frame_needed = 0, uses_anonymous_args = 0
 740              	.LVL110:
 741 0000 08B5     		push	{r3, lr}
 742              		.cfi_def_cfa_offset 8
 743              		.cfi_offset 3, -8
 744              		.cfi_offset 14, -4
 876:tmk_core/common/action.c ****     if (mods) {
 745              		.loc 1 876 0
 746 0002 28B1     		cbz	r0, .L70
 877:tmk_core/common/action.c ****         add_mods(mods);
 747              		.loc 1 877 0
 748 0004 FFF7FEFF 		bl	add_mods
 749              	.LVL111:
 878:tmk_core/common/action.c ****         send_keyboard_report();
 879:tmk_core/common/action.c ****     }
 880:tmk_core/common/action.c **** }
 750              		.loc 1 880 0
 751 0008 BDE80840 		pop	{r3, lr}
 752              		.cfi_remember_state
 753              		.cfi_restore 14
 754              		.cfi_restore 3
 755              		.cfi_def_cfa_offset 0
 878:tmk_core/common/action.c ****         send_keyboard_report();
 756              		.loc 1 878 0
 757 000c FFF7FEBF 		b	send_keyboard_report
 758              	.LVL112:
 759              	.L70:
 760              		.cfi_restore_state
 761              		.loc 1 880 0
 762 0010 08BD     		pop	{r3, pc}
 763              		.cfi_endproc
 764              	.LFE294:
 766              		.section	.text.unregister_mods,"ax",%progbits
 767              		.align	1
 768              		.global	unregister_mods
 769              		.syntax unified
 770              		.thumb
 771              		.thumb_func
 772              		.fpu softvfp
 774              	unregister_mods:
 775              	.LFB295:
 881:tmk_core/common/action.c **** 
 882:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 883:tmk_core/common/action.c ****  *
 884:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 885:tmk_core/common/action.c ****  */
 886:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 776              		.loc 1 886 0
 777              		.cfi_startproc
 778              		@ args = 0, pretend = 0, frame = 0
 779              		@ frame_needed = 0, uses_anonymous_args = 0
 780              	.LVL113:
 781 0000 08B5     		push	{r3, lr}
 782              		.cfi_def_cfa_offset 8
 783              		.cfi_offset 3, -8
 784              		.cfi_offset 14, -4
 887:tmk_core/common/action.c ****     if (mods) {
 785              		.loc 1 887 0
 786 0002 28B1     		cbz	r0, .L72
 888:tmk_core/common/action.c ****         del_mods(mods);
 787              		.loc 1 888 0
 788 0004 FFF7FEFF 		bl	del_mods
 789              	.LVL114:
 889:tmk_core/common/action.c ****         send_keyboard_report();
 890:tmk_core/common/action.c ****     }
 891:tmk_core/common/action.c **** }
 790              		.loc 1 891 0
 791 0008 BDE80840 		pop	{r3, lr}
 792              		.cfi_remember_state
 793              		.cfi_restore 14
 794              		.cfi_restore 3
 795              		.cfi_def_cfa_offset 0
 889:tmk_core/common/action.c ****         send_keyboard_report();
 796              		.loc 1 889 0
 797 000c FFF7FEBF 		b	send_keyboard_report
 798              	.LVL115:
 799              	.L72:
 800              		.cfi_restore_state
 801              		.loc 1 891 0
 802 0010 08BD     		pop	{r3, pc}
 803              		.cfi_endproc
 804              	.LFE295:
 806              		.section	.text.process_action,"ax",%progbits
 807              		.align	1
 808              		.global	process_action
 809              		.syntax unified
 810              		.thumb
 811              		.thumb_func
 812              		.fpu softvfp
 814              	process_action:
 815              	.LFB290:
 197:tmk_core/common/action.c ****     keyevent_t event = record->event;
 816              		.loc 1 197 0
 817              		.cfi_startproc
 818              		@ args = 0, pretend = 0, frame = 0
 819              		@ frame_needed = 0, uses_anonymous_args = 0
 820              	.LVL116:
 821 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 822              		.cfi_def_cfa_offset 32
 823              		.cfi_offset 4, -32
 824              		.cfi_offset 5, -28
 825              		.cfi_offset 6, -24
 826              		.cfi_offset 7, -20
 827              		.cfi_offset 8, -16
 828              		.cfi_offset 9, -12
 829              		.cfi_offset 10, -8
 830              		.cfi_offset 14, -4
 200:tmk_core/common/action.c **** #endif
 831              		.loc 1 200 0
 832 0004 90F80690 		ldrb	r9, [r0, #6]	@ zero_extendqisi2
 203:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 833              		.loc 1 203 0
 834 0008 8578     		ldrb	r5, [r0, #2]	@ zero_extendqisi2
 197:tmk_core/common/action.c ****     keyevent_t event = record->event;
 835              		.loc 1 197 0
 836 000a 0746     		mov	r7, r0
 837 000c 0C46     		mov	r4, r1	@ movhi
 200:tmk_core/common/action.c **** #endif
 838              		.loc 1 200 0
 839 000e 4FEA1919 		lsr	r9, r9, #4
 840              	.LVL117:
 203:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 841              		.loc 1 203 0
 842 0012 0DB1     		cbz	r5, .L75
 205:tmk_core/common/action.c ****     }
 843              		.loc 1 205 0
 844 0014 FFF7FEFF 		bl	clear_weak_mods
 845              	.LVL118:
 846              	.L75:
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 847              		.loc 1 211 0
 848 0018 FFF7FEFF 		bl	is_oneshot_layer_active
 849              	.LVL119:
 850 001c 8046     		mov	r8, r0
 851 001e 70B1     		cbz	r0, .L76
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 852              		.loc 1 211 0 is_stmt 0 discriminator 1
 853 0020 1DB3     		cbz	r5, .L166
 854              	.LVL120:
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 855              		.loc 1 211 0 discriminator 2
 856 0022 04F12003 		add	r3, r4, #32
 857 0026 DBB2     		uxtb	r3, r3
 858 0028 072B     		cmp	r3, #7
 859 002a 1ED9     		bls	.L166
 212:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 860              		.loc 1 212 0 is_stmt 1
 861 002c 0220     		movs	r0, #2
 862 002e FFF7FEFF 		bl	clear_oneshot_layer_state
 863              	.LVL121:
 213:tmk_core/common/action.c ****     }
 864              		.loc 1 213 0
 865 0032 FFF7FEFF 		bl	is_oneshot_layer_active
 866              	.LVL122:
 867 0036 80F00100 		eor	r0, r0, #1
 868 003a 5FFA80F8 		uxtb	r8, r0
 869              	.LVL123:
 870              	.L76:
 217:tmk_core/common/action.c ****         /* Key and Mods */
 871              		.loc 1 217 0
 872 003e C4F30336 		ubfx	r6, r4, #12, #4
 873 0042 0F2E     		cmp	r6, #15
 874 0044 40D8     		bhi	.L88
 875 0046 DFE816F0 		tbh	[pc, r6, lsl #1]
 876              	.L79:
 877 004a 1300     		.2byte	(.L78-.L79)/2
 878 004c 1300     		.2byte	(.L78-.L79)/2
 879 004e 5A00     		.2byte	(.L80-.L79)/2
 880 0050 5A00     		.2byte	(.L80-.L79)/2
 881 0052 AB00     		.2byte	(.L81-.L79)/2
 882 0054 C400     		.2byte	(.L82-.L79)/2
 883 0056 3F00     		.2byte	(.L88-.L79)/2
 884 0058 3F00     		.2byte	(.L88-.L79)/2
 885 005a F800     		.2byte	(.L83-.L79)/2
 886 005c 5001     		.2byte	(.L84-.L79)/2
 887 005e 6201     		.2byte	(.L85-.L79)/2
 888 0060 6201     		.2byte	(.L85-.L79)/2
 889 0062 C301     		.2byte	(.L86-.L79)/2
 890 0064 3F00     		.2byte	(.L88-.L79)/2
 891 0066 3F00     		.2byte	(.L88-.L79)/2
 892 0068 CC01     		.2byte	(.L87-.L79)/2
 893              	.LVL124:
 894              		.p2align 1
 895              	.L166:
 209:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 896              		.loc 1 209 0
 897 006a 4FF00008 		mov	r8, #0
 898 006e E6E7     		b	.L76
 899              	.LVL125:
 900              	.L78:
 901              	.LBB35:
 221:tmk_core/common/action.c ****             if (event.pressed) {
 902              		.loc 1 221 0
 903 0070 C4F30723 		ubfx	r3, r4, #8, #8
 904 0074 C4F30326 		ubfx	r6, r4, #8, #4
 905 0078 13F0F00F 		tst	r3, #240
 906 007c 18BF     		it	ne
 907 007e 3601     		lslne	r6, r6, #4
 908              	.LVL126:
 909 0080 E4B2     		uxtb	r4, r4
 910              	.LVL127:
 222:tmk_core/common/action.c ****                 if (mods) {
 911              		.loc 1 222 0
 912 0082 95B1     		cbz	r5, .L90
 223:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 913              		.loc 1 223 0
 914 0084 56B1     		cbz	r6, .L111
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 915              		.loc 1 224 0
 916 0086 04F12003 		add	r3, r4, #32
 917 008a DBB2     		uxtb	r3, r3
 918 008c 072B     		cmp	r3, #7
 228:tmk_core/common/action.c ****                     } else {
 919              		.loc 1 228 0
 920 008e 3046     		mov	r0, r6
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 921              		.loc 1 224 0
 922 0090 00D9     		bls	.L92
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 923              		.loc 1 224 0 is_stmt 0 discriminator 1
 924 0092 3CB9     		cbnz	r4, .L93
 925              	.L92:
 228:tmk_core/common/action.c ****                     } else {
 926              		.loc 1 228 0 is_stmt 1
 927 0094 FFF7FEFF 		bl	add_mods
 928              	.LVL128:
 929              	.L94:
 232:tmk_core/common/action.c ****                 }
 930              		.loc 1 232 0
 931 0098 FFF7FEFF 		bl	send_keyboard_report
 932              	.LVL129:
 933              	.L111:
 934              	.LBE35:
 935              	.LBB36:
 318:tmk_core/common/action.c ****                             }
 936              		.loc 1 318 0
 937 009c 2046     		mov	r0, r4
 938 009e FFF7FEFF 		bl	register_code
 939              	.LVL130:
 940 00a2 11E0     		b	.L88
 941              	.LVL131:
 942              	.L93:
 943              	.LBE36:
 944              	.LBB37:
 230:tmk_core/common/action.c ****                     }
 945              		.loc 1 230 0
 946 00a4 FFF7FEFF 		bl	add_weak_mods
 947              	.LVL132:
 948 00a8 F6E7     		b	.L94
 949              	.L90:
 236:tmk_core/common/action.c ****                 if (mods) {
 950              		.loc 1 236 0
 951 00aa 2046     		mov	r0, r4
 952 00ac FFF7FEFF 		bl	unregister_code
 953              	.LVL133:
 237:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 954              		.loc 1 237 0
 955 00b0 56B1     		cbz	r6, .L88
 238:tmk_core/common/action.c ****                         del_mods(mods);
 956              		.loc 1 238 0
 957 00b2 04F12003 		add	r3, r4, #32
 958 00b6 DBB2     		uxtb	r3, r3
 959 00b8 072B     		cmp	r3, #7
 239:tmk_core/common/action.c ****                     } else {
 960              		.loc 1 239 0
 961 00ba 3046     		mov	r0, r6
 238:tmk_core/common/action.c ****                         del_mods(mods);
 962              		.loc 1 238 0
 963 00bc 00D9     		bls	.L96
 238:tmk_core/common/action.c ****                         del_mods(mods);
 964              		.loc 1 238 0 is_stmt 0 discriminator 1
 965 00be DCB9     		cbnz	r4, .L97
 966              	.L96:
 239:tmk_core/common/action.c ****                     } else {
 967              		.loc 1 239 0 is_stmt 1
 968 00c0 FFF7FEFF 		bl	del_mods
 969              	.LVL134:
 970              	.L98:
 243:tmk_core/common/action.c ****                 }
 971              		.loc 1 243 0
 972 00c4 FFF7FEFF 		bl	send_keyboard_report
 973              	.LVL135:
 974              	.L88:
 975              	.LBE37:
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 976              		.loc 1 696 0
 977 00c8 B8F1000F 		cmp	r8, #0
 978 00cc 00F09081 		beq	.L74
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 979              		.loc 1 696 0 is_stmt 0 discriminator 1
 980 00d0 FFF7FEFF 		bl	get_oneshot_layer_state
 981              	.LVL136:
 982 00d4 10F00100 		ands	r0, r0, #1
 983 00d8 40F08A81 		bne	.L74
 697:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 984              		.loc 1 697 0 is_stmt 1
 985 00dc B870     		strb	r0, [r7, #2]
 698:tmk_core/common/action.c ****         process_record(record);
 986              		.loc 1 698 0
 987 00de FFF7FEFF 		bl	get_oneshot_layer
 988              	.LVL137:
 989 00e2 FFF7FEFF 		bl	layer_on
 990              	.LVL138:
 699:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 991              		.loc 1 699 0
 992 00e6 3846     		mov	r0, r7
 993 00e8 FFF7FEFF 		bl	process_record
 994              	.LVL139:
 700:tmk_core/common/action.c ****     }
 995              		.loc 1 700 0
 996 00ec FFF7FEFF 		bl	get_oneshot_layer
 997              	.LVL140:
 703:tmk_core/common/action.c **** 
 998              		.loc 1 703 0
 999 00f0 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 1000              		.cfi_remember_state
 1001              		.cfi_restore 14
 1002              		.cfi_restore 10
 1003              		.cfi_restore 9
 1004              		.cfi_restore 8
 1005              		.cfi_restore 7
 1006              		.cfi_restore 6
 1007              		.cfi_restore 5
 1008              		.cfi_restore 4
 1009              		.cfi_def_cfa_offset 0
 1010              	.LVL141:
 700:tmk_core/common/action.c ****     }
 1011              		.loc 1 700 0
 1012 00f4 FFF7FEBF 		b	layer_off
 1013              	.LVL142:
 1014              	.L97:
 1015              		.cfi_restore_state
 1016              	.LBB38:
 241:tmk_core/common/action.c ****                     }
 1017              		.loc 1 241 0
 1018 00f8 FFF7FEFF 		bl	del_weak_mods
 1019              	.LVL143:
 1020 00fc E2E7     		b	.L98
 1021              	.LVL144:
 1022              	.L80:
 1023              	.LBE38:
 1024              	.LBB39:
 250:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1025              		.loc 1 250 0
 1026 00fe C4F30723 		ubfx	r3, r4, #8, #8
 1027 0102 03F0F003 		and	r3, r3, #240
 1028 0106 C4F30326 		ubfx	r6, r4, #8, #4
 1029 010a 202B     		cmp	r3, #32
 251:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1030              		.loc 1 251 0
 1031 010c E4B2     		uxtb	r4, r4
 1032              	.LVL145:
 250:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1033              		.loc 1 250 0
 1034 010e 18BF     		it	ne
 1035 0110 3601     		lslne	r6, r6, #4
 1036              	.LVL146:
 251:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1037              		.loc 1 251 0
 1038 0112 64B1     		cbz	r4, .L101
 251:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1039              		.loc 1 251 0 is_stmt 0 discriminator 4
 1040 0114 012C     		cmp	r4, #1
 1041 0116 2CD0     		beq	.L102
 306:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1042              		.loc 1 306 0 is_stmt 1
 1043 0118 ADB3     		cbz	r5, .L109
 307:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 1044              		.loc 1 307 0
 1045 011a B9F1000F 		cmp	r9, #0
 1046 011e 2CD0     		beq	.L202
 309:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1047              		.loc 1 309 0
 1048 0120 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1049 0122 D907     		lsls	r1, r3, #31
 1050 0124 BAD5     		bpl	.L111
 312:tmk_core/common/action.c ****                                 register_mods(mods);
 1051              		.loc 1 312 0
 1052 0126 6FF30713 		bfc	r3, #4, #4
 1053 012a BB71     		strb	r3, [r7, #6]
 1054 012c 25E0     		b	.L202
 1055              	.L101:
 255:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1056              		.loc 1 255 0
 1057 012e 9DB1     		cbz	r5, .L103
 256:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1058              		.loc 1 256 0
 1059 0130 B9F1000F 		cmp	r9, #0
 1060 0134 06D1     		bne	.L104
 1061              	.L105:
 270:tmk_core/common/action.c ****                         }
 1062              		.loc 1 270 0
 1063 0136 FFF7FEFF 		bl	get_oneshot_mods
 1064              	.LVL147:
 1065 013a 3043     		orrs	r0, r0, r6
 1066 013c C0B2     		uxtb	r0, r0
 1067              	.L201:
 313:tmk_core/common/action.c ****                             } else
 1068              		.loc 1 313 0
 1069 013e FFF7FEFF 		bl	register_mods
 1070              	.LVL148:
 1071 0142 C1E7     		b	.L88
 1072              	.L104:
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1073              		.loc 1 259 0
 1074 0144 B9F1010F 		cmp	r9, #1
 1075 0148 F5D1     		bne	.L105
 261:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1076              		.loc 1 261 0
 1077 014a FFF7FEFF 		bl	get_oneshot_mods
 1078              	.LVL149:
 1079 014e 3043     		orrs	r0, r0, r6
 1080 0150 C0B2     		uxtb	r0, r0
 1081 0152 FFF7FEFF 		bl	set_oneshot_mods
 1082              	.LVL150:
 1083 0156 B7E7     		b	.L88
 1084              	.L103:
 273:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1085              		.loc 1 273 0
 1086 0158 B9F1000F 		cmp	r9, #0
 1087 015c 05D1     		bne	.L106
 1088              	.L203:
 288:tmk_core/common/action.c ****                             unregister_mods(mods);
 1089              		.loc 1 288 0
 1090 015e FFF7FEFF 		bl	clear_oneshot_mods
 1091              	.LVL151:
 1092              	.L112:
 333:tmk_core/common/action.c ****                         }
 1093              		.loc 1 333 0
 1094 0162 3046     		mov	r0, r6
 1095 0164 FFF7FEFF 		bl	unregister_mods
 1096              	.LVL152:
 1097 0168 AEE7     		b	.L88
 1098              	.L106:
 276:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1099              		.loc 1 276 0
 1100 016a B9F1010F 		cmp	r9, #1
 1101 016e ABD0     		beq	.L88
 1102 0170 F5E7     		b	.L203
 1103              	.L102:
 295:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1104              		.loc 1 295 0
 1105 0172 25B1     		cbz	r5, .L108
 296:tmk_core/common/action.c ****                             register_mods(mods);
 1106              		.loc 1 296 0
 1107 0174 B9F1050F 		cmp	r9, #5
 1108 0178 A6D8     		bhi	.L88
 1109              	.L202:
 313:tmk_core/common/action.c ****                             } else
 1110              		.loc 1 313 0
 1111 017a 3046     		mov	r0, r6
 1112 017c DFE7     		b	.L201
 1113              	.L108:
 300:tmk_core/common/action.c ****                             unregister_mods(mods);
 1114              		.loc 1 300 0
 1115 017e B9F1040F 		cmp	r9, #4
 1116 0182 A1D8     		bhi	.L88
 1117 0184 EDE7     		b	.L112
 1118              	.L109:
 325:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1119              		.loc 1 325 0
 1120 0186 B9F1000F 		cmp	r9, #0
 1121 018a EAD0     		beq	.L112
 327:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1122              		.loc 1 327 0
 1123 018c 392C     		cmp	r4, #57
 1124 018e 03D1     		bne	.L113
 328:tmk_core/common/action.c ****                             }
 1125              		.loc 1 328 0 discriminator 1
 1126 0190 4FF4FA50 		mov	r0, #8000
 1127 0194 FFF7FEFF 		bl	chThdSleep
 1128              	.LVL153:
 1129              	.L113:
 330:tmk_core/common/action.c ****                         } else {
 1130              		.loc 1 330 0
 1131 0198 2046     		mov	r0, r4
 1132 019a FFF7FEFF 		bl	unregister_code
 1133              	.LVL154:
 1134 019e 93E7     		b	.L88
 1135              	.LVL155:
 1136              	.L81:
 1137              	.LBE39:
 343:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1138              		.loc 1 343 0
 1139 01a0 C4F38123 		ubfx	r3, r4, #10, #2
 1140 01a4 2BB1     		cbz	r3, .L115
 1141 01a6 012B     		cmp	r3, #1
 1142 01a8 0BD0     		beq	.L116
 1143              	.L114:
 654:tmk_core/common/action.c ****         case ACT_LAYER:
 1144              		.loc 1 654 0
 1145 01aa 083E     		subs	r6, r6, #8
 1146 01ac 032E     		cmp	r6, #3
 1147 01ae 61D9     		bls	.L129
 1148 01b0 8AE7     		b	.L88
 1149              	.L115:
 345:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1150              		.loc 1 345 0
 1151 01b2 25B1     		cbz	r5, .L117
 346:tmk_core/common/action.c ****                     } else {
 1152              		.loc 1 346 0
 1153 01b4 C4F30900 		ubfx	r0, r4, #0, #10
 1154              	.L199:
 348:tmk_core/common/action.c ****                     }
 1155              		.loc 1 348 0
 1156 01b8 FFF7FEFF 		bl	host_system_send
 1157              	.LVL156:
 1158 01bc 84E7     		b	.L88
 1159              	.L117:
 1160 01be 2846     		mov	r0, r5
 1161 01c0 FAE7     		b	.L199
 1162              	.L116:
 352:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1163              		.loc 1 352 0
 1164 01c2 25B1     		cbz	r5, .L118
 353:tmk_core/common/action.c ****                     } else {
 1165              		.loc 1 353 0
 1166 01c4 C4F30900 		ubfx	r0, r4, #0, #10
 1167              	.L198:
 355:tmk_core/common/action.c ****                     }
 1168              		.loc 1 355 0
 1169 01c8 FFF7FEFF 		bl	host_consumer_send
 1170              	.LVL157:
 1171 01cc 7CE7     		b	.L88
 1172              	.L118:
 1173 01ce 2846     		mov	r0, r5
 1174 01d0 FAE7     		b	.L198
 1175              	.L82:
 1176 01d2 E0B2     		uxtb	r0, r4
 364:tmk_core/common/action.c ****                 switch (action.key.code) {
 1177              		.loc 1 364 0
 1178 01d4 CDB1     		cbz	r5, .L119
 365:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1179              		.loc 1 365 0
 1180 01d6 F528     		cmp	r0, #245
 1181 01d8 0DD0     		beq	.L121
 1182 01da F628     		cmp	r0, #246
 1183 01dc 10D0     		beq	.L122
 1184 01de F428     		cmp	r0, #244
 1185 01e0 04D1     		bne	.L120
 367:tmk_core/common/action.c ****                         break;
 1186              		.loc 1 367 0
 1187 01e2 844A     		ldr	r2, .L204
 1188 01e4 1368     		ldr	r3, [r2]
 1189 01e6 43F00103 		orr	r3, r3, #1
 1190              	.L191:
 373:tmk_core/common/action.c ****                         break;
 1191              		.loc 1 373 0
 1192 01ea 1360     		str	r3, [r2]
 1193              	.L120:
 378:tmk_core/common/action.c ****                 mousekey_send();
 1194              		.loc 1 378 0
 1195 01ec FFF7FEFF 		bl	mousekey_on
 1196              	.LVL158:
 1197              	.L200:
 395:tmk_core/common/action.c ****             }
 1198              		.loc 1 395 0
 1199 01f0 FFF7FEFF 		bl	mousekey_send
 1200              	.LVL159:
 1201 01f4 68E7     		b	.L88
 1202              	.L121:
 370:tmk_core/common/action.c ****                         break;
 1203              		.loc 1 370 0
 1204 01f6 7F4A     		ldr	r2, .L204
 1205 01f8 1368     		ldr	r3, [r2]
 1206 01fa 43F00203 		orr	r3, r3, #2
 1207 01fe F4E7     		b	.L191
 1208              	.L122:
 373:tmk_core/common/action.c ****                         break;
 1209              		.loc 1 373 0
 1210 0200 7C4A     		ldr	r2, .L204
 1211 0202 1368     		ldr	r3, [r2]
 1212 0204 43F00403 		orr	r3, r3, #4
 1213 0208 EFE7     		b	.L191
 1214              	.L119:
 381:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1215              		.loc 1 381 0
 1216 020a F528     		cmp	r0, #245
 1217 020c 0BD0     		beq	.L125
 1218 020e F628     		cmp	r0, #246
 1219 0210 0ED0     		beq	.L126
 1220 0212 F428     		cmp	r0, #244
 1221 0214 04D1     		bne	.L124
 383:tmk_core/common/action.c ****                         break;
 1222              		.loc 1 383 0
 1223 0216 774A     		ldr	r2, .L204
 1224 0218 1368     		ldr	r3, [r2]
 1225 021a 23F00103 		bic	r3, r3, #1
 1226              	.L192:
 389:tmk_core/common/action.c ****                         break;
 1227              		.loc 1 389 0
 1228 021e 1360     		str	r3, [r2]
 1229              	.L124:
 394:tmk_core/common/action.c ****                 mousekey_send();
 1230              		.loc 1 394 0
 1231 0220 FFF7FEFF 		bl	mousekey_off
 1232              	.LVL160:
 1233 0224 E4E7     		b	.L200
 1234              	.L125:
 386:tmk_core/common/action.c ****                         break;
 1235              		.loc 1 386 0
 1236 0226 734A     		ldr	r2, .L204
 1237 0228 1368     		ldr	r3, [r2]
 1238 022a 23F00203 		bic	r3, r3, #2
 1239 022e F6E7     		b	.L192
 1240              	.L126:
 389:tmk_core/common/action.c ****                         break;
 1241              		.loc 1 389 0
 1242 0230 704A     		ldr	r2, .L204
 1243 0232 1368     		ldr	r3, [r2]
 1244 0234 23F00403 		bic	r3, r3, #4
 1245 0238 F1E7     		b	.L192
 1246              	.L83:
 401:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1247              		.loc 1 401 0
 1248 023a 14F4407F 		tst	r4, #768
 1249 023e 27D1     		bne	.L128
 403:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1250              		.loc 1 403 0
 1251 0240 C5B9     		cbnz	r5, .L129
 1252              	.LVL161:
 1253              	.LBB40:
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1254              		.loc 1 406 0
 1255 0242 E206     		lsls	r2, r4, #27
 404:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1256              		.loc 1 404 0
 1257 0244 C4F34210 		ubfx	r0, r4, #5, #3
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1258              		.loc 1 406 0
 1259 0248 48BF     		it	mi
 1260 024a 0F25     		movmi	r5, #15
 405:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1261              		.loc 1 405 0
 1262 024c 4FEA8000 		lsl	r0, r0, #2
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1263              		.loc 1 406 0
 1264 0250 48BF     		it	mi
 1265 0252 8540     		lslmi	r5, r5, r0
 405:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1266              		.loc 1 405 0
 1267 0254 04F00F03 		and	r3, r4, #15
 407:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1268              		.loc 1 407 0
 1269 0258 C4F38124 		ubfx	r4, r4, #10, #2
 1270              	.LVL162:
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1271              		.loc 1 406 0
 1272 025c 48BF     		it	mi
 1273 025e ED43     		mvnmi	r5, r5
 405:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1274              		.loc 1 405 0
 1275 0260 8340     		lsls	r3, r3, r0
 1276              	.LVL163:
 407:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1277              		.loc 1 407 0
 1278 0262 022C     		cmp	r4, #2
 1279 0264 45EA0300 		orr	r0, r5, r3
 1280 0268 0CD0     		beq	.L132
 407:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1281              		.loc 1 407 0 is_stmt 0 discriminator 4
 1282 026a 0ED8     		bhi	.L133
 1283 026c 012C     		cmp	r4, #1
 1284 026e 06D0     		beq	.L134
 409:tmk_core/common/action.c ****                             break;
 1285              		.loc 1 409 0 is_stmt 1 discriminator 4
 1286 0270 FFF7FEFF 		bl	default_layer_and
 1287              	.LVL164:
 1288              	.L129:
 1289              	.LBE40:
 661:tmk_core/common/action.c ****             break;
 1290              		.loc 1 661 0
 1291 0274 FFF7FEFF 		bl	host_keyboard_leds
 1292              	.LVL165:
 1293 0278 FFF7FEFF 		bl	led_set
 1294              	.LVL166:
 662:tmk_core/common/action.c ****         default:
 1295              		.loc 1 662 0
 1296 027c 24E7     		b	.L88
 1297              	.LVL167:
 1298              	.L134:
 1299              	.LBB41:
 412:tmk_core/common/action.c ****                             break;
 1300              		.loc 1 412 0
 1301 027e FFF7FEFF 		bl	default_layer_or
 1302              	.LVL168:
 413:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1303              		.loc 1 413 0
 1304 0282 F7E7     		b	.L129
 1305              	.LVL169:
 1306              	.L132:
 415:tmk_core/common/action.c ****                             break;
 1307              		.loc 1 415 0
 1308 0284 FFF7FEFF 		bl	default_layer_xor
 1309              	.LVL170:
 416:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1310              		.loc 1 416 0
 1311 0288 F4E7     		b	.L129
 1312              	.LVL171:
 1313              	.L133:
 418:tmk_core/common/action.c ****                             break;
 1314              		.loc 1 418 0
 1315 028a FFF7FEFF 		bl	default_layer_set
 1316              	.LVL172:
 419:tmk_core/common/action.c ****                     }
 1317              		.loc 1 419 0
 1318 028e F1E7     		b	.L129
 1319              	.LVL173:
 1320              	.L128:
 1321 0290 C4F30122 		ubfx	r2, r4, #8, #2
 1322 0294 D3B2     		uxtb	r3, r2
 1323              	.LBE41:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1324              		.loc 1 424 0
 1325 0296 EDB1     		cbz	r5, .L135
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1326              		.loc 1 424 0 is_stmt 0 discriminator 1
 1327 0298 02F00103 		and	r3, r2, #1
 1328              	.L136:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1329              		.loc 1 424 0 discriminator 4
 1330 029c 002B     		cmp	r3, #0
 1331 029e E9D0     		beq	.L129
 1332              	.LVL174:
 1333              	.LBB42:
 425:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1334              		.loc 1 425 0 is_stmt 1
 1335 02a0 C4F34210 		ubfx	r0, r4, #5, #3
 426:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1336              		.loc 1 426 0
 1337 02a4 8300     		lsls	r3, r0, #2
 1338 02a6 04F00F00 		and	r0, r4, #15
 1339 02aa 00FA03F2 		lsl	r2, r0, r3
 1340              	.LVL175:
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1341              		.loc 1 427 0
 1342 02ae 14F01000 		ands	r0, r4, #16
 1343 02b2 1CBF     		itt	ne
 1344 02b4 0F20     		movne	r0, #15
 1345 02b6 9840     		lslne	r0, r0, r3
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1346              		.loc 1 428 0
 1347 02b8 C4F38124 		ubfx	r4, r4, #10, #2
 1348              	.LVL176:
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1349              		.loc 1 427 0
 1350 02bc 18BF     		it	ne
 1351 02be C043     		mvnne	r0, r0
 1352              	.LVL177:
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1353              		.loc 1 428 0
 1354 02c0 022C     		cmp	r4, #2
 1355 02c2 40EA0200 		orr	r0, r0, r2
 1356              	.LVL178:
 1357 02c6 0AD0     		beq	.L139
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1358              		.loc 1 428 0 is_stmt 0 discriminator 4
 1359 02c8 0CD8     		bhi	.L140
 1360 02ca 012C     		cmp	r4, #1
 1361 02cc 04D0     		beq	.L141
 430:tmk_core/common/action.c ****                             break;
 1362              		.loc 1 430 0 is_stmt 1 discriminator 4
 1363 02ce FFF7FEFF 		bl	layer_and
 1364              	.LVL179:
 431:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1365              		.loc 1 431 0 discriminator 4
 1366 02d2 CFE7     		b	.L129
 1367              	.LVL180:
 1368              	.L135:
 1369              	.LBE42:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1370              		.loc 1 424 0 discriminator 2
 1371 02d4 5B08     		lsrs	r3, r3, #1
 1372 02d6 E1E7     		b	.L136
 1373              	.LVL181:
 1374              	.L141:
 1375              	.LBB43:
 433:tmk_core/common/action.c ****                             break;
 1376              		.loc 1 433 0
 1377 02d8 FFF7FEFF 		bl	layer_or
 1378              	.LVL182:
 434:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1379              		.loc 1 434 0
 1380 02dc CAE7     		b	.L129
 1381              	.LVL183:
 1382              	.L139:
 436:tmk_core/common/action.c ****                             break;
 1383              		.loc 1 436 0
 1384 02de FFF7FEFF 		bl	layer_xor
 1385              	.LVL184:
 437:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1386              		.loc 1 437 0
 1387 02e2 C7E7     		b	.L129
 1388              	.LVL185:
 1389              	.L140:
 439:tmk_core/common/action.c ****                             break;
 1390              		.loc 1 439 0
 1391 02e4 FFF7FEFF 		bl	layer_state_set
 1392              	.LVL186:
 440:tmk_core/common/action.c ****                     }
 1393              		.loc 1 440 0
 1394 02e8 C4E7     		b	.L129
 1395              	.LVL187:
 1396              	.L84:
 1397 02ea E6B2     		uxtb	r6, r4
 1398 02ec C4F30324 		ubfx	r4, r4, #8, #4
 1399              	.LVL188:
 1400              	.LBE43:
 446:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1401              		.loc 1 446 0
 1402 02f0 35B1     		cbz	r5, .L142
 447:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1403              		.loc 1 447 0
 1404 02f2 2046     		mov	r0, r4
 1405 02f4 FFF7FEFF 		bl	layer_on
 1406              	.LVL189:
 448:tmk_core/common/action.c ****             } else {
 1407              		.loc 1 448 0
 1408 02f8 3046     		mov	r0, r6
 1409 02fa FFF7FEFF 		bl	register_mods
 1410              	.LVL190:
 1411 02fe B9E7     		b	.L129
 1412              	.L142:
 450:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1413              		.loc 1 450 0
 1414 0300 3046     		mov	r0, r6
 1415 0302 FFF7FEFF 		bl	unregister_mods
 1416              	.LVL191:
 451:tmk_core/common/action.c ****             }
 1417              		.loc 1 451 0
 1418 0306 2046     		mov	r0, r4
 1419 0308 FFF7FEFF 		bl	layer_off
 1420              	.LVL192:
 1421 030c B2E7     		b	.L129
 1422              	.LVL193:
 1423              	.L85:
 457:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1424              		.loc 1 457 0
 1425 030e 5FFA84FA 		uxtb	r10, r4
 1426 0312 AAF1F003 		sub	r3, r10, #240
 1427 0316 042B     		cmp	r3, #4
 1428 0318 3DD8     		bhi	.L143
 1429 031a DFE803F0 		tbb	[pc, r3]
 1430              	.L145:
 1431 031e 03       		.byte	(.L144-.L145)/2
 1432 031f 10       		.byte	(.L146-.L145)/2
 1433 0320 16       		.byte	(.L147-.L145)/2
 1434 0321 1D       		.byte	(.L148-.L145)/2
 1435 0322 26       		.byte	(.L149-.L145)/2
 1436 0323 00       		.p2align 1
 1437              	.L144:
 460:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1438              		.loc 1 460 0
 1439 0324 45B1     		cbz	r5, .L150
 461:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1440              		.loc 1 461 0
 1441 0326 B9F1040F 		cmp	r9, #4
 1442              	.L194:
 1443 032a 3FF63EAF 		bhi	.L114
 462:tmk_core/common/action.c ****                         }
 1444              		.loc 1 462 0
 1445 032e C4F30420 		ubfx	r0, r4, #8, #5
 1446 0332 FFF7FEFF 		bl	layer_invert
 1447              	.LVL194:
 1448 0336 38E7     		b	.L114
 1449              	.L150:
 465:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1450              		.loc 1 465 0
 1451 0338 B9F1050F 		cmp	r9, #5
 1452 033c F5E7     		b	.L194
 1453              	.L146:
 1454 033e C4F30420 		ubfx	r0, r4, #8, #5
 471:tmk_core/common/action.c ****                     break;
 1455              		.loc 1 471 0
 1456 0342 35B1     		cbz	r5, .L197
 1457              	.L196:
 525:tmk_core/common/action.c ****                         }
 1458              		.loc 1 525 0
 1459 0344 FFF7FEFF 		bl	layer_on
 1460              	.LVL195:
 1461 0348 2FE7     		b	.L114
 1462              	.L147:
 1463 034a C4F30420 		ubfx	r0, r4, #8, #5
 474:tmk_core/common/action.c ****                     break;
 1464              		.loc 1 474 0
 1465 034e 002D     		cmp	r5, #0
 1466 0350 F8D0     		beq	.L196
 1467              	.L197:
 538:tmk_core/common/action.c ****                         }
 1468              		.loc 1 538 0
 1469 0352 FFF7FEFF 		bl	layer_off
 1470              	.LVL196:
 1471 0356 28E7     		b	.L114
 1472              	.L148:
 477:tmk_core/common/action.c ****                     break;
 1473              		.loc 1 477 0
 1474 0358 25B1     		cbz	r5, .L155
 477:tmk_core/common/action.c ****                     break;
 1475              		.loc 1 477 0 is_stmt 0 discriminator 1
 1476 035a C4F30420 		ubfx	r0, r4, #8, #5
 1477 035e FFF7FEFF 		bl	layer_move
 1478              	.LVL197:
 1479 0362 22E7     		b	.L114
 1480              	.L155:
 477:tmk_core/common/action.c ****                     break;
 1481              		.loc 1 477 0 discriminator 2
 1482 0364 FFF7FEFF 		bl	layer_clear
 1483              	.LVL198:
 1484 0368 1FE7     		b	.L114
 1485              	.L149:
 505:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1486              		.loc 1 505 0 is_stmt 1
 1487 036a 4DB1     		cbz	r5, .L156
 506:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1488              		.loc 1 506 0
 1489 036c C4F30424 		ubfx	r4, r4, #8, #5
 1490              	.LVL199:
 1491 0370 2046     		mov	r0, r4
 1492 0372 FFF7FEFF 		bl	layer_on
 1493              	.LVL200:
 507:tmk_core/common/action.c ****                     } else {
 1494              		.loc 1 507 0
 1495 0376 0321     		movs	r1, #3
 1496 0378 2046     		mov	r0, r4
 1497 037a FFF7FEFF 		bl	set_oneshot_layer
 1498              	.LVL201:
 1499 037e 14E7     		b	.L114
 1500              	.LVL202:
 1501              	.L156:
 509:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1502              		.loc 1 509 0
 1503 0380 0120     		movs	r0, #1
 1504 0382 FFF7FEFF 		bl	clear_oneshot_layer_state
 1505              	.LVL203:
 510:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1506              		.loc 1 510 0
 1507 0386 B9F1010F 		cmp	r9, #1
 1508 038a 7FF60EAF 		bls	.L114
 511:tmk_core/common/action.c ****                         }
 1509              		.loc 1 511 0
 1510 038e 0220     		movs	r0, #2
 1511 0390 FFF7FEFF 		bl	clear_oneshot_layer_state
 1512              	.LVL204:
 1513 0394 09E7     		b	.L114
 1514              	.L143:
 519:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1515              		.loc 1 519 0
 1516 0396 4DB1     		cbz	r5, .L157
 520:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1517              		.loc 1 520 0
 1518 0398 B9F1000F 		cmp	r9, #0
 1519 039c 03D0     		beq	.L158
 522:tmk_core/common/action.c ****                         } else {
 1520              		.loc 1 522 0
 1521 039e 5046     		mov	r0, r10
 1522 03a0 FFF7FEFF 		bl	register_code
 1523              	.LVL205:
 1524 03a4 01E7     		b	.L114
 1525              	.L158:
 525:tmk_core/common/action.c ****                         }
 1526              		.loc 1 525 0
 1527 03a6 C4F30420 		ubfx	r0, r4, #8, #5
 1528 03aa CBE7     		b	.L196
 1529              	.L157:
 528:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1530              		.loc 1 528 0
 1531 03ac B9F1000F 		cmp	r9, #0
 1532 03b0 0BD0     		beq	.L159
 530:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1533              		.loc 1 530 0
 1534 03b2 BAF1390F 		cmp	r10, #57
 531:tmk_core/common/action.c ****                             } else {
 1535              		.loc 1 531 0
 1536 03b6 0CBF     		ite	eq
 1537 03b8 4FF4FA50 		moveq	r0, #8000
 533:tmk_core/common/action.c ****                             }
 1538              		.loc 1 533 0
 1539 03bc 0120     		movne	r0, #1
 1540 03be FFF7FEFF 		bl	chThdSleep
 1541              	.LVL206:
 535:tmk_core/common/action.c ****                         } else {
 1542              		.loc 1 535 0
 1543 03c2 5046     		mov	r0, r10
 1544 03c4 FFF7FEFF 		bl	unregister_code
 1545              	.LVL207:
 1546 03c8 EFE6     		b	.L114
 1547              	.L159:
 538:tmk_core/common/action.c ****                         }
 1548              		.loc 1 538 0
 1549 03ca C4F30420 		ubfx	r0, r4, #8, #5
 1550 03ce C0E7     		b	.L197
 1551              	.L86:
 549:tmk_core/common/action.c ****             break;
 1552              		.loc 1 549 0
 1553 03d0 C4F30322 		ubfx	r2, r4, #8, #4
 1554 03d4 E1B2     		uxtb	r1, r4
 1555 03d6 3846     		mov	r0, r7
 1556 03d8 FFF7FEFF 		bl	action_get_macro
 1557              	.LVL208:
 1558 03dc FFF7FEFF 		bl	action_macro_play
 1559              	.LVL209:
 550:tmk_core/common/action.c **** #endif
 1560              		.loc 1 550 0
 1561 03e0 72E6     		b	.L88
 1562              	.L87:
 645:tmk_core/common/action.c ****             break;
 1563              		.loc 1 645 0
 1564 03e2 C4F30322 		ubfx	r2, r4, #8, #4
 1565 03e6 E1B2     		uxtb	r1, r4
 1566 03e8 3846     		mov	r0, r7
 1567 03ea FFF7FEFF 		bl	action_function
 1568              	.LVL210:
 646:tmk_core/common/action.c **** #endif
 1569              		.loc 1 646 0
 1570 03ee 6BE6     		b	.L88
 1571              	.L74:
 703:tmk_core/common/action.c **** 
 1572              		.loc 1 703 0
 1573 03f0 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1574              	.LVL211:
 1575              	.L205:
 1576              		.align	2
 1577              	.L204:
 1578 03f4 00000000 		.word	.LANCHOR0
 1579              		.cfi_endproc
 1580              	.LFE290:
 1582              		.section	.text.process_record,"ax",%progbits
 1583              		.align	1
 1584              		.global	process_record
 1585              		.syntax unified
 1586              		.thumb
 1587              		.thumb_func
 1588              		.fpu softvfp
 1590              	process_record:
 1591              	.LFB289:
 172:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1592              		.loc 1 172 0
 1593              		.cfi_startproc
 1594              		@ args = 0, pretend = 0, frame = 8
 1595              		@ frame_needed = 0, uses_anonymous_args = 0
 1596              	.LVL212:
 1597 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1598              		.cfi_def_cfa_offset 24
 1599              		.cfi_offset 4, -12
 1600              		.cfi_offset 5, -8
 1601              		.cfi_offset 14, -4
 173:tmk_core/common/action.c ****         return;
 1602              		.loc 1 173 0
 1603 0002 8388     		ldrh	r3, [r0, #4]
 1604 0004 0288     		ldrh	r2, [r0]	@ unaligned
 1605 0006 ADF80420 		strh	r2, [sp, #4]	@ unaligned
 172:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1606              		.loc 1 172 0
 1607 000a 0446     		mov	r4, r0
 1608              	.LBB51:
 1609              	.LBB52:
 1610              		.file 2 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1611              		.loc 2 48 0
 1612 000c C3B1     		cbz	r3, .L206
 1613              	.LBE52:
 1614              	.LBE51:
 173:tmk_core/common/action.c ****         return;
 1615              		.loc 1 173 0
 1616 000e BDF80420 		ldrh	r2, [sp, #4]
 1617 0012 4FF6FF73 		movw	r3, #65535
 1618 0016 9A42     		cmp	r2, r3
 1619 0018 12D0     		beq	.L206
 177:tmk_core/common/action.c **** 
 1620              		.loc 1 177 0
 1621 001a FFF7FEFF 		bl	process_record_quantum
 1622              	.LVL213:
 1623 001e 78B1     		cbz	r0, .L206
 1624              	.LVL214:
 1625              	.LBB53:
 1626              	.LBB54:
 179:tmk_core/common/action.c ****     dprint("ACTION: ");
 1627              		.loc 1 179 0
 1628 0020 2188     		ldrh	r1, [r4]
 1629 0022 A078     		ldrb	r0, [r4, #2]	@ zero_extendqisi2
 1630 0024 FFF7FEFF 		bl	store_or_get_action
 1631              	.LVL215:
 1632 0028 0546     		mov	r5, r0	@ movhi
 1633              	.LVL216:
 184:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1634              		.loc 1 184 0
 1635 002a FFF7FEFF 		bl	layer_debug
 1636              	.LVL217:
 186:tmk_core/common/action.c **** #endif
 1637              		.loc 1 186 0
 1638 002e FFF7FEFF 		bl	default_layer_debug
 1639              	.LVL218:
 190:tmk_core/common/action.c **** }
 1640              		.loc 1 190 0
 1641 0032 2946     		mov	r1, r5	@ movhi
 1642 0034 2046     		mov	r0, r4
 1643              	.LBE54:
 1644              	.LBE53:
 191:tmk_core/common/action.c **** 
 1645              		.loc 1 191 0
 1646 0036 03B0     		add	sp, sp, #12
 1647              		.cfi_remember_state
 1648              		.cfi_def_cfa_offset 12
 1649              		@ sp needed
 1650 0038 BDE83040 		pop	{r4, r5, lr}
 1651              		.cfi_restore 14
 1652              		.cfi_restore 5
 1653              		.cfi_restore 4
 1654              		.cfi_def_cfa_offset 0
 1655              	.LVL219:
 1656              	.LBB56:
 1657              	.LBB55:
 190:tmk_core/common/action.c **** }
 1658              		.loc 1 190 0
 1659 003c FFF7FEBF 		b	process_action
 1660              	.LVL220:
 1661              	.L206:
 1662              		.cfi_restore_state
 1663              	.LBE55:
 1664              	.LBE56:
 191:tmk_core/common/action.c **** 
 1665              		.loc 1 191 0
 1666 0040 03B0     		add	sp, sp, #12
 1667              		.cfi_def_cfa_offset 12
 1668              		@ sp needed
 1669 0042 30BD     		pop	{r4, r5, pc}
 1670              		.cfi_endproc
 1671              	.LFE289:
 1673              		.section	.text.process_record_nocache,"ax",%progbits
 1674              		.align	1
 1675              		.global	process_record_nocache
 1676              		.syntax unified
 1677              		.thumb
 1678              		.thumb_func
 1679              		.fpu softvfp
 1681              	process_record_nocache:
 1682              	.LFB286:
 134:tmk_core/common/action.c ****     disable_action_cache = true;
 1683              		.loc 1 134 0
 1684              		.cfi_startproc
 1685              		@ args = 0, pretend = 0, frame = 0
 1686              		@ frame_needed = 0, uses_anonymous_args = 0
 1687              	.LVL221:
 1688 0000 10B5     		push	{r4, lr}
 1689              		.cfi_def_cfa_offset 8
 1690              		.cfi_offset 4, -8
 1691              		.cfi_offset 14, -4
 135:tmk_core/common/action.c ****     process_record(record);
 1692              		.loc 1 135 0
 1693 0002 044C     		ldr	r4, .L214
 1694 0004 0123     		movs	r3, #1
 1695 0006 2370     		strb	r3, [r4]
 136:tmk_core/common/action.c ****     disable_action_cache = false;
 1696              		.loc 1 136 0
 1697 0008 FFF7FEFF 		bl	process_record
 1698              	.LVL222:
 137:tmk_core/common/action.c **** }
 1699              		.loc 1 137 0
 1700 000c 0023     		movs	r3, #0
 1701 000e 2370     		strb	r3, [r4]
 138:tmk_core/common/action.c **** #else
 1702              		.loc 1 138 0
 1703 0010 10BD     		pop	{r4, pc}
 1704              	.L215:
 1705 0012 00BF     		.align	2
 1706              	.L214:
 1707 0014 00000000 		.word	.LANCHOR1
 1708              		.cfi_endproc
 1709              	.LFE286:
 1711              		.section	.text.clear_keyboard_but_mods_and_keys,"ax",%progbits
 1712              		.align	1
 1713              		.global	clear_keyboard_but_mods_and_keys
 1714              		.syntax unified
 1715              		.thumb
 1716              		.thumb_func
 1717              		.fpu softvfp
 1719              	clear_keyboard_but_mods_and_keys:
 1720              	.LFB298:
 892:tmk_core/common/action.c **** 
 893:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 894:tmk_core/common/action.c ****  *
 895:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 896:tmk_core/common/action.c ****  */
 897:tmk_core/common/action.c **** void clear_keyboard(void) {
 898:tmk_core/common/action.c ****     clear_mods();
 899:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 900:tmk_core/common/action.c **** }
 901:tmk_core/common/action.c **** 
 902:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 903:tmk_core/common/action.c ****  *
 904:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 905:tmk_core/common/action.c ****  */
 906:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 907:tmk_core/common/action.c ****     clear_keys();
 908:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 909:tmk_core/common/action.c **** }
 910:tmk_core/common/action.c **** 
 911:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 912:tmk_core/common/action.c ****  *
 913:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 914:tmk_core/common/action.c ****  */
 915:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1721              		.loc 1 915 0
 1722              		.cfi_startproc
 1723              		@ args = 0, pretend = 0, frame = 0
 1724              		@ frame_needed = 0, uses_anonymous_args = 0
 1725 0000 08B5     		push	{r3, lr}
 1726              		.cfi_def_cfa_offset 8
 1727              		.cfi_offset 3, -8
 1728              		.cfi_offset 14, -4
 916:tmk_core/common/action.c ****     clear_weak_mods();
 1729              		.loc 1 916 0
 1730 0002 FFF7FEFF 		bl	clear_weak_mods
 1731              	.LVL223:
 917:tmk_core/common/action.c ****     clear_macro_mods();
 1732              		.loc 1 917 0
 1733 0006 FFF7FEFF 		bl	clear_macro_mods
 1734              	.LVL224:
 918:tmk_core/common/action.c ****     send_keyboard_report();
 1735              		.loc 1 918 0
 1736 000a FFF7FEFF 		bl	send_keyboard_report
 1737              	.LVL225:
 919:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 920:tmk_core/common/action.c ****     mousekey_clear();
 1738              		.loc 1 920 0
 1739 000e FFF7FEFF 		bl	mousekey_clear
 1740              	.LVL226:
 921:tmk_core/common/action.c ****     mousekey_send();
 1741              		.loc 1 921 0
 1742 0012 FFF7FEFF 		bl	mousekey_send
 1743              	.LVL227:
 922:tmk_core/common/action.c **** #endif
 923:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 924:tmk_core/common/action.c ****     host_system_send(0);
 1744              		.loc 1 924 0
 1745 0016 0020     		movs	r0, #0
 1746 0018 FFF7FEFF 		bl	host_system_send
 1747              	.LVL228:
 925:tmk_core/common/action.c ****     host_consumer_send(0);
 1748              		.loc 1 925 0
 1749 001c 0020     		movs	r0, #0
 926:tmk_core/common/action.c **** #endif
 927:tmk_core/common/action.c **** }
 1750              		.loc 1 927 0
 1751 001e BDE80840 		pop	{r3, lr}
 1752              		.cfi_restore 14
 1753              		.cfi_restore 3
 1754              		.cfi_def_cfa_offset 0
 925:tmk_core/common/action.c ****     host_consumer_send(0);
 1755              		.loc 1 925 0
 1756 0022 FFF7FEBF 		b	host_consumer_send
 1757              	.LVL229:
 1758              		.cfi_endproc
 1759              	.LFE298:
 1761              		.section	.text.clear_keyboard_but_mods,"ax",%progbits
 1762              		.align	1
 1763              		.global	clear_keyboard_but_mods
 1764              		.syntax unified
 1765              		.thumb
 1766              		.thumb_func
 1767              		.fpu softvfp
 1769              	clear_keyboard_but_mods:
 1770              	.LFB297:
 906:tmk_core/common/action.c ****     clear_keys();
 1771              		.loc 1 906 0
 1772              		.cfi_startproc
 1773              		@ args = 0, pretend = 0, frame = 0
 1774              		@ frame_needed = 0, uses_anonymous_args = 0
 1775 0000 08B5     		push	{r3, lr}
 1776              		.cfi_def_cfa_offset 8
 1777              		.cfi_offset 3, -8
 1778              		.cfi_offset 14, -4
 907:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1779              		.loc 1 907 0
 1780 0002 FFF7FEFF 		bl	clear_keys
 1781              	.LVL230:
 909:tmk_core/common/action.c **** 
 1782              		.loc 1 909 0
 1783 0006 BDE80840 		pop	{r3, lr}
 1784              		.cfi_restore 14
 1785              		.cfi_restore 3
 1786              		.cfi_def_cfa_offset 0
 908:tmk_core/common/action.c **** }
 1787              		.loc 1 908 0
 1788 000a FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 1789              	.LVL231:
 1790              		.cfi_endproc
 1791              	.LFE297:
 1793              		.section	.text.clear_keyboard,"ax",%progbits
 1794              		.align	1
 1795              		.global	clear_keyboard
 1796              		.syntax unified
 1797              		.thumb
 1798              		.thumb_func
 1799              		.fpu softvfp
 1801              	clear_keyboard:
 1802              	.LFB296:
 897:tmk_core/common/action.c ****     clear_mods();
 1803              		.loc 1 897 0
 1804              		.cfi_startproc
 1805              		@ args = 0, pretend = 0, frame = 0
 1806              		@ frame_needed = 0, uses_anonymous_args = 0
 1807 0000 08B5     		push	{r3, lr}
 1808              		.cfi_def_cfa_offset 8
 1809              		.cfi_offset 3, -8
 1810              		.cfi_offset 14, -4
 898:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1811              		.loc 1 898 0
 1812 0002 FFF7FEFF 		bl	clear_mods
 1813              	.LVL232:
 900:tmk_core/common/action.c **** 
 1814              		.loc 1 900 0
 1815 0006 BDE80840 		pop	{r3, lr}
 1816              		.cfi_restore 14
 1817              		.cfi_restore 3
 1818              		.cfi_def_cfa_offset 0
 899:tmk_core/common/action.c **** }
 1819              		.loc 1 899 0
 1820 000a FFF7FEBF 		b	clear_keyboard_but_mods
 1821              	.LVL233:
 1822              		.cfi_endproc
 1823              	.LFE296:
 1825              		.section	.text.is_tap_action,"ax",%progbits
 1826              		.align	1
 1827              		.global	is_tap_action
 1828              		.syntax unified
 1829              		.thumb
 1830              		.thumb_func
 1831              		.fpu softvfp
 1833              	is_tap_action:
 1834              	.LFB300:
 928:tmk_core/common/action.c **** 
 929:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 930:tmk_core/common/action.c ****  *
 931:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 932:tmk_core/common/action.c ****  */
 933:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 934:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 935:tmk_core/common/action.c ****     return is_tap_action(action);
 936:tmk_core/common/action.c **** }
 937:tmk_core/common/action.c **** 
 938:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 939:tmk_core/common/action.c ****  *
 940:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 941:tmk_core/common/action.c ****  */
 942:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1835              		.loc 1 942 0
 1836              		.cfi_startproc
 1837              		@ args = 0, pretend = 0, frame = 0
 1838              		@ frame_needed = 0, uses_anonymous_args = 0
 1839              		@ link register save eliminated.
 1840              	.LVL234:
 943:tmk_core/common/action.c ****     switch (action.kind.id) {
 1841              		.loc 1 943 0
 1842 0000 C0F30333 		ubfx	r3, r0, #12, #4
 1843 0004 0E33     		adds	r3, r3, #14
 1844 0006 03F00F02 		and	r2, r3, #15
 1845 000a 0D2A     		cmp	r2, #13
 1846 000c 0CD8     		bhi	.L227
 1847 000e 0123     		movs	r3, #1
 1848 0010 9340     		lsls	r3, r3, r2
 1849 0012 13F4105F 		tst	r3, #9216
 1850 0016 C1B2     		uxtb	r1, r0
 1851 0018 17D1     		bne	.L221
 1852 001a 40F20330 		movw	r0, #771
 1853              	.LVL235:
 1854 001e 1840     		ands	r0, r3, r0
 1855 0020 04D1     		bne	.L222
 1856 0022 13F01003 		ands	r3, r3, #16
 1857 0026 0BD1     		bne	.L223
 1858              	.LVL236:
 1859              	.L227:
 944:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 945:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 946:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 947:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 948:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 949:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 950:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 951:tmk_core/common/action.c ****                 case OP_ONESHOT:
 952:tmk_core/common/action.c ****                     return true;
 953:tmk_core/common/action.c ****             }
 954:tmk_core/common/action.c ****             return false;
 955:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 956:tmk_core/common/action.c ****             switch (action.swap.code) {
 957:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 958:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 959:tmk_core/common/action.c ****                     return true;
 960:tmk_core/common/action.c ****             }
 961:tmk_core/common/action.c ****             return false;
 962:tmk_core/common/action.c ****         case ACT_MACRO:
 963:tmk_core/common/action.c ****         case ACT_FUNCTION:
 964:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 965:tmk_core/common/action.c ****                 return true;
 966:tmk_core/common/action.c ****             }
 967:tmk_core/common/action.c ****             return false;
 968:tmk_core/common/action.c ****     }
 969:tmk_core/common/action.c ****     return false;
 1860              		.loc 1 969 0
 1861 0028 0020     		movs	r0, #0
 1862              	.LVL237:
 1863 002a 7047     		bx	lr
 1864              	.LVL238:
 1865              	.L222:
 948:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1866              		.loc 1 948 0
 1867 002c F029     		cmp	r1, #240
 1868 002e 02D0     		beq	.L229
 1869 0030 03D8     		bhi	.L225
 1870 0032 E729     		cmp	r1, #231
 1871 0034 F8D8     		bhi	.L227
 1872              	.L229:
 952:tmk_core/common/action.c ****             }
 1873              		.loc 1 952 0
 1874 0036 0120     		movs	r0, #1
 970:tmk_core/common/action.c **** }
 1875              		.loc 1 970 0
 1876 0038 7047     		bx	lr
 1877              	.L225:
 948:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1878              		.loc 1 948 0
 1879 003a F429     		cmp	r1, #244
 1880 003c F4D1     		bne	.L227
 1881 003e FAE7     		b	.L229
 1882              	.L223:
 956:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1883              		.loc 1 956 0
 1884 0040 E729     		cmp	r1, #231
 1885 0042 F8D9     		bls	.L229
 1886 0044 F129     		cmp	r1, #241
 1887 0046 F6D0     		beq	.L229
 1888 0048 7047     		bx	lr
 1889              	.LVL239:
 1890              	.L221:
 964:tmk_core/common/action.c ****                 return true;
 1891              		.loc 1 964 0
 1892 004a C0F3C020 		ubfx	r0, r0, #11, #1
 1893              	.LVL240:
 1894 004e 7047     		bx	lr
 1895              		.cfi_endproc
 1896              	.LFE300:
 1898              		.section	.text.is_tap_key,"ax",%progbits
 1899              		.align	1
 1900              		.global	is_tap_key
 1901              		.syntax unified
 1902              		.thumb
 1903              		.thumb_func
 1904              		.fpu softvfp
 1906              	is_tap_key:
 1907              	.LFB299:
 933:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1908              		.loc 1 933 0
 1909              		.cfi_startproc
 1910              		@ args = 0, pretend = 0, frame = 8
 1911              		@ frame_needed = 0, uses_anonymous_args = 0
 1912 0000 07B5     		push	{r0, r1, r2, lr}
 1913              		.cfi_def_cfa_offset 16
 1914              		.cfi_offset 14, -4
 933:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1915              		.loc 1 933 0
 1916 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 934:tmk_core/common/action.c ****     return is_tap_action(action);
 1917              		.loc 1 934 0
 1918 0006 0198     		ldr	r0, [sp, #4]
 1919 0008 FFF7FEFF 		bl	layer_switch_get_action
 1920              	.LVL241:
 936:tmk_core/common/action.c **** 
 1921              		.loc 1 936 0
 1922 000c 03B0     		add	sp, sp, #12
 1923              		.cfi_def_cfa_offset 4
 1924              		@ sp needed
 1925 000e 5DF804EB 		ldr	lr, [sp], #4
 1926              		.cfi_restore 14
 1927              		.cfi_def_cfa_offset 0
 935:tmk_core/common/action.c **** }
 1928              		.loc 1 935 0
 1929 0012 FFF7FEBF 		b	is_tap_action
 1930              	.LVL242:
 1931              		.cfi_endproc
 1932              	.LFE299:
 1934              		.section	.text.debug_event,"ax",%progbits
 1935              		.align	1
 1936              		.global	debug_event
 1937              		.syntax unified
 1938              		.thumb
 1939              		.thumb_func
 1940              		.fpu softvfp
 1942              	debug_event:
 1943              	.LFB301:
 971:tmk_core/common/action.c **** 
 972:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 973:tmk_core/common/action.c ****  *
 974:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 975:tmk_core/common/action.c ****  */
 976:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1944              		.loc 1 976 0
 1945              		.cfi_startproc
 1946              		@ args = 0, pretend = 0, frame = 8
 1947              		@ frame_needed = 0, uses_anonymous_args = 0
 1948              		@ link register save eliminated.
 1949 0000 82B0     		sub	sp, sp, #8
 1950              		.cfi_def_cfa_offset 8
 1951              		.loc 1 976 0
 1952 0002 02AB     		add	r3, sp, #8
 1953 0004 03E90300 		stmdb	r3, {r0, r1}
 1954 0008 02B0     		add	sp, sp, #8
 1955              		.cfi_def_cfa_offset 0
 1956              		@ sp needed
 1957 000a 7047     		bx	lr
 1958              		.cfi_endproc
 1959              	.LFE301:
 1961              		.section	.text.debug_record,"ax",%progbits
 1962              		.align	1
 1963              		.global	debug_record
 1964              		.syntax unified
 1965              		.thumb
 1966              		.thumb_func
 1967              		.fpu softvfp
 1969              	debug_record:
 1970              	.LFB302:
 977:tmk_core/common/action.c **** 
 978:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 979:tmk_core/common/action.c ****  *
 980:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 981:tmk_core/common/action.c ****  */
 982:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1971              		.loc 1 982 0
 1972              		.cfi_startproc
 1973              		@ args = 0, pretend = 0, frame = 8
 1974              		@ frame_needed = 0, uses_anonymous_args = 0
 1975              		@ link register save eliminated.
 1976 0000 82B0     		sub	sp, sp, #8
 1977              		.cfi_def_cfa_offset 8
 1978              		.loc 1 982 0
 1979 0002 02AB     		add	r3, sp, #8
 1980 0004 03E90300 		stmdb	r3, {r0, r1}
 983:tmk_core/common/action.c ****     debug_event(record.event);
 984:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 985:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** }
 1981              		.loc 1 987 0
 1982 0008 02B0     		add	sp, sp, #8
 1983              		.cfi_def_cfa_offset 0
 1984              		@ sp needed
 1985 000a 7047     		bx	lr
 1986              		.cfi_endproc
 1987              	.LFE302:
 1989              		.section	.text.debug_action,"ax",%progbits
 1990              		.align	1
 1991              		.global	debug_action
 1992              		.syntax unified
 1993              		.thumb
 1994              		.thumb_func
 1995              		.fpu softvfp
 1997              	debug_action:
 1998              	.LFB303:
 988:tmk_core/common/action.c **** 
 989:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 990:tmk_core/common/action.c ****  *
 991:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 992:tmk_core/common/action.c ****  */
 993:tmk_core/common/action.c **** void debug_action(action_t action) {
 1999              		.loc 1 993 0
 2000              		.cfi_startproc
 2001              		@ args = 0, pretend = 0, frame = 0
 2002              		@ frame_needed = 0, uses_anonymous_args = 0
 2003              		@ link register save eliminated.
 2004              	.LVL243:
 994:tmk_core/common/action.c ****     switch (action.kind.id) {
 995:tmk_core/common/action.c ****         case ACT_LMODS:
 996:tmk_core/common/action.c ****             dprint("ACT_LMODS");
 997:tmk_core/common/action.c ****             break;
 998:tmk_core/common/action.c ****         case ACT_RMODS:
 999:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1000:tmk_core/common/action.c ****             break;
1001:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1002:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1003:tmk_core/common/action.c ****             break;
1004:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1005:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1006:tmk_core/common/action.c ****             break;
1007:tmk_core/common/action.c ****         case ACT_USAGE:
1008:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1009:tmk_core/common/action.c ****             break;
1010:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1011:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1012:tmk_core/common/action.c ****             break;
1013:tmk_core/common/action.c ****         case ACT_LAYER:
1014:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1015:tmk_core/common/action.c ****             break;
1016:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1017:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1018:tmk_core/common/action.c ****             break;
1019:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1020:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1021:tmk_core/common/action.c ****             break;
1022:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1023:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1024:tmk_core/common/action.c ****             break;
1025:tmk_core/common/action.c ****         case ACT_MACRO:
1026:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1027:tmk_core/common/action.c ****             break;
1028:tmk_core/common/action.c ****         case ACT_COMMAND:
1029:tmk_core/common/action.c ****             dprint("ACT_COMMAND");
1030:tmk_core/common/action.c ****             break;
1031:tmk_core/common/action.c ****         case ACT_FUNCTION:
1032:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1033:tmk_core/common/action.c ****             break;
1034:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1035:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1036:tmk_core/common/action.c ****             break;
1037:tmk_core/common/action.c ****         default:
1038:tmk_core/common/action.c ****             dprint("UNKNOWN");
1039:tmk_core/common/action.c ****             break;
1040:tmk_core/common/action.c ****     }
1041:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
1042:tmk_core/common/action.c **** }
 2005              		.loc 1 1042 0
 2006 0000 7047     		bx	lr
 2007              		.cfi_endproc
 2008              	.LFE303:
 2010              		.global	disable_action_cache
 2011              		.global	tp_buttons
 2012              		.section	.bss.disable_action_cache,"aw",%nobits
 2013              		.set	.LANCHOR1,. + 0
 2016              	disable_action_cache:
 2017 0000 00       		.space	1
 2018              		.section	.bss.tp_buttons,"aw",%nobits
 2019              		.align	2
 2020              		.set	.LANCHOR0,. + 0
 2023              	tp_buttons:
 2024 0000 00000000 		.space	4
 2025              		.text
 2026              	.Letext0:
 2027              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 2028              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 2029              		.file 5 "tmk_core/common/keycode.h"
 2030              		.file 6 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
 2031              		.file 7 "./lib/chibios/os/common/ports/ARMCMx/compilers/GCC/chtypes.h"
 2032              		.file 8 "./lib/chibios/os/rt/include/chsystypes.h"
 2033              		.file 9 "./lib/chibios/os/rt/include/chschd.h"
 2034              		.file 10 "./lib/chibios/os/common/ext/CMSIS/include/core_cm4.h"
 2035              		.file 11 "./lib/chibios/os/common/ext/CMSIS/ST/STM32F3xx/system_stm32f3xx.h"
 2036              		.file 12 "./lib/chibios/os/common/ext/CMSIS/ST/STM32F3xx/stm32f303xc.h"
 2037              		.file 13 "./lib/chibios/os/common/ports/ARMCMx/chcore.h"
 2038              		.file 14 "./lib/chibios/os/common/ports/ARMCMx/chcore_v7m.h"
 2039              		.file 15 "./lib/chibios/os/hal/ports/STM32/LLD/TIMv1/stm32_tim.h"
 2040              		.file 16 "./lib/chibios/os/rt/include/chtm.h"
 2041              		.file 17 "./lib/chibios/os/rt/include/chsem.h"
 2042              		.file 18 "./lib/chibios/os/rt/include/chmtx.h"
 2043              		.file 19 "./lib/chibios/os/rt/include/chsys.h"
 2044              		.file 20 "./lib/chibios/os/rt/include/chregistry.h"
 2045              		.file 21 "./lib/chibios/os/common/oslib/include/chmemcore.h"
 2046              		.file 22 "./lib/chibios/os/hal/ports/STM32/LLD/DMAv1/stm32_dma.h"
 2047              		.file 23 "./lib/chibios/os/hal/ports/STM32/LLD/GPIOv2/hal_pal_lld.h"
 2048              		.file 24 "./lib/chibios/os/hal/include/hal_dac.h"
 2049              		.file 25 "./lib/chibios/os/hal/ports/STM32/LLD/DACv1/hal_dac_lld.h"
 2050              		.file 26 "./lib/chibios/os/hal/include/hal_gpt.h"
 2051              		.file 27 "./lib/chibios/os/hal/ports/STM32/LLD/TIMv1/hal_gpt_lld.h"
 2052              		.file 28 "./lib/chibios/os/hal/include/hal_i2c.h"
 2053              		.file 29 "./lib/chibios/os/hal/ports/STM32/LLD/I2Cv2/hal_i2c_lld.h"
 2054              		.file 30 "./lib/chibios/os/hal/include/hal_pwm.h"
 2055              		.file 31 "./lib/chibios/os/hal/ports/STM32/LLD/TIMv1/hal_pwm_lld.h"
 2056              		.file 32 "./lib/chibios/os/hal/include/hal_usb.h"
 2057              		.file 33 "./lib/chibios/os/hal/ports/STM32/LLD/USBv1/hal_usb_lld.h"
 2058              		.file 34 "tmk_core/common/report.h"
 2059              		.file 35 "tmk_core/common/host.h"
 2060              		.file 36 "tmk_core/common/mousekey.h"
 2061              		.file 37 "tmk_core/common/command.h"
 2062              		.file 38 "tmk_core/common/action_code.h"
 2063              		.file 39 "tmk_core/common/action.h"
 2064              		.file 40 "tmk_core/common/action_layer.h"
 2065              		.file 41 "tmk_core/common/action_util.h"
 2066              		.file 42 "tmk_core/common/debug.h"
 2067              		.file 43 "./lib/chibios/os/rt/include/chthreads.h"
 2068              		.file 44 "tmk_core/common/led.h"
 2069              		.file 45 "tmk_core/common/action_macro.h"
 2070              		.file 46 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:16     .text.action_exec:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:23     .text.action_exec:0000000000000000 action_exec
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:60     .text.process_record_quantum:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:67     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:83     .text.process_record_tap_hint:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:90     .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:107    .text.register_code:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:114    .text.register_code:0000000000000000 register_code
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:491    .text.unregister_code:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:498    .text.unregister_code:0000000000000000 unregister_code
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:681    .text.tap_code:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:688    .text.tap_code:0000000000000000 tap_code
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:727    .text.register_mods:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:734    .text.register_mods:0000000000000000 register_mods
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:767    .text.unregister_mods:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:774    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:807    .text.process_action:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:814    .text.process_action:0000000000000000 process_action
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:877    .text.process_action:000000000000004a $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:894    .text.process_action:000000000000006a $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1590   .text.process_record:0000000000000000 process_record
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1431   .text.process_action:000000000000031e $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1578   .text.process_action:00000000000003f4 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1583   .text.process_record:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1674   .text.process_record_nocache:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1681   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1707   .text.process_record_nocache:0000000000000014 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1712   .text.clear_keyboard_but_mods_and_keys:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1719   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1762   .text.clear_keyboard_but_mods:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1769   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1794   .text.clear_keyboard:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1801   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1826   .text.is_tap_action:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1833   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1899   .text.is_tap_key:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1906   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1935   .text.debug_event:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1942   .text.debug_event:0000000000000000 debug_event
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1962   .text.debug_record:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1969   .text.debug_record:0000000000000000 debug_record
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1990   .text.debug_action:0000000000000000 $t
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1997   .text.debug_action:0000000000000000 debug_action
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:2016   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:2023   .bss.tp_buttons:0000000000000000 tp_buttons
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:2017   .bss.disable_action_cache:0000000000000000 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:2019   .bss.tp_buttons:0000000000000000 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1436   .text.process_action:0000000000000323 $d
/var/folders/qs/3p__ddh573j_6k2216pg8mv40000gn/T//ccknu6Jf.s:1436   .text.process_action:0000000000000324 $t

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
chThdSleep
del_key
command_proc
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
led_set
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods

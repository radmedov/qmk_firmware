   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 2
  11              		.file	"encoder.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.encoder_update_user,"ax",%progbits
  16              		.align	1
  17              		.weak	encoder_update_user
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	encoder_update_user:
  24              	.LFB287:
  25              		.file 1 "quantum/encoder.c"
   1:quantum/encoder.c **** /*
   2:quantum/encoder.c ****  * Copyright 2018 Jack Humbert <jack.humb@gmail.com>
   3:quantum/encoder.c ****  *
   4:quantum/encoder.c ****  * This program is free software: you can redistribute it and/or modify
   5:quantum/encoder.c ****  * it under the terms of the GNU General Public License as published by
   6:quantum/encoder.c ****  * the Free Software Foundation, either version 2 of the License, or
   7:quantum/encoder.c ****  * (at your option) any later version.
   8:quantum/encoder.c ****  *
   9:quantum/encoder.c ****  * This program is distributed in the hope that it will be useful,
  10:quantum/encoder.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/encoder.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/encoder.c ****  * GNU General Public License for more details.
  13:quantum/encoder.c ****  *
  14:quantum/encoder.c ****  * You should have received a copy of the GNU General Public License
  15:quantum/encoder.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/encoder.c ****  */
  17:quantum/encoder.c **** 
  18:quantum/encoder.c **** #include "encoder.h"
  19:quantum/encoder.c **** #ifdef SPLIT_KEYBOARD
  20:quantum/encoder.c **** #    include "split_util.h"
  21:quantum/encoder.c **** #endif
  22:quantum/encoder.c **** 
  23:quantum/encoder.c **** // for memcpy
  24:quantum/encoder.c **** #include <string.h>
  25:quantum/encoder.c **** 
  26:quantum/encoder.c **** #ifndef ENCODER_RESOLUTION
  27:quantum/encoder.c **** #    define ENCODER_RESOLUTION 4
  28:quantum/encoder.c **** #endif
  29:quantum/encoder.c **** 
  30:quantum/encoder.c **** #if !defined(ENCODERS_PAD_A) || !defined(ENCODERS_PAD_B)
  31:quantum/encoder.c **** #    error "No encoder pads defined by ENCODERS_PAD_A and ENCODERS_PAD_B"
  32:quantum/encoder.c **** #endif
  33:quantum/encoder.c **** 
  34:quantum/encoder.c **** #define NUMBER_OF_ENCODERS (sizeof(encoders_pad_a) / sizeof(pin_t))
  35:quantum/encoder.c **** static pin_t encoders_pad_a[] = ENCODERS_PAD_A;
  36:quantum/encoder.c **** static pin_t encoders_pad_b[] = ENCODERS_PAD_B;
  37:quantum/encoder.c **** 
  38:quantum/encoder.c **** static int8_t encoder_LUT[] = {0, -1, 1, 0, 1, 0, 0, -1, -1, 0, 0, 1, 0, 1, -1, 0};
  39:quantum/encoder.c **** 
  40:quantum/encoder.c **** static uint8_t encoder_state[NUMBER_OF_ENCODERS] = {0};
  41:quantum/encoder.c **** 
  42:quantum/encoder.c **** #ifdef SPLIT_KEYBOARD
  43:quantum/encoder.c **** // right half encoders come over as second set of encoders
  44:quantum/encoder.c **** static int8_t encoder_value[NUMBER_OF_ENCODERS * 2] = {0};
  45:quantum/encoder.c **** // row offsets for each hand
  46:quantum/encoder.c **** static uint8_t thisHand, thatHand;
  47:quantum/encoder.c **** #else
  48:quantum/encoder.c **** static int8_t encoder_value[NUMBER_OF_ENCODERS] = {0};
  49:quantum/encoder.c **** #endif
  50:quantum/encoder.c **** 
  51:quantum/encoder.c **** __attribute__((weak)) void encoder_update_user(int8_t index, bool clockwise) {}
  26              		.loc 1 51 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  32              		.loc 1 51 0
  33 0000 7047     		bx	lr
  34              		.cfi_endproc
  35              	.LFE287:
  37              		.section	.text.encoder_update_kb,"ax",%progbits
  38              		.align	1
  39              		.weak	encoder_update_kb
  40              		.syntax unified
  41              		.thumb
  42              		.thumb_func
  43              		.fpu softvfp
  45              	encoder_update_kb:
  46              	.LFB288:
  52:quantum/encoder.c **** 
  53:quantum/encoder.c **** __attribute__((weak)) void encoder_update_kb(int8_t index, bool clockwise) { encoder_update_user(in
  47              		.loc 1 53 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 0
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL1:
  52 0000 08B5     		push	{r3, lr}
  53              		.cfi_def_cfa_offset 8
  54              		.cfi_offset 3, -8
  55              		.cfi_offset 14, -4
  56              		.loc 1 53 0
  57 0002 FFF7FEFF 		bl	encoder_update_user
  58              	.LVL2:
  59 0006 08BD     		pop	{r3, pc}
  60              		.cfi_endproc
  61              	.LFE288:
  63              		.section	.text.encoder_init,"ax",%progbits
  64              		.align	1
  65              		.global	encoder_init
  66              		.syntax unified
  67              		.thumb
  68              		.thumb_func
  69              		.fpu softvfp
  71              	encoder_init:
  72              	.LFB289:
  54:quantum/encoder.c **** 
  55:quantum/encoder.c **** void encoder_init(void) {
  73              		.loc 1 55 0
  74              		.cfi_startproc
  75              		@ args = 0, pretend = 0, frame = 0
  76              		@ frame_needed = 0, uses_anonymous_args = 0
  77              	.LVL3:
  78 0000 10B5     		push	{r4, lr}
  79              		.cfi_def_cfa_offset 8
  80              		.cfi_offset 4, -8
  81              		.cfi_offset 14, -4
  82              	.LBB2:
  56:quantum/encoder.c **** #if defined(SPLIT_KEYBOARD) && defined(ENCODERS_PAD_A_RIGHT) && defined(ENCODERS_PAD_B_RIGHT)
  57:quantum/encoder.c ****     if (!isLeftHand) {
  58:quantum/encoder.c ****         const pin_t encoders_pad_a_right[] = ENCODERS_PAD_A_RIGHT;
  59:quantum/encoder.c ****         const pin_t encoders_pad_b_right[] = ENCODERS_PAD_B_RIGHT;
  60:quantum/encoder.c ****         for (uint8_t i = 0; i < NUMBER_OF_ENCODERS; i++) {
  61:quantum/encoder.c ****             encoders_pad_a[i] = encoders_pad_a_right[i];
  62:quantum/encoder.c ****             encoders_pad_b[i] = encoders_pad_b_right[i];
  63:quantum/encoder.c ****         }
  64:quantum/encoder.c ****     }
  65:quantum/encoder.c **** #endif
  66:quantum/encoder.c **** 
  67:quantum/encoder.c ****     for (int i = 0; i < NUMBER_OF_ENCODERS; i++) {
  68:quantum/encoder.c ****         setPinInputHigh(encoders_pad_a[i]);
  83              		.loc 1 68 0
  84 0002 0C4C     		ldr	r4, .L4
  85 0004 2022     		movs	r2, #32
  86 0006 4FF48051 		mov	r1, #4096
  87 000a 2046     		mov	r0, r4
  88 000c FFF7FEFF 		bl	_pal_lld_setgroupmode
  89              	.LVL4:
  69:quantum/encoder.c ****         setPinInputHigh(encoders_pad_b[i]);
  90              		.loc 1 69 0
  91 0010 2022     		movs	r2, #32
  92 0012 4FF40051 		mov	r1, #8192
  93 0016 2046     		mov	r0, r4
  94 0018 FFF7FEFF 		bl	_pal_lld_setgroupmode
  95              	.LVL5:
  70:quantum/encoder.c **** 
  71:quantum/encoder.c ****         encoder_state[i] = (readPin(encoders_pad_a[i]) << 0) | (readPin(encoders_pad_b[i]) << 1);
  96              		.loc 1 71 0
  97 001c 2269     		ldr	r2, [r4, #16]
  98 001e 2369     		ldr	r3, [r4, #16]
  99 0020 1B0B     		lsrs	r3, r3, #12
 100 0022 C2F30032 		ubfx	r2, r2, #12, #1
 101 0026 03F00203 		and	r3, r3, #2
 102 002a 1343     		orrs	r3, r3, r2
 103 002c 024A     		ldr	r2, .L4+4
 104 002e 1370     		strb	r3, [r2]
 105              	.LVL6:
 106              	.LBE2:
  72:quantum/encoder.c ****     }
  73:quantum/encoder.c **** 
  74:quantum/encoder.c **** #ifdef SPLIT_KEYBOARD
  75:quantum/encoder.c ****     thisHand = isLeftHand ? 0 : NUMBER_OF_ENCODERS;
  76:quantum/encoder.c ****     thatHand = NUMBER_OF_ENCODERS - thisHand;
  77:quantum/encoder.c **** #endif
  78:quantum/encoder.c **** }
 107              		.loc 1 78 0
 108 0030 10BD     		pop	{r4, pc}
 109              	.L5:
 110 0032 00BF     		.align	2
 111              	.L4:
 112 0034 00040048 		.word	1207960576
 113 0038 00000000 		.word	.LANCHOR0
 114              		.cfi_endproc
 115              	.LFE289:
 117              		.section	.text.encoder_read,"ax",%progbits
 118              		.align	1
 119              		.global	encoder_read
 120              		.syntax unified
 121              		.thumb
 122              		.thumb_func
 123              		.fpu softvfp
 125              	encoder_read:
 126              	.LFB291:
  79:quantum/encoder.c **** 
  80:quantum/encoder.c **** static void encoder_update(int8_t index, uint8_t state) {
  81:quantum/encoder.c ****     encoder_value[index] += encoder_LUT[state & 0xF];
  82:quantum/encoder.c ****     if (encoder_value[index] >= ENCODER_RESOLUTION) {
  83:quantum/encoder.c ****         encoder_update_kb(index, false);
  84:quantum/encoder.c ****     }
  85:quantum/encoder.c ****     if (encoder_value[index] <= -ENCODER_RESOLUTION) { // direction is arbitrary here, but this clo
  86:quantum/encoder.c ****         encoder_update_kb(index, true);
  87:quantum/encoder.c ****     }
  88:quantum/encoder.c ****     encoder_value[index] %= ENCODER_RESOLUTION;
  89:quantum/encoder.c **** }
  90:quantum/encoder.c **** 
  91:quantum/encoder.c **** void encoder_read(void) {
 127              		.loc 1 91 0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131              	.LVL7:
 132              	.LBB6:
  92:quantum/encoder.c ****     for (int i = 0; i < NUMBER_OF_ENCODERS; i++) {
  93:quantum/encoder.c ****         encoder_state[i] <<= 2;
  94:quantum/encoder.c ****         encoder_state[i] |= (readPin(encoders_pad_a[i]) << 0) | (readPin(encoders_pad_b[i]) << 1);
 133              		.loc 1 94 0
 134 0000 184B     		ldr	r3, .L9
 135 0002 1A69     		ldr	r2, [r3, #16]
 136 0004 1B69     		ldr	r3, [r3, #16]
 137              	.LBE6:
  91:quantum/encoder.c ****     for (int i = 0; i < NUMBER_OF_ENCODERS; i++) {
 138              		.loc 1 91 0
 139 0006 10B5     		push	{r4, lr}
 140              		.cfi_def_cfa_offset 8
 141              		.cfi_offset 4, -8
 142              		.cfi_offset 14, -4
 143              	.LBB11:
 144              		.loc 1 94 0
 145 0008 1B0B     		lsrs	r3, r3, #12
 146 000a C2F30032 		ubfx	r2, r2, #12, #1
 147 000e 03F00203 		and	r3, r3, #2
 148 0012 1343     		orrs	r3, r3, r2
  93:quantum/encoder.c ****         encoder_state[i] |= (readPin(encoders_pad_a[i]) << 0) | (readPin(encoders_pad_b[i]) << 1);
 149              		.loc 1 93 0
 150 0014 144A     		ldr	r2, .L9+4
 151              	.LBB7:
 152              	.LBB8:
  81:quantum/encoder.c ****     if (encoder_value[index] >= ENCODER_RESOLUTION) {
 153              		.loc 1 81 0
 154 0016 154C     		ldr	r4, .L9+8
 155              	.LBE8:
 156              	.LBE7:
  93:quantum/encoder.c ****         encoder_state[i] |= (readPin(encoders_pad_a[i]) << 0) | (readPin(encoders_pad_b[i]) << 1);
 157              		.loc 1 93 0
 158 0018 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 159              		.loc 1 94 0
 160 001a 43EA8103 		orr	r3, r3, r1, lsl #2
 161 001e DBB2     		uxtb	r3, r3
 162 0020 1370     		strb	r3, [r2]
 163              	.LVL8:
 164              	.LBB10:
 165              	.LBB9:
  81:quantum/encoder.c ****     if (encoder_value[index] >= ENCODER_RESOLUTION) {
 166              		.loc 1 81 0
 167 0022 134A     		ldr	r2, .L9+12
 168 0024 03F00F03 		and	r3, r3, #15
 169              	.LVL9:
 170 0028 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 171 002a 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 172 002c 1344     		add	r3, r3, r2
 173 002e 5BB2     		sxtb	r3, r3
  82:quantum/encoder.c ****         encoder_update_kb(index, false);
 174              		.loc 1 82 0
 175 0030 032B     		cmp	r3, #3
  81:quantum/encoder.c ****     if (encoder_value[index] >= ENCODER_RESOLUTION) {
 176              		.loc 1 81 0
 177 0032 2370     		strb	r3, [r4]
  82:quantum/encoder.c ****         encoder_update_kb(index, false);
 178              		.loc 1 82 0
 179 0034 03DD     		ble	.L7
  83:quantum/encoder.c ****     }
 180              		.loc 1 83 0
 181 0036 0021     		movs	r1, #0
 182 0038 0846     		mov	r0, r1
 183 003a FFF7FEFF 		bl	encoder_update_kb
 184              	.LVL10:
 185              	.L7:
  85:quantum/encoder.c ****         encoder_update_kb(index, true);
 186              		.loc 1 85 0
 187 003e 94F90030 		ldrsb	r3, [r4]
 188 0042 0333     		adds	r3, r3, #3
 189 0044 03DA     		bge	.L8
  86:quantum/encoder.c ****     }
 190              		.loc 1 86 0
 191 0046 0121     		movs	r1, #1
 192 0048 0020     		movs	r0, #0
 193 004a FFF7FEFF 		bl	encoder_update_kb
 194              	.LVL11:
 195              	.L8:
  88:quantum/encoder.c **** }
 196              		.loc 1 88 0
 197 004e 94F90030 		ldrsb	r3, [r4]
 198 0052 5A42     		rsbs	r2, r3, #0
 199 0054 02F00302 		and	r2, r2, #3
 200 0058 03F00303 		and	r3, r3, #3
 201 005c 58BF     		it	pl
 202 005e 5342     		rsbpl	r3, r2, #0
 203 0060 2370     		strb	r3, [r4]
 204              	.LVL12:
 205              	.LBE9:
 206              	.LBE10:
 207              	.LBE11:
  95:quantum/encoder.c **** #if SPLIT_KEYBOARD
  96:quantum/encoder.c ****         encoder_update(i + thisHand, encoder_state[i]);
  97:quantum/encoder.c **** #else
  98:quantum/encoder.c ****         encoder_update(i, encoder_state[i]);
  99:quantum/encoder.c **** #endif
 100:quantum/encoder.c ****     }
 101:quantum/encoder.c **** }
 208              		.loc 1 101 0
 209 0062 10BD     		pop	{r4, pc}
 210              	.L10:
 211              		.align	2
 212              	.L9:
 213 0064 00040048 		.word	1207960576
 214 0068 00000000 		.word	.LANCHOR0
 215 006c 00000000 		.word	.LANCHOR2
 216 0070 00000000 		.word	.LANCHOR1
 217              		.cfi_endproc
 218              	.LFE291:
 220              		.section	.bss.encoder_state,"aw",%nobits
 221              		.set	.LANCHOR0,. + 0
 224              	encoder_state:
 225 0000 00       		.space	1
 226              		.section	.bss.encoder_value,"aw",%nobits
 227              		.set	.LANCHOR2,. + 0
 230              	encoder_value:
 231 0000 00       		.space	1
 232              		.section	.rodata.encoder_LUT,"a",%progbits
 233              		.set	.LANCHOR1,. + 0
 236              	encoder_LUT:
 237 0000 00       		.byte	0
 238 0001 FF       		.byte	-1
 239 0002 01       		.byte	1
 240 0003 00       		.byte	0
 241 0004 01       		.byte	1
 242 0005 00       		.byte	0
 243 0006 00       		.byte	0
 244 0007 FF       		.byte	-1
 245 0008 FF       		.byte	-1
 246 0009 00       		.byte	0
 247 000a 00       		.byte	0
 248 000b 01       		.byte	1
 249 000c 00       		.byte	0
 250 000d 01       		.byte	1
 251 000e FF       		.byte	-1
 252 000f 00       		.byte	0
 253              		.text
 254              	.Letext0:
 255              		.file 2 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
 256              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 257              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 258              		.file 5 "./lib/chibios/os/common/ports/ARMCMx/compilers/GCC/chtypes.h"
 259              		.file 6 "./lib/chibios/os/rt/include/chsystypes.h"
 260              		.file 7 "./lib/chibios/os/rt/include/chschd.h"
 261              		.file 8 "./lib/chibios/os/common/ext/CMSIS/include/core_cm4.h"
 262              		.file 9 "./lib/chibios/os/common/ext/CMSIS/ST/STM32F3xx/system_stm32f3xx.h"
 263              		.file 10 "./lib/chibios/os/common/ext/CMSIS/ST/STM32F3xx/stm32f303xc.h"
 264              		.file 11 "./lib/chibios/os/common/ports/ARMCMx/chcore.h"
 265              		.file 12 "./lib/chibios/os/common/ports/ARMCMx/chcore_v7m.h"
 266              		.file 13 "./lib/chibios/os/hal/ports/STM32/LLD/TIMv1/stm32_tim.h"
 267              		.file 14 "./lib/chibios/os/rt/include/chtm.h"
 268              		.file 15 "./lib/chibios/os/rt/include/chsem.h"
 269              		.file 16 "./lib/chibios/os/rt/include/chmtx.h"
 270              		.file 17 "./lib/chibios/os/rt/include/chsys.h"
 271              		.file 18 "./lib/chibios/os/rt/include/chregistry.h"
 272              		.file 19 "./lib/chibios/os/common/oslib/include/chmemcore.h"
 273              		.file 20 "./lib/chibios/os/hal/ports/STM32/LLD/DMAv1/stm32_dma.h"
 274              		.file 21 "./lib/chibios/os/hal/ports/STM32/LLD/GPIOv2/hal_pal_lld.h"
 275              		.file 22 "./lib/chibios/os/hal/include/hal_dac.h"
 276              		.file 23 "./lib/chibios/os/hal/ports/STM32/LLD/DACv1/hal_dac_lld.h"
 277              		.file 24 "./lib/chibios/os/hal/include/hal_gpt.h"
 278              		.file 25 "./lib/chibios/os/hal/ports/STM32/LLD/TIMv1/hal_gpt_lld.h"
 279              		.file 26 "./lib/chibios/os/hal/include/hal_i2c.h"
 280              		.file 27 "./lib/chibios/os/hal/ports/STM32/LLD/I2Cv2/hal_i2c_lld.h"
 281              		.file 28 "./lib/chibios/os/hal/include/hal_pwm.h"
 282              		.file 29 "./lib/chibios/os/hal/ports/STM32/LLD/TIMv1/hal_pwm_lld.h"
 283              		.file 30 "./lib/chibios/os/hal/include/hal_usb.h"
 284              		.file 31 "./lib/chibios/os/hal/ports/STM32/LLD/USBv1/hal_usb_lld.h"
 285              		.file 32 "tmk_core/common/action.h"
 286              		.file 33 "tmk_core/common/report.h"
 287              		.file 34 "tmk_core/common/host.h"
 288              		.file 35 "tmk_core/common/debug.h"
 289              		.file 36 "quantum/keycode_config.h"
 290              		.file 37 "quantum/keymap.h"
 291              		.file 38 "tmk_core/common/action_layer.h"
 292              		.file 39 "tmk_core/common/timer.h"
 293              		.file 40 "tmk_core/common/action_util.h"
 294              		.file 41 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 295              		.file 42 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 296              		.file 43 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 297              		.file 44 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 298              		.file 45 "quantum/audio/luts.h"
 299              		.file 46 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/math.h"
 300              		.file 47 "quantum/process_keycode/process_music.h"
 301              		.file 48 "quantum/quantum.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 encoder.c
/var/tmp//cc25yHrK.s:16     .text.encoder_update_user:0000000000000000 $t
/var/tmp//cc25yHrK.s:23     .text.encoder_update_user:0000000000000000 encoder_update_user
/var/tmp//cc25yHrK.s:38     .text.encoder_update_kb:0000000000000000 $t
/var/tmp//cc25yHrK.s:45     .text.encoder_update_kb:0000000000000000 encoder_update_kb
/var/tmp//cc25yHrK.s:64     .text.encoder_init:0000000000000000 $t
/var/tmp//cc25yHrK.s:71     .text.encoder_init:0000000000000000 encoder_init
/var/tmp//cc25yHrK.s:112    .text.encoder_init:0000000000000034 $d
/var/tmp//cc25yHrK.s:118    .text.encoder_read:0000000000000000 $t
/var/tmp//cc25yHrK.s:125    .text.encoder_read:0000000000000000 encoder_read
/var/tmp//cc25yHrK.s:213    .text.encoder_read:0000000000000064 $d
/var/tmp//cc25yHrK.s:224    .bss.encoder_state:0000000000000000 encoder_state
/var/tmp//cc25yHrK.s:225    .bss.encoder_state:0000000000000000 $d
/var/tmp//cc25yHrK.s:230    .bss.encoder_value:0000000000000000 encoder_value
/var/tmp//cc25yHrK.s:231    .bss.encoder_value:0000000000000000 $d
/var/tmp//cc25yHrK.s:236    .rodata.encoder_LUT:0000000000000000 encoder_LUT

UNDEFINED SYMBOLS
_pal_lld_setgroupmode

   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 2
  11              		.file	"action_layer.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.default_layer_state_set_user,"ax",%progbits
  16              		.align	1
  17              		.weak	default_layer_state_set_user
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	default_layer_state_set_user:
  24              	.LFB3:
  25              		.file 1 "tmk_core/common/action_layer.c"
   1:tmk_core/common/action_layer.c **** #include <stdint.h>
   2:tmk_core/common/action_layer.c **** #include "keyboard.h"
   3:tmk_core/common/action_layer.c **** #include "action.h"
   4:tmk_core/common/action_layer.c **** #include "util.h"
   5:tmk_core/common/action_layer.c **** #include "action_layer.h"
   6:tmk_core/common/action_layer.c **** 
   7:tmk_core/common/action_layer.c **** #ifdef DEBUG_ACTION
   8:tmk_core/common/action_layer.c **** #    include "debug.h"
   9:tmk_core/common/action_layer.c **** #else
  10:tmk_core/common/action_layer.c **** #    include "nodebug.h"
  11:tmk_core/common/action_layer.c **** #endif
  12:tmk_core/common/action_layer.c **** 
  13:tmk_core/common/action_layer.c **** /** \brief Default Layer State
  14:tmk_core/common/action_layer.c ****  */
  15:tmk_core/common/action_layer.c **** layer_state_t default_layer_state = 0;
  16:tmk_core/common/action_layer.c **** 
  17:tmk_core/common/action_layer.c **** /** \brief Default Layer State Set At user Level
  18:tmk_core/common/action_layer.c ****  *
  19:tmk_core/common/action_layer.c ****  * Run user code on default layer state change
  20:tmk_core/common/action_layer.c ****  */
  21:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_user(layer_state_t state) { return stat
  26              		.loc 1 21 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  32              		.loc 1 21 0
  33 0000 7047     		bx	lr
  34              		.cfi_endproc
  35              	.LFE3:
  37              		.section	.text.default_layer_state_set_kb,"ax",%progbits
  38              		.align	1
  39              		.weak	default_layer_state_set_kb
  40              		.syntax unified
  41              		.thumb
  42              		.thumb_func
  43              		.fpu softvfp
  45              	default_layer_state_set_kb:
  46              	.LFB4:
  22:tmk_core/common/action_layer.c **** 
  23:tmk_core/common/action_layer.c **** /** \brief Default Layer State Set At Keyboard Level
  24:tmk_core/common/action_layer.c ****  *
  25:tmk_core/common/action_layer.c ****  *  Run keyboard code on default layer state change
  26:tmk_core/common/action_layer.c ****  */
  27:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_kb(layer_state_t state) { return defaul
  47              		.loc 1 27 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 0
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL1:
  52 0000 08B5     		push	{r3, lr}
  53              		.cfi_def_cfa_offset 8
  54              		.cfi_offset 3, -8
  55              		.cfi_offset 14, -4
  56              		.loc 1 27 0
  57 0002 FFF7FEFF 		bl	default_layer_state_set_user
  58              	.LVL2:
  59 0006 08BD     		pop	{r3, pc}
  60              		.cfi_endproc
  61              	.LFE4:
  63              		.section	.text.default_layer_state_set,"ax",%progbits
  64              		.align	1
  65              		.syntax unified
  66              		.thumb
  67              		.thumb_func
  68              		.fpu softvfp
  70              	default_layer_state_set:
  71              	.LFB5:
  28:tmk_core/common/action_layer.c **** 
  29:tmk_core/common/action_layer.c **** /** \brief Default Layer State Set
  30:tmk_core/common/action_layer.c ****  *
  31:tmk_core/common/action_layer.c ****  * Static function to set the default layer state, prints debug info and clears keys
  32:tmk_core/common/action_layer.c ****  */
  33:tmk_core/common/action_layer.c **** static void default_layer_state_set(layer_state_t state) {
  72              		.loc 1 33 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76              	.LVL3:
  77 0000 08B5     		push	{r3, lr}
  78              		.cfi_def_cfa_offset 8
  79              		.cfi_offset 3, -8
  80              		.cfi_offset 14, -4
  34:tmk_core/common/action_layer.c ****     state = default_layer_state_set_kb(state);
  81              		.loc 1 34 0
  82 0002 FFF7FEFF 		bl	default_layer_state_set_kb
  83              	.LVL4:
  35:tmk_core/common/action_layer.c ****     debug("default_layer_state: ");
  36:tmk_core/common/action_layer.c ****     default_layer_debug();
  37:tmk_core/common/action_layer.c ****     debug(" to ");
  38:tmk_core/common/action_layer.c ****     default_layer_state = state;
  84              		.loc 1 38 0
  85 0006 034B     		ldr	r3, .L4
  86 0008 1860     		str	r0, [r3]
  39:tmk_core/common/action_layer.c ****     default_layer_debug();
  40:tmk_core/common/action_layer.c ****     debug("\n");
  41:tmk_core/common/action_layer.c **** #ifdef STRICT_LAYER_RELEASE
  42:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
  43:tmk_core/common/action_layer.c **** #else
  44:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
  45:tmk_core/common/action_layer.c **** #endif
  46:tmk_core/common/action_layer.c **** }
  87              		.loc 1 46 0
  88 000a BDE80840 		pop	{r3, lr}
  89              		.cfi_restore 14
  90              		.cfi_restore 3
  91              		.cfi_def_cfa_offset 0
  44:tmk_core/common/action_layer.c **** #endif
  92              		.loc 1 44 0
  93 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
  94              	.LVL5:
  95              	.L5:
  96 0012 00BF     		.align	2
  97              	.L4:
  98 0014 00000000 		.word	.LANCHOR0
  99              		.cfi_endproc
 100              	.LFE5:
 102              		.section	.text.default_layer_debug,"ax",%progbits
 103              		.align	1
 104              		.global	default_layer_debug
 105              		.syntax unified
 106              		.thumb
 107              		.thumb_func
 108              		.fpu softvfp
 110              	default_layer_debug:
 111              	.LFB6:
  47:tmk_core/common/action_layer.c **** 
  48:tmk_core/common/action_layer.c **** /** \brief Default Layer Print
  49:tmk_core/common/action_layer.c ****  *
  50:tmk_core/common/action_layer.c ****  * Print out the hex value of the 32-bit default layer state, as well as the value of the highest b
  51:tmk_core/common/action_layer.c ****  */
  52:tmk_core/common/action_layer.c **** void default_layer_debug(void) { dprintf("%08lX(%u)", default_layer_state, biton32(default_layer_st
 112              		.loc 1 52 0
 113              		.cfi_startproc
 114              		@ args = 0, pretend = 0, frame = 0
 115              		@ frame_needed = 0, uses_anonymous_args = 0
 116              		@ link register save eliminated.
 117              		.loc 1 52 0
 118 0000 7047     		bx	lr
 119              		.cfi_endproc
 120              	.LFE6:
 122              		.section	.text.default_layer_set,"ax",%progbits
 123              		.align	1
 124              		.global	default_layer_set
 125              		.syntax unified
 126              		.thumb
 127              		.thumb_func
 128              		.fpu softvfp
 130              	default_layer_set:
 131              	.LFB7:
  53:tmk_core/common/action_layer.c **** 
  54:tmk_core/common/action_layer.c **** /** \brief Default Layer Set
  55:tmk_core/common/action_layer.c ****  *
  56:tmk_core/common/action_layer.c ****  * Sets the default layer state.
  57:tmk_core/common/action_layer.c ****  */
  58:tmk_core/common/action_layer.c **** void default_layer_set(layer_state_t state) { default_layer_state_set(state); }
 132              		.loc 1 58 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              		@ link register save eliminated.
 137              	.LVL6:
 138              		.loc 1 58 0
 139 0000 FFF7FEBF 		b	default_layer_state_set
 140              	.LVL7:
 141              		.cfi_endproc
 142              	.LFE7:
 144              		.section	.text.default_layer_or,"ax",%progbits
 145              		.align	1
 146              		.global	default_layer_or
 147              		.syntax unified
 148              		.thumb
 149              		.thumb_func
 150              		.fpu softvfp
 152              	default_layer_or:
 153              	.LFB8:
  59:tmk_core/common/action_layer.c **** 
  60:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
  61:tmk_core/common/action_layer.c **** /** \brief Default Layer Or
  62:tmk_core/common/action_layer.c ****  *
  63:tmk_core/common/action_layer.c ****  * Turns on the default layer based on matching bits between specifed layer and existing layer stat
  64:tmk_core/common/action_layer.c ****  */
  65:tmk_core/common/action_layer.c **** void default_layer_or(layer_state_t state) { default_layer_state_set(default_layer_state | state); 
 154              		.loc 1 65 0
 155              		.cfi_startproc
 156              		@ args = 0, pretend = 0, frame = 0
 157              		@ frame_needed = 0, uses_anonymous_args = 0
 158              		@ link register save eliminated.
 159              	.LVL8:
 160              		.loc 1 65 0
 161 0000 024B     		ldr	r3, .L9
 162 0002 1B68     		ldr	r3, [r3]
 163 0004 1843     		orrs	r0, r0, r3
 164              	.LVL9:
 165 0006 FFF7FEBF 		b	default_layer_state_set
 166              	.LVL10:
 167              	.L10:
 168 000a 00BF     		.align	2
 169              	.L9:
 170 000c 00000000 		.word	.LANCHOR0
 171              		.cfi_endproc
 172              	.LFE8:
 174              		.section	.text.default_layer_and,"ax",%progbits
 175              		.align	1
 176              		.global	default_layer_and
 177              		.syntax unified
 178              		.thumb
 179              		.thumb_func
 180              		.fpu softvfp
 182              	default_layer_and:
 183              	.LFB9:
  66:tmk_core/common/action_layer.c **** /** \brief Default Layer And
  67:tmk_core/common/action_layer.c ****  *
  68:tmk_core/common/action_layer.c ****  * Turns on default layer based on matching enabled bits between specifed layer and existing layer 
  69:tmk_core/common/action_layer.c ****  */
  70:tmk_core/common/action_layer.c **** void default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state);
 184              		.loc 1 70 0
 185              		.cfi_startproc
 186              		@ args = 0, pretend = 0, frame = 0
 187              		@ frame_needed = 0, uses_anonymous_args = 0
 188              		@ link register save eliminated.
 189              	.LVL11:
 190              		.loc 1 70 0
 191 0000 024B     		ldr	r3, .L12
 192 0002 1B68     		ldr	r3, [r3]
 193 0004 1840     		ands	r0, r0, r3
 194              	.LVL12:
 195 0006 FFF7FEBF 		b	default_layer_state_set
 196              	.LVL13:
 197              	.L13:
 198 000a 00BF     		.align	2
 199              	.L12:
 200 000c 00000000 		.word	.LANCHOR0
 201              		.cfi_endproc
 202              	.LFE9:
 204              		.section	.text.default_layer_xor,"ax",%progbits
 205              		.align	1
 206              		.global	default_layer_xor
 207              		.syntax unified
 208              		.thumb
 209              		.thumb_func
 210              		.fpu softvfp
 212              	default_layer_xor:
 213              	.LFB10:
  71:tmk_core/common/action_layer.c **** /** \brief Default Layer Xor
  72:tmk_core/common/action_layer.c ****  *
  73:tmk_core/common/action_layer.c ****  * Turns on default layer based on non-matching bits between specifed layer and existing layer stat
  74:tmk_core/common/action_layer.c ****  */
  75:tmk_core/common/action_layer.c **** void default_layer_xor(layer_state_t state) { default_layer_state_set(default_layer_state ^ state);
 214              		.loc 1 75 0
 215              		.cfi_startproc
 216              		@ args = 0, pretend = 0, frame = 0
 217              		@ frame_needed = 0, uses_anonymous_args = 0
 218              		@ link register save eliminated.
 219              	.LVL14:
 220              		.loc 1 75 0
 221 0000 024B     		ldr	r3, .L15
 222 0002 1B68     		ldr	r3, [r3]
 223 0004 5840     		eors	r0, r0, r3
 224              	.LVL15:
 225 0006 FFF7FEBF 		b	default_layer_state_set
 226              	.LVL16:
 227              	.L16:
 228 000a 00BF     		.align	2
 229              	.L15:
 230 000c 00000000 		.word	.LANCHOR0
 231              		.cfi_endproc
 232              	.LFE10:
 234              		.section	.text.layer_state_set_user,"ax",%progbits
 235              		.align	1
 236              		.weak	layer_state_set_user
 237              		.syntax unified
 238              		.thumb
 239              		.thumb_func
 240              		.fpu softvfp
 242              	layer_state_set_user:
 243              	.LFB33:
 244              		.cfi_startproc
 245              		@ args = 0, pretend = 0, frame = 0
 246              		@ frame_needed = 0, uses_anonymous_args = 0
 247              		@ link register save eliminated.
 248 0000 7047     		bx	lr
 249              		.cfi_endproc
 250              	.LFE33:
 252              		.section	.text.layer_state_set_kb,"ax",%progbits
 253              		.align	1
 254              		.weak	layer_state_set_kb
 255              		.syntax unified
 256              		.thumb
 257              		.thumb_func
 258              		.fpu softvfp
 260              	layer_state_set_kb:
 261              	.LFB12:
  76:tmk_core/common/action_layer.c **** #endif
  77:tmk_core/common/action_layer.c **** 
  78:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
  79:tmk_core/common/action_layer.c **** /** \brief Keymap Layer State
  80:tmk_core/common/action_layer.c ****  */
  81:tmk_core/common/action_layer.c **** layer_state_t layer_state = 0;
  82:tmk_core/common/action_layer.c **** 
  83:tmk_core/common/action_layer.c **** /** \brief Layer state set user
  84:tmk_core/common/action_layer.c ****  *
  85:tmk_core/common/action_layer.c ****  * Runs user code on layer state change
  86:tmk_core/common/action_layer.c ****  */
  87:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_user(layer_state_t state) { return state; }
  88:tmk_core/common/action_layer.c **** 
  89:tmk_core/common/action_layer.c **** /** \brief Layer state set keyboard
  90:tmk_core/common/action_layer.c ****  *
  91:tmk_core/common/action_layer.c ****  * Runs keyboard code on layer state change
  92:tmk_core/common/action_layer.c ****  */
  93:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_kb(layer_state_t state) { return layer_state_se
 262              		.loc 1 93 0
 263              		.cfi_startproc
 264              		@ args = 0, pretend = 0, frame = 0
 265              		@ frame_needed = 0, uses_anonymous_args = 0
 266              	.LVL17:
 267              		.loc 1 93 0
 268 0000 08B5     		push	{r3, lr}
 269              		.cfi_def_cfa_offset 8
 270              		.cfi_offset 3, -8
 271              		.cfi_offset 14, -4
 272              		.loc 1 93 0
 273 0002 FFF7FEFF 		bl	layer_state_set_user
 274              	.LVL18:
 275 0006 08BD     		pop	{r3, pc}
 276              		.cfi_endproc
 277              	.LFE12:
 279              		.section	.text.layer_state_set,"ax",%progbits
 280              		.align	1
 281              		.global	layer_state_set
 282              		.syntax unified
 283              		.thumb
 284              		.thumb_func
 285              		.fpu softvfp
 287              	layer_state_set:
 288              	.LFB13:
  94:tmk_core/common/action_layer.c **** 
  95:tmk_core/common/action_layer.c **** /** \brief Layer state set
  96:tmk_core/common/action_layer.c ****  *
  97:tmk_core/common/action_layer.c ****  * Sets the layer to match the specifed state (a bitmask)
  98:tmk_core/common/action_layer.c ****  */
  99:tmk_core/common/action_layer.c **** void layer_state_set(layer_state_t state) {
 289              		.loc 1 99 0
 290              		.cfi_startproc
 291              		@ args = 0, pretend = 0, frame = 0
 292              		@ frame_needed = 0, uses_anonymous_args = 0
 293              	.LVL19:
 294 0000 08B5     		push	{r3, lr}
 295              		.cfi_def_cfa_offset 8
 296              		.cfi_offset 3, -8
 297              		.cfi_offset 14, -4
 100:tmk_core/common/action_layer.c ****     state = layer_state_set_kb(state);
 298              		.loc 1 100 0
 299 0002 FFF7FEFF 		bl	layer_state_set_kb
 300              	.LVL20:
 101:tmk_core/common/action_layer.c ****     dprint("layer_state: ");
 102:tmk_core/common/action_layer.c ****     layer_debug();
 103:tmk_core/common/action_layer.c ****     dprint(" to ");
 104:tmk_core/common/action_layer.c ****     layer_state = state;
 301              		.loc 1 104 0
 302 0006 034B     		ldr	r3, .L20
 303 0008 1860     		str	r0, [r3]
 105:tmk_core/common/action_layer.c ****     layer_debug();
 106:tmk_core/common/action_layer.c ****     dprintln();
 107:tmk_core/common/action_layer.c **** #    ifdef STRICT_LAYER_RELEASE
 108:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
 109:tmk_core/common/action_layer.c **** #    else
 110:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
 111:tmk_core/common/action_layer.c **** #    endif
 112:tmk_core/common/action_layer.c **** }
 304              		.loc 1 112 0
 305 000a BDE80840 		pop	{r3, lr}
 306              		.cfi_restore 14
 307              		.cfi_restore 3
 308              		.cfi_def_cfa_offset 0
 110:tmk_core/common/action_layer.c **** #    endif
 309              		.loc 1 110 0
 310 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 311              	.LVL21:
 312              	.L21:
 313 0012 00BF     		.align	2
 314              	.L20:
 315 0014 00000000 		.word	.LANCHOR1
 316              		.cfi_endproc
 317              	.LFE13:
 319              		.section	.text.layer_clear,"ax",%progbits
 320              		.align	1
 321              		.global	layer_clear
 322              		.syntax unified
 323              		.thumb
 324              		.thumb_func
 325              		.fpu softvfp
 327              	layer_clear:
 328              	.LFB14:
 113:tmk_core/common/action_layer.c **** 
 114:tmk_core/common/action_layer.c **** /** \brief Layer clear
 115:tmk_core/common/action_layer.c ****  *
 116:tmk_core/common/action_layer.c ****  * Turn off all layers
 117:tmk_core/common/action_layer.c ****  */
 118:tmk_core/common/action_layer.c **** void layer_clear(void) { layer_state_set(0); }
 329              		.loc 1 118 0
 330              		.cfi_startproc
 331              		@ args = 0, pretend = 0, frame = 0
 332              		@ frame_needed = 0, uses_anonymous_args = 0
 333              		@ link register save eliminated.
 334              		.loc 1 118 0
 335 0000 0020     		movs	r0, #0
 336 0002 FFF7FEBF 		b	layer_state_set
 337              	.LVL22:
 338              		.cfi_endproc
 339              	.LFE14:
 341              		.section	.text.layer_state_cmp,"ax",%progbits
 342              		.align	1
 343              		.global	layer_state_cmp
 344              		.syntax unified
 345              		.thumb
 346              		.thumb_func
 347              		.fpu softvfp
 349              	layer_state_cmp:
 350              	.LFB16:
 119:tmk_core/common/action_layer.c **** 
 120:tmk_core/common/action_layer.c **** /** \brief Layer state is
 121:tmk_core/common/action_layer.c ****  *
 122:tmk_core/common/action_layer.c ****  * Return whether the given state is on (it might still be shadowed by a higher state, though)
 123:tmk_core/common/action_layer.c ****  */
 124:tmk_core/common/action_layer.c **** bool layer_state_is(uint8_t layer) { return layer_state_cmp(layer_state, layer); }
 125:tmk_core/common/action_layer.c **** 
 126:tmk_core/common/action_layer.c **** /** \brief Layer state compare
 127:tmk_core/common/action_layer.c ****  *
 128:tmk_core/common/action_layer.c ****  * Used for comparing layers {mostly used for unit testing}
 129:tmk_core/common/action_layer.c ****  */
 130:tmk_core/common/action_layer.c **** bool layer_state_cmp(layer_state_t cmp_layer_state, uint8_t layer) {
 351              		.loc 1 130 0
 352              		.cfi_startproc
 353              		@ args = 0, pretend = 0, frame = 0
 354              		@ frame_needed = 0, uses_anonymous_args = 0
 355              		@ link register save eliminated.
 356              	.LVL23:
 131:tmk_core/common/action_layer.c ****     if (!cmp_layer_state) {
 357              		.loc 1 131 0
 358 0000 18B9     		cbnz	r0, .L24
 132:tmk_core/common/action_layer.c ****         return layer == 0;
 359              		.loc 1 132 0
 360 0002 B1FA81F0 		clz	r0, r1
 361              	.LVL24:
 362 0006 4009     		lsrs	r0, r0, #5
 363 0008 7047     		bx	lr
 364              	.LVL25:
 365              	.L24:
 133:tmk_core/common/action_layer.c ****     }
 134:tmk_core/common/action_layer.c ****     return (cmp_layer_state & (1UL << layer)) != 0;
 366              		.loc 1 134 0
 367 000a C840     		lsrs	r0, r0, r1
 368              	.LVL26:
 369 000c 00F00100 		and	r0, r0, #1
 135:tmk_core/common/action_layer.c **** }
 370              		.loc 1 135 0
 371 0010 7047     		bx	lr
 372              		.cfi_endproc
 373              	.LFE16:
 375              		.section	.text.layer_state_is,"ax",%progbits
 376              		.align	1
 377              		.global	layer_state_is
 378              		.syntax unified
 379              		.thumb
 380              		.thumb_func
 381              		.fpu softvfp
 383              	layer_state_is:
 384              	.LFB15:
 124:tmk_core/common/action_layer.c **** 
 385              		.loc 1 124 0
 386              		.cfi_startproc
 387              		@ args = 0, pretend = 0, frame = 0
 388              		@ frame_needed = 0, uses_anonymous_args = 0
 389              		@ link register save eliminated.
 390              	.LVL27:
 124:tmk_core/common/action_layer.c **** 
 391              		.loc 1 124 0
 392 0000 024B     		ldr	r3, .L27
 393 0002 0146     		mov	r1, r0
 394 0004 1868     		ldr	r0, [r3]
 395              	.LVL28:
 396 0006 FFF7FEBF 		b	layer_state_cmp
 397              	.LVL29:
 398              	.L28:
 399 000a 00BF     		.align	2
 400              	.L27:
 401 000c 00000000 		.word	.LANCHOR1
 402              		.cfi_endproc
 403              	.LFE15:
 405              		.section	.text.layer_move,"ax",%progbits
 406              		.align	1
 407              		.global	layer_move
 408              		.syntax unified
 409              		.thumb
 410              		.thumb_func
 411              		.fpu softvfp
 413              	layer_move:
 414              	.LFB17:
 136:tmk_core/common/action_layer.c **** 
 137:tmk_core/common/action_layer.c **** /** \brief Layer move
 138:tmk_core/common/action_layer.c ****  *
 139:tmk_core/common/action_layer.c ****  * Turns on the given layer and turn off all other layers
 140:tmk_core/common/action_layer.c ****  */
 141:tmk_core/common/action_layer.c **** void layer_move(uint8_t layer) { layer_state_set(1UL << layer); }
 415              		.loc 1 141 0
 416              		.cfi_startproc
 417              		@ args = 0, pretend = 0, frame = 0
 418              		@ frame_needed = 0, uses_anonymous_args = 0
 419              		@ link register save eliminated.
 420              	.LVL30:
 421              		.loc 1 141 0
 422 0000 0123     		movs	r3, #1
 423 0002 03FA00F0 		lsl	r0, r3, r0
 424              	.LVL31:
 425 0006 FFF7FEBF 		b	layer_state_set
 426              	.LVL32:
 427              		.cfi_endproc
 428              	.LFE17:
 430              		.section	.text.layer_on,"ax",%progbits
 431              		.align	1
 432              		.global	layer_on
 433              		.syntax unified
 434              		.thumb
 435              		.thumb_func
 436              		.fpu softvfp
 438              	layer_on:
 439              	.LFB18:
 142:tmk_core/common/action_layer.c **** 
 143:tmk_core/common/action_layer.c **** /** \brief Layer on
 144:tmk_core/common/action_layer.c ****  *
 145:tmk_core/common/action_layer.c ****  * Turns on given layer
 146:tmk_core/common/action_layer.c ****  */
 147:tmk_core/common/action_layer.c **** void layer_on(uint8_t layer) { layer_state_set(layer_state | (1UL << layer)); }
 440              		.loc 1 147 0
 441              		.cfi_startproc
 442              		@ args = 0, pretend = 0, frame = 0
 443              		@ frame_needed = 0, uses_anonymous_args = 0
 444              		@ link register save eliminated.
 445              	.LVL33:
 446              		.loc 1 147 0
 447 0000 0123     		movs	r3, #1
 448 0002 03FA00F0 		lsl	r0, r3, r0
 449              	.LVL34:
 450 0006 024B     		ldr	r3, .L31
 451 0008 1B68     		ldr	r3, [r3]
 452 000a 1843     		orrs	r0, r0, r3
 453 000c FFF7FEBF 		b	layer_state_set
 454              	.LVL35:
 455              	.L32:
 456              		.align	2
 457              	.L31:
 458 0010 00000000 		.word	.LANCHOR1
 459              		.cfi_endproc
 460              	.LFE18:
 462              		.section	.text.layer_off,"ax",%progbits
 463              		.align	1
 464              		.global	layer_off
 465              		.syntax unified
 466              		.thumb
 467              		.thumb_func
 468              		.fpu softvfp
 470              	layer_off:
 471              	.LFB19:
 148:tmk_core/common/action_layer.c **** 
 149:tmk_core/common/action_layer.c **** /** \brief Layer off
 150:tmk_core/common/action_layer.c ****  *
 151:tmk_core/common/action_layer.c ****  * Turns off given layer
 152:tmk_core/common/action_layer.c ****  */
 153:tmk_core/common/action_layer.c **** void layer_off(uint8_t layer) { layer_state_set(layer_state & ~(1UL << layer)); }
 472              		.loc 1 153 0
 473              		.cfi_startproc
 474              		@ args = 0, pretend = 0, frame = 0
 475              		@ frame_needed = 0, uses_anonymous_args = 0
 476              		@ link register save eliminated.
 477              	.LVL36:
 478              		.loc 1 153 0
 479 0000 0123     		movs	r3, #1
 480 0002 03FA00F0 		lsl	r0, r3, r0
 481              	.LVL37:
 482 0006 034B     		ldr	r3, .L34
 483 0008 1B68     		ldr	r3, [r3]
 484 000a 23EA0000 		bic	r0, r3, r0
 485 000e FFF7FEBF 		b	layer_state_set
 486              	.LVL38:
 487              	.L35:
 488 0012 00BF     		.align	2
 489              	.L34:
 490 0014 00000000 		.word	.LANCHOR1
 491              		.cfi_endproc
 492              	.LFE19:
 494              		.section	.text.layer_invert,"ax",%progbits
 495              		.align	1
 496              		.global	layer_invert
 497              		.syntax unified
 498              		.thumb
 499              		.thumb_func
 500              		.fpu softvfp
 502              	layer_invert:
 503              	.LFB20:
 154:tmk_core/common/action_layer.c **** 
 155:tmk_core/common/action_layer.c **** /** \brief Layer invert
 156:tmk_core/common/action_layer.c ****  *
 157:tmk_core/common/action_layer.c ****  * Toggle the given layer (set it if it's unset, or unset it if it's set)
 158:tmk_core/common/action_layer.c ****  */
 159:tmk_core/common/action_layer.c **** void layer_invert(uint8_t layer) { layer_state_set(layer_state ^ (1UL << layer)); }
 504              		.loc 1 159 0
 505              		.cfi_startproc
 506              		@ args = 0, pretend = 0, frame = 0
 507              		@ frame_needed = 0, uses_anonymous_args = 0
 508              		@ link register save eliminated.
 509              	.LVL39:
 510              		.loc 1 159 0
 511 0000 0123     		movs	r3, #1
 512 0002 03FA00F0 		lsl	r0, r3, r0
 513              	.LVL40:
 514 0006 024B     		ldr	r3, .L37
 515 0008 1B68     		ldr	r3, [r3]
 516 000a 5840     		eors	r0, r0, r3
 517 000c FFF7FEBF 		b	layer_state_set
 518              	.LVL41:
 519              	.L38:
 520              		.align	2
 521              	.L37:
 522 0010 00000000 		.word	.LANCHOR1
 523              		.cfi_endproc
 524              	.LFE20:
 526              		.section	.text.layer_or,"ax",%progbits
 527              		.align	1
 528              		.global	layer_or
 529              		.syntax unified
 530              		.thumb
 531              		.thumb_func
 532              		.fpu softvfp
 534              	layer_or:
 535              	.LFB21:
 160:tmk_core/common/action_layer.c **** 
 161:tmk_core/common/action_layer.c **** /** \brief Layer or
 162:tmk_core/common/action_layer.c ****  *
 163:tmk_core/common/action_layer.c ****  * Turns on layers based on matching bits between specifed layer and existing layer state
 164:tmk_core/common/action_layer.c ****  */
 165:tmk_core/common/action_layer.c **** void layer_or(layer_state_t state) { layer_state_set(layer_state | state); }
 536              		.loc 1 165 0
 537              		.cfi_startproc
 538              		@ args = 0, pretend = 0, frame = 0
 539              		@ frame_needed = 0, uses_anonymous_args = 0
 540              		@ link register save eliminated.
 541              	.LVL42:
 542              		.loc 1 165 0
 543 0000 024B     		ldr	r3, .L40
 544 0002 1B68     		ldr	r3, [r3]
 545 0004 1843     		orrs	r0, r0, r3
 546              	.LVL43:
 547 0006 FFF7FEBF 		b	layer_state_set
 548              	.LVL44:
 549              	.L41:
 550 000a 00BF     		.align	2
 551              	.L40:
 552 000c 00000000 		.word	.LANCHOR1
 553              		.cfi_endproc
 554              	.LFE21:
 556              		.section	.text.layer_and,"ax",%progbits
 557              		.align	1
 558              		.global	layer_and
 559              		.syntax unified
 560              		.thumb
 561              		.thumb_func
 562              		.fpu softvfp
 564              	layer_and:
 565              	.LFB22:
 166:tmk_core/common/action_layer.c **** /** \brief Layer and
 167:tmk_core/common/action_layer.c ****  *
 168:tmk_core/common/action_layer.c ****  * Turns on layers based on matching enabled bits between specifed layer and existing layer state
 169:tmk_core/common/action_layer.c ****  */
 170:tmk_core/common/action_layer.c **** void layer_and(layer_state_t state) { layer_state_set(layer_state & state); }
 566              		.loc 1 170 0
 567              		.cfi_startproc
 568              		@ args = 0, pretend = 0, frame = 0
 569              		@ frame_needed = 0, uses_anonymous_args = 0
 570              		@ link register save eliminated.
 571              	.LVL45:
 572              		.loc 1 170 0
 573 0000 024B     		ldr	r3, .L43
 574 0002 1B68     		ldr	r3, [r3]
 575 0004 1840     		ands	r0, r0, r3
 576              	.LVL46:
 577 0006 FFF7FEBF 		b	layer_state_set
 578              	.LVL47:
 579              	.L44:
 580 000a 00BF     		.align	2
 581              	.L43:
 582 000c 00000000 		.word	.LANCHOR1
 583              		.cfi_endproc
 584              	.LFE22:
 586              		.section	.text.layer_xor,"ax",%progbits
 587              		.align	1
 588              		.global	layer_xor
 589              		.syntax unified
 590              		.thumb
 591              		.thumb_func
 592              		.fpu softvfp
 594              	layer_xor:
 595              	.LFB23:
 171:tmk_core/common/action_layer.c **** /** \brief Layer xor
 172:tmk_core/common/action_layer.c ****  *
 173:tmk_core/common/action_layer.c ****  * Turns on layers based on non-matching bits between specifed layer and existing layer state
 174:tmk_core/common/action_layer.c ****  */
 175:tmk_core/common/action_layer.c **** void layer_xor(layer_state_t state) { layer_state_set(layer_state ^ state); }
 596              		.loc 1 175 0
 597              		.cfi_startproc
 598              		@ args = 0, pretend = 0, frame = 0
 599              		@ frame_needed = 0, uses_anonymous_args = 0
 600              		@ link register save eliminated.
 601              	.LVL48:
 602              		.loc 1 175 0
 603 0000 024B     		ldr	r3, .L46
 604 0002 1B68     		ldr	r3, [r3]
 605 0004 5840     		eors	r0, r0, r3
 606              	.LVL49:
 607 0006 FFF7FEBF 		b	layer_state_set
 608              	.LVL50:
 609              	.L47:
 610 000a 00BF     		.align	2
 611              	.L46:
 612 000c 00000000 		.word	.LANCHOR1
 613              		.cfi_endproc
 614              	.LFE23:
 616              		.section	.text.layer_debug,"ax",%progbits
 617              		.align	1
 618              		.global	layer_debug
 619              		.syntax unified
 620              		.thumb
 621              		.thumb_func
 622              		.fpu softvfp
 624              	layer_debug:
 625              	.LFB31:
 626              		.cfi_startproc
 627              		@ args = 0, pretend = 0, frame = 0
 628              		@ frame_needed = 0, uses_anonymous_args = 0
 629              		@ link register save eliminated.
 630 0000 7047     		bx	lr
 631              		.cfi_endproc
 632              	.LFE31:
 634              		.section	.text.update_source_layers_cache,"ax",%progbits
 635              		.align	1
 636              		.global	update_source_layers_cache
 637              		.syntax unified
 638              		.thumb
 639              		.thumb_func
 640              		.fpu softvfp
 642              	update_source_layers_cache:
 643              	.LFB25:
 176:tmk_core/common/action_layer.c **** 
 177:tmk_core/common/action_layer.c **** /** \brief Layer debug printing
 178:tmk_core/common/action_layer.c ****  *
 179:tmk_core/common/action_layer.c ****  * Print out the hex value of the 32-bit layer state, as well as the value of the highest bit.
 180:tmk_core/common/action_layer.c ****  */
 181:tmk_core/common/action_layer.c **** void layer_debug(void) { dprintf("%08lX(%u)", layer_state, biton32(layer_state)); }
 182:tmk_core/common/action_layer.c **** #endif
 183:tmk_core/common/action_layer.c **** 
 184:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 185:tmk_core/common/action_layer.c **** /** \brief source layer cache
 186:tmk_core/common/action_layer.c ****  */
 187:tmk_core/common/action_layer.c **** 
 188:tmk_core/common/action_layer.c **** uint8_t source_layers_cache[(MATRIX_ROWS * MATRIX_COLS + 7) / 8][MAX_LAYER_BITS] = {{0}};
 189:tmk_core/common/action_layer.c **** 
 190:tmk_core/common/action_layer.c **** /** \brief update source layers cache
 191:tmk_core/common/action_layer.c ****  *
 192:tmk_core/common/action_layer.c ****  * Updates the cached keys when changing layers
 193:tmk_core/common/action_layer.c ****  */
 194:tmk_core/common/action_layer.c **** void update_source_layers_cache(keypos_t key, uint8_t layer) {
 644              		.loc 1 194 0
 645              		.cfi_startproc
 646              		@ args = 0, pretend = 0, frame = 8
 647              		@ frame_needed = 0, uses_anonymous_args = 0
 648              	.LVL51:
 195:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 649              		.loc 1 195 0
 650 0000 C0F30723 		ubfx	r3, r0, #8, #8
 651 0004 03EB4303 		add	r3, r3, r3, lsl #1
 652 0008 00EB4303 		add	r3, r0, r3, lsl #1
 653 000c 03F0FF03 		and	r3, r3, #255
 654              	.LVL52:
 194:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 655              		.loc 1 194 0
 656 0010 37B5     		push	{r0, r1, r2, r4, r5, lr}
 657              		.cfi_def_cfa_offset 24
 658              		.cfi_offset 4, -12
 659              		.cfi_offset 5, -8
 660              		.cfi_offset 14, -4
 661              	.LBB10:
 196:tmk_core/common/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 197:tmk_core/common/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 198:tmk_core/common/action_layer.c **** 
 199:tmk_core/common/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 200:tmk_core/common/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 662              		.loc 1 200 0
 663 0012 03F00702 		and	r2, r3, #7
 664 0016 0120     		movs	r0, #1
 665 0018 9040     		lsls	r0, r0, r2
 666 001a DB08     		lsrs	r3, r3, #3
 667              	.LVL53:
 668 001c 0A4A     		ldr	r2, .L52
 669 001e 03EB8303 		add	r3, r3, r3, lsl #2
 670 0022 C0B2     		uxtb	r0, r0
 671 0024 1344     		add	r3, r3, r2
 672 0026 0024     		movs	r4, #0
 673              	.LVL54:
 674              	.L50:
 675              		.loc 1 200 0 is_stmt 0 discriminator 3
 676 0028 13F8015F 		ldrb	r5, [r3, #1]!	@ zero_extendqisi2
 677 002c 21FA04F2 		lsr	r2, r1, r4
 678 0030 42F30002 		sbfx	r2, r2, #0, #1
 679 0034 6A40     		eors	r2, r2, r5
 680 0036 0240     		ands	r2, r2, r0
 681 0038 0134     		adds	r4, r4, #1
 682              	.LVL55:
 683 003a 6A40     		eors	r2, r2, r5
 199:tmk_core/common/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 684              		.loc 1 199 0 is_stmt 1 discriminator 3
 685 003c 052C     		cmp	r4, #5
 686              		.loc 1 200 0 discriminator 3
 687 003e 1A70     		strb	r2, [r3]
 199:tmk_core/common/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 688              		.loc 1 199 0 discriminator 3
 689 0040 F2D1     		bne	.L50
 690              	.LBE10:
 201:tmk_core/common/action_layer.c ****     }
 202:tmk_core/common/action_layer.c **** }
 691              		.loc 1 202 0
 692 0042 03B0     		add	sp, sp, #12
 693              		.cfi_def_cfa_offset 12
 694              		@ sp needed
 695 0044 30BD     		pop	{r4, r5, pc}
 696              	.L53:
 697 0046 00BF     		.align	2
 698              	.L52:
 699 0048 FFFFFFFF 		.word	.LANCHOR2-1
 700              		.cfi_endproc
 701              	.LFE25:
 703              		.section	.text.read_source_layers_cache,"ax",%progbits
 704              		.align	1
 705              		.global	read_source_layers_cache
 706              		.syntax unified
 707              		.thumb
 708              		.thumb_func
 709              		.fpu softvfp
 711              	read_source_layers_cache:
 712              	.LFB26:
 203:tmk_core/common/action_layer.c **** 
 204:tmk_core/common/action_layer.c **** /** \brief read source layers cache
 205:tmk_core/common/action_layer.c ****  *
 206:tmk_core/common/action_layer.c ****  * reads the cached keys stored when the layer was changed
 207:tmk_core/common/action_layer.c ****  */
 208:tmk_core/common/action_layer.c **** uint8_t read_source_layers_cache(keypos_t key) {
 713              		.loc 1 208 0
 714              		.cfi_startproc
 715              		@ args = 0, pretend = 0, frame = 8
 716              		@ frame_needed = 0, uses_anonymous_args = 0
 209:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 717              		.loc 1 209 0
 718 0000 C0F30723 		ubfx	r3, r0, #8, #8
 719 0004 03EB4303 		add	r3, r3, r3, lsl #1
 208:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 720              		.loc 1 208 0
 721 0008 13B5     		push	{r0, r1, r4, lr}
 722              		.cfi_def_cfa_offset 16
 723              		.cfi_offset 4, -8
 724              		.cfi_offset 14, -4
 725              		.loc 1 209 0
 726 000a 00EB4300 		add	r0, r0, r3, lsl #1
 727 000e 00F0FF00 		and	r0, r0, #255
 728              	.LVL56:
 210:tmk_core/common/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 211:tmk_core/common/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 729              		.loc 1 211 0
 730 0012 00F00704 		and	r4, r0, #7
 731              	.LVL57:
 732 0016 0949     		ldr	r1, .L57
 733 0018 C008     		lsrs	r0, r0, #3
 734              	.LVL58:
 735 001a 00EB8000 		add	r0, r0, r0, lsl #2
 736 001e 0022     		movs	r2, #0
 737 0020 0144     		add	r1, r1, r0
 212:tmk_core/common/action_layer.c ****     uint8_t       layer       = 0;
 738              		.loc 1 212 0
 739 0022 1046     		mov	r0, r2
 740              	.LVL59:
 741              	.L55:
 742              	.LBB11:
 213:tmk_core/common/action_layer.c **** 
 214:tmk_core/common/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 215:tmk_core/common/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 743              		.loc 1 215 0 discriminator 3
 744 0024 8B5C     		ldrb	r3, [r1, r2]	@ zero_extendqisi2
 745 0026 E340     		lsrs	r3, r3, r4
 746 0028 03F00103 		and	r3, r3, #1
 747 002c 9340     		lsls	r3, r3, r2
 748 002e 0132     		adds	r2, r2, #1
 749              	.LVL60:
 750 0030 1843     		orrs	r0, r0, r3
 751              	.LVL61:
 214:tmk_core/common/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 752              		.loc 1 214 0 discriminator 3
 753 0032 052A     		cmp	r2, #5
 754              		.loc 1 215 0 discriminator 3
 755 0034 C0B2     		uxtb	r0, r0
 756              	.LVL62:
 214:tmk_core/common/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 757              		.loc 1 214 0 discriminator 3
 758 0036 F5D1     		bne	.L55
 759              	.LBE11:
 216:tmk_core/common/action_layer.c ****     }
 217:tmk_core/common/action_layer.c **** 
 218:tmk_core/common/action_layer.c ****     return layer;
 219:tmk_core/common/action_layer.c **** }
 760              		.loc 1 219 0
 761 0038 02B0     		add	sp, sp, #8
 762              		.cfi_def_cfa_offset 8
 763              		@ sp needed
 764 003a 10BD     		pop	{r4, pc}
 765              	.LVL63:
 766              	.L58:
 767              		.align	2
 768              	.L57:
 769 003c 00000000 		.word	.LANCHOR2
 770              		.cfi_endproc
 771              	.LFE26:
 773              		.section	.text.layer_switch_get_layer,"ax",%progbits
 774              		.align	1
 775              		.global	layer_switch_get_layer
 776              		.syntax unified
 777              		.thumb
 778              		.thumb_func
 779              		.fpu softvfp
 781              	layer_switch_get_layer:
 782              	.LFB28:
 220:tmk_core/common/action_layer.c **** #endif
 221:tmk_core/common/action_layer.c **** 
 222:tmk_core/common/action_layer.c **** /** \brief Store or get action (FIXME: Needs better summary)
 223:tmk_core/common/action_layer.c ****  *
 224:tmk_core/common/action_layer.c ****  * Make sure the action triggered when the key is released is the same
 225:tmk_core/common/action_layer.c ****  * one as the one triggered on press. It's important for the mod keys
 226:tmk_core/common/action_layer.c ****  * when the layer is switched after the down event but before the up
 227:tmk_core/common/action_layer.c ****  * event as they may get stuck otherwise.
 228:tmk_core/common/action_layer.c ****  */
 229:tmk_core/common/action_layer.c **** action_t store_or_get_action(bool pressed, keypos_t key) {
 230:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 231:tmk_core/common/action_layer.c ****     if (disable_action_cache) {
 232:tmk_core/common/action_layer.c ****         return layer_switch_get_action(key);
 233:tmk_core/common/action_layer.c ****     }
 234:tmk_core/common/action_layer.c **** 
 235:tmk_core/common/action_layer.c ****     uint8_t layer;
 236:tmk_core/common/action_layer.c **** 
 237:tmk_core/common/action_layer.c ****     if (pressed) {
 238:tmk_core/common/action_layer.c ****         layer = layer_switch_get_layer(key);
 239:tmk_core/common/action_layer.c ****         update_source_layers_cache(key, layer);
 240:tmk_core/common/action_layer.c ****     } else {
 241:tmk_core/common/action_layer.c ****         layer = read_source_layers_cache(key);
 242:tmk_core/common/action_layer.c ****     }
 243:tmk_core/common/action_layer.c ****     return action_for_key(layer, key);
 244:tmk_core/common/action_layer.c **** #else
 245:tmk_core/common/action_layer.c ****     return layer_switch_get_action(key);
 246:tmk_core/common/action_layer.c **** #endif
 247:tmk_core/common/action_layer.c **** }
 248:tmk_core/common/action_layer.c **** 
 249:tmk_core/common/action_layer.c **** /** \brief Layer switch get layer
 250:tmk_core/common/action_layer.c ****  *
 251:tmk_core/common/action_layer.c ****  * Gets the layer based on key info
 252:tmk_core/common/action_layer.c ****  */
 253:tmk_core/common/action_layer.c **** uint8_t layer_switch_get_layer(keypos_t key) {
 783              		.loc 1 253 0
 784              		.cfi_startproc
 785              		@ args = 0, pretend = 0, frame = 8
 786              		@ frame_needed = 0, uses_anonymous_args = 0
 787              	.LVL64:
 254:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
 255:tmk_core/common/action_layer.c ****     action_t action;
 256:tmk_core/common/action_layer.c ****     action.code = ACTION_TRANSPARENT;
 257:tmk_core/common/action_layer.c **** 
 258:tmk_core/common/action_layer.c ****     layer_state_t layers = layer_state | default_layer_state;
 788              		.loc 1 258 0
 789 0000 0E4B     		ldr	r3, .L68
 253:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
 790              		.loc 1 253 0
 791 0002 73B5     		push	{r0, r1, r4, r5, r6, lr}
 792              		.cfi_def_cfa_offset 24
 793              		.cfi_offset 4, -16
 794              		.cfi_offset 5, -12
 795              		.cfi_offset 6, -8
 796              		.cfi_offset 14, -4
 797              		.loc 1 258 0
 798 0004 1E68     		ldr	r6, [r3]
 799 0006 0E4B     		ldr	r3, .L68+4
 253:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
 800              		.loc 1 253 0
 801 0008 ADF80400 		strh	r0, [sp, #4]	@ movhi
 802              		.loc 1 258 0
 803 000c 1B68     		ldr	r3, [r3]
 804 000e 1F24     		movs	r4, #31
 805 0010 1E43     		orrs	r6, r6, r3
 806              	.LVL65:
 807              	.L61:
 808              	.LBB12:
 259:tmk_core/common/action_layer.c ****     /* check top layer first */
 260:tmk_core/common/action_layer.c ****     for (int8_t i = sizeof(layer_state_t) * 8 - 1; i >= 0; i--) {
 261:tmk_core/common/action_layer.c ****         if (layers & (1UL << i)) {
 809              		.loc 1 261 0
 810 0012 26FA04F3 		lsr	r3, r6, r4
 811 0016 DB07     		lsls	r3, r3, #31
 812 0018 E5B2     		uxtb	r5, r4
 813 001a 06D4     		bmi	.L60
 814              	.L63:
 815              	.LVL66:
 260:tmk_core/common/action_layer.c ****         if (layers & (1UL << i)) {
 816              		.loc 1 260 0
 817 001c 14F1FF34 		adds	r4, r4, #-1
 818              	.LVL67:
 819 0020 F7D2     		bcs	.L61
 820              	.LBE12:
 262:tmk_core/common/action_layer.c ****             action = action_for_key(i, key);
 263:tmk_core/common/action_layer.c ****             if (action.code != ACTION_TRANSPARENT) {
 264:tmk_core/common/action_layer.c ****                 return i;
 265:tmk_core/common/action_layer.c ****             }
 266:tmk_core/common/action_layer.c ****         }
 267:tmk_core/common/action_layer.c ****     }
 268:tmk_core/common/action_layer.c ****     /* fall back to layer 0 */
 269:tmk_core/common/action_layer.c ****     return 0;
 821              		.loc 1 269 0
 822 0022 0025     		movs	r5, #0
 823              	.LVL68:
 824              	.L62:
 270:tmk_core/common/action_layer.c **** #else
 271:tmk_core/common/action_layer.c ****     return biton32(default_layer_state);
 272:tmk_core/common/action_layer.c **** #endif
 273:tmk_core/common/action_layer.c **** }
 825              		.loc 1 273 0
 826 0024 2846     		mov	r0, r5
 827              	.LVL69:
 828 0026 02B0     		add	sp, sp, #8
 829              		.cfi_remember_state
 830              		.cfi_def_cfa_offset 16
 831              		@ sp needed
 832 0028 70BD     		pop	{r4, r5, r6, pc}
 833              	.LVL70:
 834              	.L60:
 835              		.cfi_restore_state
 836              	.LBB13:
 262:tmk_core/common/action_layer.c ****             action = action_for_key(i, key);
 837              		.loc 1 262 0
 838 002a 0199     		ldr	r1, [sp, #4]
 839 002c 2846     		mov	r0, r5
 840              	.LVL71:
 841 002e FFF7FEFF 		bl	action_for_key
 842              	.LVL72:
 263:tmk_core/common/action_layer.c ****                 return i;
 843              		.loc 1 263 0
 844 0032 80B2     		uxth	r0, r0
 845              	.LVL73:
 846 0034 0128     		cmp	r0, #1
 847 0036 F1D0     		beq	.L63
 848 0038 F4E7     		b	.L62
 849              	.L69:
 850 003a 00BF     		.align	2
 851              	.L68:
 852 003c 00000000 		.word	.LANCHOR1
 853 0040 00000000 		.word	.LANCHOR0
 854              	.LBE13:
 855              		.cfi_endproc
 856              	.LFE28:
 858              		.section	.text.layer_switch_get_action,"ax",%progbits
 859              		.align	1
 860              		.global	layer_switch_get_action
 861              		.syntax unified
 862              		.thumb
 863              		.thumb_func
 864              		.fpu softvfp
 866              	layer_switch_get_action:
 867              	.LFB29:
 274:tmk_core/common/action_layer.c **** 
 275:tmk_core/common/action_layer.c **** /** \brief Layer switch get layer
 276:tmk_core/common/action_layer.c ****  *
 277:tmk_core/common/action_layer.c ****  * Gets action code based on key position
 278:tmk_core/common/action_layer.c ****  */
 279:tmk_core/common/action_layer.c **** action_t layer_switch_get_action(keypos_t key) { return action_for_key(layer_switch_get_layer(key),
 868              		.loc 1 279 0
 869              		.cfi_startproc
 870              		@ args = 0, pretend = 0, frame = 8
 871              		@ frame_needed = 0, uses_anonymous_args = 0
 872 0000 07B5     		push	{r0, r1, r2, lr}
 873              		.cfi_def_cfa_offset 16
 874              		.cfi_offset 14, -4
 875              		.loc 1 279 0
 876 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 877 0006 0198     		ldr	r0, [sp, #4]
 878 0008 FFF7FEFF 		bl	layer_switch_get_layer
 879              	.LVL74:
 880 000c 0199     		ldr	r1, [sp, #4]
 881 000e 03B0     		add	sp, sp, #12
 882              		.cfi_def_cfa_offset 4
 883              		@ sp needed
 884 0010 5DF804EB 		ldr	lr, [sp], #4
 885              		.cfi_restore 14
 886              		.cfi_def_cfa_offset 0
 887 0014 FFF7FEBF 		b	action_for_key
 888              	.LVL75:
 889              		.cfi_endproc
 890              	.LFE29:
 892              		.section	.text.store_or_get_action,"ax",%progbits
 893              		.align	1
 894              		.global	store_or_get_action
 895              		.syntax unified
 896              		.thumb
 897              		.thumb_func
 898              		.fpu softvfp
 900              	store_or_get_action:
 901              	.LFB27:
 229:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 902              		.loc 1 229 0
 903              		.cfi_startproc
 904              		@ args = 0, pretend = 0, frame = 8
 905              		@ frame_needed = 0, uses_anonymous_args = 0
 906              	.LVL76:
 907 0000 13B5     		push	{r0, r1, r4, lr}
 908              		.cfi_def_cfa_offset 16
 909              		.cfi_offset 4, -8
 910              		.cfi_offset 14, -4
 231:tmk_core/common/action_layer.c ****         return layer_switch_get_action(key);
 911              		.loc 1 231 0
 912 0002 104B     		ldr	r3, .L75
 229:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 913              		.loc 1 229 0
 914 0004 ADF80410 		strh	r1, [sp, #4]	@ movhi
 231:tmk_core/common/action_layer.c ****         return layer_switch_get_action(key);
 915              		.loc 1 231 0
 916 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 917 000a 2BB1     		cbz	r3, .L72
 232:tmk_core/common/action_layer.c ****     }
 918              		.loc 1 232 0
 919 000c 0198     		ldr	r0, [sp, #4]
 920              	.LVL77:
 247:tmk_core/common/action_layer.c **** 
 921              		.loc 1 247 0
 922 000e 02B0     		add	sp, sp, #8
 923              		.cfi_remember_state
 924              		.cfi_def_cfa_offset 8
 925              		@ sp needed
 926 0010 BDE81040 		pop	{r4, lr}
 927              		.cfi_restore 14
 928              		.cfi_restore 4
 929              		.cfi_def_cfa_offset 0
 232:tmk_core/common/action_layer.c ****     }
 930              		.loc 1 232 0
 931 0014 FFF7FEBF 		b	layer_switch_get_action
 932              	.LVL78:
 933              	.L72:
 934              		.cfi_restore_state
 237:tmk_core/common/action_layer.c ****         layer = layer_switch_get_layer(key);
 935              		.loc 1 237 0
 936 0018 70B1     		cbz	r0, .L73
 238:tmk_core/common/action_layer.c ****         update_source_layers_cache(key, layer);
 937              		.loc 1 238 0
 938 001a 0198     		ldr	r0, [sp, #4]
 939              	.LVL79:
 940 001c FFF7FEFF 		bl	layer_switch_get_layer
 941              	.LVL80:
 942 0020 0446     		mov	r4, r0
 943              	.LVL81:
 239:tmk_core/common/action_layer.c ****     } else {
 944              		.loc 1 239 0
 945 0022 0146     		mov	r1, r0
 946 0024 0198     		ldr	r0, [sp, #4]
 947              	.LVL82:
 948 0026 FFF7FEFF 		bl	update_source_layers_cache
 949              	.LVL83:
 950              	.L74:
 243:tmk_core/common/action_layer.c **** #else
 951              		.loc 1 243 0
 952 002a 0199     		ldr	r1, [sp, #4]
 953 002c 2046     		mov	r0, r4
 247:tmk_core/common/action_layer.c **** 
 954              		.loc 1 247 0
 955 002e 02B0     		add	sp, sp, #8
 956              		.cfi_remember_state
 957              		.cfi_def_cfa_offset 8
 958              		@ sp needed
 959 0030 BDE81040 		pop	{r4, lr}
 960              		.cfi_restore 14
 961              		.cfi_restore 4
 962              		.cfi_def_cfa_offset 0
 963              	.LVL84:
 243:tmk_core/common/action_layer.c **** #else
 964              		.loc 1 243 0
 965 0034 FFF7FEBF 		b	action_for_key
 966              	.LVL85:
 967              	.L73:
 968              		.cfi_restore_state
 241:tmk_core/common/action_layer.c ****     }
 969              		.loc 1 241 0
 970 0038 0198     		ldr	r0, [sp, #4]
 971              	.LVL86:
 972 003a FFF7FEFF 		bl	read_source_layers_cache
 973              	.LVL87:
 974 003e 0446     		mov	r4, r0
 975              	.LVL88:
 976 0040 F3E7     		b	.L74
 977              	.L76:
 978 0042 00BF     		.align	2
 979              	.L75:
 980 0044 00000000 		.word	disable_action_cache
 981              		.cfi_endproc
 982              	.LFE27:
 984              		.global	source_layers_cache
 985              		.global	layer_state
 986              		.global	default_layer_state
 987              		.section	.bss.default_layer_state,"aw",%nobits
 988              		.align	2
 989              		.set	.LANCHOR0,. + 0
 992              	default_layer_state:
 993 0000 00000000 		.space	4
 994              		.section	.bss.layer_state,"aw",%nobits
 995              		.align	2
 996              		.set	.LANCHOR1,. + 0
 999              	layer_state:
 1000 0000 00000000 		.space	4
 1001              		.section	.bss.source_layers_cache,"aw",%nobits
 1002              		.set	.LANCHOR2,. + 0
 1005              	source_layers_cache:
 1006 0000 00000000 		.space	40
 1006      00000000 
 1006      00000000 
 1006      00000000 
 1006      00000000 
 1007              		.text
 1008              	.Letext0:
 1009              		.file 2 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 1010              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 1011              		.file 4 "tmk_core/common/keyboard.h"
 1012              		.file 5 "tmk_core/common/action_code.h"
 1013              		.file 6 "tmk_core/common/action_layer.h"
 1014              		.file 7 "tmk_core/common/action.h"
 1015              		.file 8 "tmk_core/common/debug.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action_layer.c
/var/tmp//cc4eMydm.s:16     .text.default_layer_state_set_user:0000000000000000 $t
/var/tmp//cc4eMydm.s:23     .text.default_layer_state_set_user:0000000000000000 default_layer_state_set_user
/var/tmp//cc4eMydm.s:38     .text.default_layer_state_set_kb:0000000000000000 $t
/var/tmp//cc4eMydm.s:45     .text.default_layer_state_set_kb:0000000000000000 default_layer_state_set_kb
/var/tmp//cc4eMydm.s:64     .text.default_layer_state_set:0000000000000000 $t
/var/tmp//cc4eMydm.s:70     .text.default_layer_state_set:0000000000000000 default_layer_state_set
/var/tmp//cc4eMydm.s:98     .text.default_layer_state_set:0000000000000014 $d
/var/tmp//cc4eMydm.s:103    .text.default_layer_debug:0000000000000000 $t
/var/tmp//cc4eMydm.s:110    .text.default_layer_debug:0000000000000000 default_layer_debug
/var/tmp//cc4eMydm.s:123    .text.default_layer_set:0000000000000000 $t
/var/tmp//cc4eMydm.s:130    .text.default_layer_set:0000000000000000 default_layer_set
/var/tmp//cc4eMydm.s:145    .text.default_layer_or:0000000000000000 $t
/var/tmp//cc4eMydm.s:152    .text.default_layer_or:0000000000000000 default_layer_or
/var/tmp//cc4eMydm.s:170    .text.default_layer_or:000000000000000c $d
/var/tmp//cc4eMydm.s:175    .text.default_layer_and:0000000000000000 $t
/var/tmp//cc4eMydm.s:182    .text.default_layer_and:0000000000000000 default_layer_and
/var/tmp//cc4eMydm.s:200    .text.default_layer_and:000000000000000c $d
/var/tmp//cc4eMydm.s:205    .text.default_layer_xor:0000000000000000 $t
/var/tmp//cc4eMydm.s:212    .text.default_layer_xor:0000000000000000 default_layer_xor
/var/tmp//cc4eMydm.s:230    .text.default_layer_xor:000000000000000c $d
/var/tmp//cc4eMydm.s:235    .text.layer_state_set_user:0000000000000000 $t
/var/tmp//cc4eMydm.s:242    .text.layer_state_set_user:0000000000000000 layer_state_set_user
/var/tmp//cc4eMydm.s:253    .text.layer_state_set_kb:0000000000000000 $t
/var/tmp//cc4eMydm.s:260    .text.layer_state_set_kb:0000000000000000 layer_state_set_kb
/var/tmp//cc4eMydm.s:280    .text.layer_state_set:0000000000000000 $t
/var/tmp//cc4eMydm.s:287    .text.layer_state_set:0000000000000000 layer_state_set
/var/tmp//cc4eMydm.s:315    .text.layer_state_set:0000000000000014 $d
/var/tmp//cc4eMydm.s:320    .text.layer_clear:0000000000000000 $t
/var/tmp//cc4eMydm.s:327    .text.layer_clear:0000000000000000 layer_clear
/var/tmp//cc4eMydm.s:342    .text.layer_state_cmp:0000000000000000 $t
/var/tmp//cc4eMydm.s:349    .text.layer_state_cmp:0000000000000000 layer_state_cmp
/var/tmp//cc4eMydm.s:376    .text.layer_state_is:0000000000000000 $t
/var/tmp//cc4eMydm.s:383    .text.layer_state_is:0000000000000000 layer_state_is
/var/tmp//cc4eMydm.s:401    .text.layer_state_is:000000000000000c $d
/var/tmp//cc4eMydm.s:406    .text.layer_move:0000000000000000 $t
/var/tmp//cc4eMydm.s:413    .text.layer_move:0000000000000000 layer_move
/var/tmp//cc4eMydm.s:431    .text.layer_on:0000000000000000 $t
/var/tmp//cc4eMydm.s:438    .text.layer_on:0000000000000000 layer_on
/var/tmp//cc4eMydm.s:458    .text.layer_on:0000000000000010 $d
/var/tmp//cc4eMydm.s:463    .text.layer_off:0000000000000000 $t
/var/tmp//cc4eMydm.s:470    .text.layer_off:0000000000000000 layer_off
/var/tmp//cc4eMydm.s:490    .text.layer_off:0000000000000014 $d
/var/tmp//cc4eMydm.s:495    .text.layer_invert:0000000000000000 $t
/var/tmp//cc4eMydm.s:502    .text.layer_invert:0000000000000000 layer_invert
/var/tmp//cc4eMydm.s:522    .text.layer_invert:0000000000000010 $d
/var/tmp//cc4eMydm.s:527    .text.layer_or:0000000000000000 $t
/var/tmp//cc4eMydm.s:534    .text.layer_or:0000000000000000 layer_or
/var/tmp//cc4eMydm.s:552    .text.layer_or:000000000000000c $d
/var/tmp//cc4eMydm.s:557    .text.layer_and:0000000000000000 $t
/var/tmp//cc4eMydm.s:564    .text.layer_and:0000000000000000 layer_and
/var/tmp//cc4eMydm.s:582    .text.layer_and:000000000000000c $d
/var/tmp//cc4eMydm.s:587    .text.layer_xor:0000000000000000 $t
/var/tmp//cc4eMydm.s:594    .text.layer_xor:0000000000000000 layer_xor
/var/tmp//cc4eMydm.s:612    .text.layer_xor:000000000000000c $d
/var/tmp//cc4eMydm.s:617    .text.layer_debug:0000000000000000 $t
/var/tmp//cc4eMydm.s:624    .text.layer_debug:0000000000000000 layer_debug
/var/tmp//cc4eMydm.s:635    .text.update_source_layers_cache:0000000000000000 $t
/var/tmp//cc4eMydm.s:642    .text.update_source_layers_cache:0000000000000000 update_source_layers_cache
/var/tmp//cc4eMydm.s:699    .text.update_source_layers_cache:0000000000000048 $d
/var/tmp//cc4eMydm.s:704    .text.read_source_layers_cache:0000000000000000 $t
/var/tmp//cc4eMydm.s:711    .text.read_source_layers_cache:0000000000000000 read_source_layers_cache
/var/tmp//cc4eMydm.s:769    .text.read_source_layers_cache:000000000000003c $d
/var/tmp//cc4eMydm.s:774    .text.layer_switch_get_layer:0000000000000000 $t
/var/tmp//cc4eMydm.s:781    .text.layer_switch_get_layer:0000000000000000 layer_switch_get_layer
/var/tmp//cc4eMydm.s:852    .text.layer_switch_get_layer:000000000000003c $d
/var/tmp//cc4eMydm.s:859    .text.layer_switch_get_action:0000000000000000 $t
/var/tmp//cc4eMydm.s:866    .text.layer_switch_get_action:0000000000000000 layer_switch_get_action
/var/tmp//cc4eMydm.s:893    .text.store_or_get_action:0000000000000000 $t
/var/tmp//cc4eMydm.s:900    .text.store_or_get_action:0000000000000000 store_or_get_action
/var/tmp//cc4eMydm.s:980    .text.store_or_get_action:0000000000000044 $d
/var/tmp//cc4eMydm.s:1005   .bss.source_layers_cache:0000000000000000 source_layers_cache
/var/tmp//cc4eMydm.s:999    .bss.layer_state:0000000000000000 layer_state
/var/tmp//cc4eMydm.s:992    .bss.default_layer_state:0000000000000000 default_layer_state
/var/tmp//cc4eMydm.s:988    .bss.default_layer_state:0000000000000000 $d
/var/tmp//cc4eMydm.s:995    .bss.layer_state:0000000000000000 $d
/var/tmp//cc4eMydm.s:1006   .bss.source_layers_cache:0000000000000000 $d

UNDEFINED SYMBOLS
clear_keyboard_but_mods_and_keys
action_for_key
disable_action_cache

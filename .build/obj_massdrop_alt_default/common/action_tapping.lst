   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"action_tapping.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.debug_waiting_buffer,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	debug_waiting_buffer:
  25              	.LFB14:
  26              		.file 1 "tmk_core/common/action_tapping.c"
   1:tmk_core/common/action_tapping.c **** #include <stdint.h>
   2:tmk_core/common/action_tapping.c **** #include <stdbool.h>
   3:tmk_core/common/action_tapping.c **** #include "action.h"
   4:tmk_core/common/action_tapping.c **** #include "action_layer.h"
   5:tmk_core/common/action_tapping.c **** #include "action_tapping.h"
   6:tmk_core/common/action_tapping.c **** #include "keycode.h"
   7:tmk_core/common/action_tapping.c **** #include "timer.h"
   8:tmk_core/common/action_tapping.c **** 
   9:tmk_core/common/action_tapping.c **** #ifdef DEBUG_ACTION
  10:tmk_core/common/action_tapping.c **** #    include "debug.h"
  11:tmk_core/common/action_tapping.c **** #else
  12:tmk_core/common/action_tapping.c **** #    include "nodebug.h"
  13:tmk_core/common/action_tapping.c **** #endif
  14:tmk_core/common/action_tapping.c **** 
  15:tmk_core/common/action_tapping.c **** #ifndef NO_ACTION_TAPPING
  16:tmk_core/common/action_tapping.c **** 
  17:tmk_core/common/action_tapping.c **** #    define IS_TAPPING() !IS_NOEVENT(tapping_key.event)
  18:tmk_core/common/action_tapping.c **** #    define IS_TAPPING_PRESSED() (IS_TAPPING() && tapping_key.event.pressed)
  19:tmk_core/common/action_tapping.c **** #    define IS_TAPPING_RELEASED() (IS_TAPPING() && !tapping_key.event.pressed)
  20:tmk_core/common/action_tapping.c **** #    define IS_TAPPING_KEY(k) (IS_TAPPING() && KEYEQ(tapping_key.event.key, (k)))
  21:tmk_core/common/action_tapping.c **** 
  22:tmk_core/common/action_tapping.c **** __attribute__((weak)) uint16_t get_tapping_term(uint16_t keycode) { return TAPPING_TERM; }
  23:tmk_core/common/action_tapping.c **** 
  24:tmk_core/common/action_tapping.c **** #    ifdef TAPPING_TERM_PER_KEY
  25:tmk_core/common/action_tapping.c **** #        define WITHIN_TAPPING_TERM(e) (TIMER_DIFF_16(e.time, tapping_key.event.time) < get_tapping
  26:tmk_core/common/action_tapping.c **** #    else
  27:tmk_core/common/action_tapping.c **** #        define WITHIN_TAPPING_TERM(e) (TIMER_DIFF_16(e.time, tapping_key.event.time) < TAPPING_TER
  28:tmk_core/common/action_tapping.c **** #    endif
  29:tmk_core/common/action_tapping.c **** 
  30:tmk_core/common/action_tapping.c **** static keyrecord_t tapping_key                         = {};
  31:tmk_core/common/action_tapping.c **** static keyrecord_t waiting_buffer[WAITING_BUFFER_SIZE] = {};
  32:tmk_core/common/action_tapping.c **** static uint8_t     waiting_buffer_head                 = 0;
  33:tmk_core/common/action_tapping.c **** static uint8_t     waiting_buffer_tail                 = 0;
  34:tmk_core/common/action_tapping.c **** 
  35:tmk_core/common/action_tapping.c **** static bool process_tapping(keyrecord_t *record);
  36:tmk_core/common/action_tapping.c **** static bool waiting_buffer_enq(keyrecord_t record);
  37:tmk_core/common/action_tapping.c **** static void waiting_buffer_clear(void);
  38:tmk_core/common/action_tapping.c **** static bool waiting_buffer_typed(keyevent_t event);
  39:tmk_core/common/action_tapping.c **** static bool waiting_buffer_has_anykey_pressed(void);
  40:tmk_core/common/action_tapping.c **** static void waiting_buffer_scan_tap(void);
  41:tmk_core/common/action_tapping.c **** static void debug_tapping_key(void);
  42:tmk_core/common/action_tapping.c **** static void debug_waiting_buffer(void);
  43:tmk_core/common/action_tapping.c **** 
  44:tmk_core/common/action_tapping.c **** /** \brief Action Tapping Process
  45:tmk_core/common/action_tapping.c ****  *
  46:tmk_core/common/action_tapping.c ****  * FIXME: Needs doc
  47:tmk_core/common/action_tapping.c ****  */
  48:tmk_core/common/action_tapping.c **** void action_tapping_process(keyrecord_t record) {
  49:tmk_core/common/action_tapping.c ****     if (process_tapping(&record)) {
  50:tmk_core/common/action_tapping.c ****         if (!IS_NOEVENT(record.event)) {
  51:tmk_core/common/action_tapping.c ****             debug("processed: ");
  52:tmk_core/common/action_tapping.c ****             debug_record(record);
  53:tmk_core/common/action_tapping.c ****             debug("\n");
  54:tmk_core/common/action_tapping.c ****         }
  55:tmk_core/common/action_tapping.c ****     } else {
  56:tmk_core/common/action_tapping.c ****         if (!waiting_buffer_enq(record)) {
  57:tmk_core/common/action_tapping.c ****             // clear all in case of overflow.
  58:tmk_core/common/action_tapping.c ****             debug("OVERFLOW: CLEAR ALL STATES\n");
  59:tmk_core/common/action_tapping.c ****             clear_keyboard();
  60:tmk_core/common/action_tapping.c ****             waiting_buffer_clear();
  61:tmk_core/common/action_tapping.c ****             tapping_key = (keyrecord_t){};
  62:tmk_core/common/action_tapping.c ****         }
  63:tmk_core/common/action_tapping.c ****     }
  64:tmk_core/common/action_tapping.c **** 
  65:tmk_core/common/action_tapping.c ****     // process waiting_buffer
  66:tmk_core/common/action_tapping.c ****     if (!IS_NOEVENT(record.event) && waiting_buffer_head != waiting_buffer_tail) {
  67:tmk_core/common/action_tapping.c ****         debug("---- action_exec: process waiting_buffer -----\n");
  68:tmk_core/common/action_tapping.c ****     }
  69:tmk_core/common/action_tapping.c ****     for (; waiting_buffer_tail != waiting_buffer_head; waiting_buffer_tail = (waiting_buffer_tail +
  70:tmk_core/common/action_tapping.c ****         if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
  71:tmk_core/common/action_tapping.c ****             debug("processed: waiting_buffer[");
  72:tmk_core/common/action_tapping.c ****             debug_dec(waiting_buffer_tail);
  73:tmk_core/common/action_tapping.c ****             debug("] = ");
  74:tmk_core/common/action_tapping.c ****             debug_record(waiting_buffer[waiting_buffer_tail]);
  75:tmk_core/common/action_tapping.c ****             debug("\n\n");
  76:tmk_core/common/action_tapping.c ****         } else {
  77:tmk_core/common/action_tapping.c ****             break;
  78:tmk_core/common/action_tapping.c ****         }
  79:tmk_core/common/action_tapping.c ****     }
  80:tmk_core/common/action_tapping.c ****     if (!IS_NOEVENT(record.event)) {
  81:tmk_core/common/action_tapping.c ****         debug("\n");
  82:tmk_core/common/action_tapping.c ****     }
  83:tmk_core/common/action_tapping.c **** }
  84:tmk_core/common/action_tapping.c **** 
  85:tmk_core/common/action_tapping.c **** /** \brief Tapping
  86:tmk_core/common/action_tapping.c ****  *
  87:tmk_core/common/action_tapping.c ****  * Rule: Tap key is typed(pressed and released) within TAPPING_TERM.
  88:tmk_core/common/action_tapping.c ****  *       (without interfering by typing other key)
  89:tmk_core/common/action_tapping.c ****  */
  90:tmk_core/common/action_tapping.c **** /* return true when key event is processed or consumed. */
  91:tmk_core/common/action_tapping.c **** bool process_tapping(keyrecord_t *keyp) {
  92:tmk_core/common/action_tapping.c ****     keyevent_t event = keyp->event;
  93:tmk_core/common/action_tapping.c **** 
  94:tmk_core/common/action_tapping.c ****     // if tapping
  95:tmk_core/common/action_tapping.c ****     if (IS_TAPPING_PRESSED()) {
  96:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
  97:tmk_core/common/action_tapping.c ****             if (tapping_key.tap.count == 0) {
  98:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
  99:tmk_core/common/action_tapping.c ****                     // first tap!
 100:tmk_core/common/action_tapping.c ****                     debug("Tapping: First tap(0->1).\n");
 101:tmk_core/common/action_tapping.c ****                     tapping_key.tap.count = 1;
 102:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 103:tmk_core/common/action_tapping.c ****                     process_record(&tapping_key);
 104:tmk_core/common/action_tapping.c **** 
 105:tmk_core/common/action_tapping.c ****                     // copy tapping state
 106:tmk_core/common/action_tapping.c ****                     keyp->tap = tapping_key.tap;
 107:tmk_core/common/action_tapping.c ****                     // enqueue
 108:tmk_core/common/action_tapping.c ****                     return false;
 109:tmk_core/common/action_tapping.c ****                 }
 110:tmk_core/common/action_tapping.c ****                 /* Process a key typed within TAPPING_TERM
 111:tmk_core/common/action_tapping.c ****                  * This can register the key before settlement of tapping,
 112:tmk_core/common/action_tapping.c ****                  * useful for long TAPPING_TERM but may prevent fast typing.
 113:tmk_core/common/action_tapping.c ****                  */
 114:tmk_core/common/action_tapping.c **** #    if defined(TAPPING_TERM_PER_KEY) || (!defined(PER_KEY_TAPPING_TERM) && TAPPING_TERM >= 500) ||
 115:tmk_core/common/action_tapping.c **** #        ifdef TAPPING_TERM_PER_KEY
 116:tmk_core/common/action_tapping.c ****                 else if ((get_tapping_term(get_event_keycode(tapping_key.event)) >= 500) && IS_RELE
 117:tmk_core/common/action_tapping.c **** #        else
 118:tmk_core/common/action_tapping.c ****                 else if (IS_RELEASED(event) && waiting_buffer_typed(event))
 119:tmk_core/common/action_tapping.c **** #        endif
 120:tmk_core/common/action_tapping.c ****                 {
 121:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. No tap. Interfered by typing key\n");
 122:tmk_core/common/action_tapping.c ****                     process_record(&tapping_key);
 123:tmk_core/common/action_tapping.c ****                     tapping_key = (keyrecord_t){};
 124:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 125:tmk_core/common/action_tapping.c ****                     // enqueue
 126:tmk_core/common/action_tapping.c ****                     return false;
 127:tmk_core/common/action_tapping.c ****                 }
 128:tmk_core/common/action_tapping.c **** #    endif
 129:tmk_core/common/action_tapping.c ****                 /* Process release event of a key pressed before tapping starts
 130:tmk_core/common/action_tapping.c ****                  * Without this unexpected repeating will occur with having fast repeating setting
 131:tmk_core/common/action_tapping.c ****                  * https://github.com/tmk/tmk_keyboard/issues/60
 132:tmk_core/common/action_tapping.c ****                  */
 133:tmk_core/common/action_tapping.c ****                 else if (IS_RELEASED(event) && !waiting_buffer_typed(event)) {
 134:tmk_core/common/action_tapping.c ****                     // Modifier should be retained till end of this tapping.
 135:tmk_core/common/action_tapping.c ****                     action_t action = layer_switch_get_action(event.key);
 136:tmk_core/common/action_tapping.c ****                     switch (action.kind.id) {
 137:tmk_core/common/action_tapping.c ****                         case ACT_LMODS:
 138:tmk_core/common/action_tapping.c ****                         case ACT_RMODS:
 139:tmk_core/common/action_tapping.c ****                             if (action.key.mods && !action.key.code) return false;
 140:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 141:tmk_core/common/action_tapping.c ****                             break;
 142:tmk_core/common/action_tapping.c ****                         case ACT_LMODS_TAP:
 143:tmk_core/common/action_tapping.c ****                         case ACT_RMODS_TAP:
 144:tmk_core/common/action_tapping.c ****                             if (action.key.mods && keyp->tap.count == 0) return false;
 145:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 146:tmk_core/common/action_tapping.c ****                             break;
 147:tmk_core/common/action_tapping.c ****                     }
 148:tmk_core/common/action_tapping.c ****                     // Release of key should be process immediately.
 149:tmk_core/common/action_tapping.c ****                     debug("Tapping: release event of a key pressed before tapping\n");
 150:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 151:tmk_core/common/action_tapping.c ****                     return true;
 152:tmk_core/common/action_tapping.c ****                 } else {
 153:tmk_core/common/action_tapping.c ****                     // set interrupted flag when other key preesed during tapping
 154:tmk_core/common/action_tapping.c ****                     if (event.pressed) {
 155:tmk_core/common/action_tapping.c ****                         tapping_key.tap.interrupted = true;
 156:tmk_core/common/action_tapping.c ****                     }
 157:tmk_core/common/action_tapping.c ****                     // enqueue
 158:tmk_core/common/action_tapping.c ****                     return false;
 159:tmk_core/common/action_tapping.c ****                 }
 160:tmk_core/common/action_tapping.c ****             }
 161:tmk_core/common/action_tapping.c ****             // tap_count > 0
 162:tmk_core/common/action_tapping.c ****             else {
 163:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
 164:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 165:tmk_core/common/action_tapping.c ****                     debug_dec(tapping_key.tap.count);
 166:tmk_core/common/action_tapping.c ****                     debug(")\n");
 167:tmk_core/common/action_tapping.c ****                     keyp->tap = tapping_key.tap;
 168:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 169:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 170:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 171:tmk_core/common/action_tapping.c ****                     return true;
 172:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 173:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 174:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last tap(>1).\n");
 175:tmk_core/common/action_tapping.c ****                         // unregister key
 176:tmk_core/common/action_tapping.c ****                         process_record(&(keyrecord_t){.tap = tapping_key.tap, .event.key = tapping_
 177:tmk_core/common/action_tapping.c ****                     } else {
 178:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start while last tap(1).\n");
 179:tmk_core/common/action_tapping.c ****                     }
 180:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 181:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 182:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 183:tmk_core/common/action_tapping.c ****                     return true;
 184:tmk_core/common/action_tapping.c ****                 } else {
 185:tmk_core/common/action_tapping.c ****                     if (!IS_NOEVENT(event)) {
 186:tmk_core/common/action_tapping.c ****                         debug("Tapping: key event while last tap(>0).\n");
 187:tmk_core/common/action_tapping.c ****                     }
 188:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 189:tmk_core/common/action_tapping.c ****                     return true;
 190:tmk_core/common/action_tapping.c ****                 }
 191:tmk_core/common/action_tapping.c ****             }
 192:tmk_core/common/action_tapping.c ****         }
 193:tmk_core/common/action_tapping.c ****         // after TAPPING_TERM
 194:tmk_core/common/action_tapping.c ****         else {
 195:tmk_core/common/action_tapping.c ****             if (tapping_key.tap.count == 0) {
 196:tmk_core/common/action_tapping.c ****                 debug("Tapping: End. Timeout. Not tap(0): ");
 197:tmk_core/common/action_tapping.c ****                 debug_event(event);
 198:tmk_core/common/action_tapping.c ****                 debug("\n");
 199:tmk_core/common/action_tapping.c ****                 process_record(&tapping_key);
 200:tmk_core/common/action_tapping.c ****                 tapping_key = (keyrecord_t){};
 201:tmk_core/common/action_tapping.c ****                 debug_tapping_key();
 202:tmk_core/common/action_tapping.c ****                 return false;
 203:tmk_core/common/action_tapping.c ****             } else {
 204:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
 205:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 206:tmk_core/common/action_tapping.c ****                     keyp->tap = tapping_key.tap;
 207:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 208:tmk_core/common/action_tapping.c ****                     tapping_key = (keyrecord_t){};
 209:tmk_core/common/action_tapping.c ****                     return true;
 210:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 211:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 212:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last timeout tap(>1).\n");
 213:tmk_core/common/action_tapping.c ****                         // unregister key
 214:tmk_core/common/action_tapping.c ****                         process_record(&(keyrecord_t){.tap = tapping_key.tap, .event.key = tapping_
 215:tmk_core/common/action_tapping.c ****                     } else {
 216:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start while last timeout tap(1).\n");
 217:tmk_core/common/action_tapping.c ****                     }
 218:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 219:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 220:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 221:tmk_core/common/action_tapping.c ****                     return true;
 222:tmk_core/common/action_tapping.c ****                 } else {
 223:tmk_core/common/action_tapping.c ****                     if (!IS_NOEVENT(event)) {
 224:tmk_core/common/action_tapping.c ****                         debug("Tapping: key event while last timeout tap(>0).\n");
 225:tmk_core/common/action_tapping.c ****                     }
 226:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 227:tmk_core/common/action_tapping.c ****                     return true;
 228:tmk_core/common/action_tapping.c ****                 }
 229:tmk_core/common/action_tapping.c ****             }
 230:tmk_core/common/action_tapping.c ****         }
 231:tmk_core/common/action_tapping.c ****     } else if (IS_TAPPING_RELEASED()) {
 232:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 233:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 234:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key)) {
 235:tmk_core/common/action_tapping.c **** #    ifndef TAPPING_FORCE_HOLD
 236:tmk_core/common/action_tapping.c ****                     if (!tapping_key.tap.interrupted && tapping_key.tap.count > 0) {
 237:tmk_core/common/action_tapping.c ****                         // sequential tap.
 238:tmk_core/common/action_tapping.c ****                         keyp->tap = tapping_key.tap;
 239:tmk_core/common/action_tapping.c ****                         if (keyp->tap.count < 15) keyp->tap.count += 1;
 240:tmk_core/common/action_tapping.c ****                         debug("Tapping: Tap press(");
 241:tmk_core/common/action_tapping.c ****                         debug_dec(keyp->tap.count);
 242:tmk_core/common/action_tapping.c ****                         debug(")\n");
 243:tmk_core/common/action_tapping.c ****                         process_record(keyp);
 244:tmk_core/common/action_tapping.c ****                         tapping_key = *keyp;
 245:tmk_core/common/action_tapping.c ****                         debug_tapping_key();
 246:tmk_core/common/action_tapping.c ****                         return true;
 247:tmk_core/common/action_tapping.c ****                     }
 248:tmk_core/common/action_tapping.c **** #    endif
 249:tmk_core/common/action_tapping.c ****                     // FIX: start new tap again
 250:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 251:tmk_core/common/action_tapping.c ****                     return true;
 252:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key)) {
 253:tmk_core/common/action_tapping.c ****                     // Sequential tap can be interfered with other tap key.
 254:tmk_core/common/action_tapping.c ****                     debug("Tapping: Start with interfering other tap.\n");
 255:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 256:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 257:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 258:tmk_core/common/action_tapping.c ****                     return true;
 259:tmk_core/common/action_tapping.c ****                 } else {
 260:tmk_core/common/action_tapping.c ****                     // should none in buffer
 261:tmk_core/common/action_tapping.c ****                     // FIX: interrupted when other key is pressed
 262:tmk_core/common/action_tapping.c ****                     tapping_key.tap.interrupted = true;
 263:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 264:tmk_core/common/action_tapping.c ****                     return true;
 265:tmk_core/common/action_tapping.c ****                 }
 266:tmk_core/common/action_tapping.c ****             } else {
 267:tmk_core/common/action_tapping.c ****                 if (!IS_NOEVENT(event)) debug("Tapping: other key just after tap.\n");
 268:tmk_core/common/action_tapping.c ****                 process_record(keyp);
 269:tmk_core/common/action_tapping.c ****                 return true;
 270:tmk_core/common/action_tapping.c ****             }
 271:tmk_core/common/action_tapping.c ****         } else {
 272:tmk_core/common/action_tapping.c ****             // FIX: process_action here?
 273:tmk_core/common/action_tapping.c ****             // timeout. no sequential tap.
 274:tmk_core/common/action_tapping.c ****             debug("Tapping: End(Timeout after releasing last tap): ");
 275:tmk_core/common/action_tapping.c ****             debug_event(event);
 276:tmk_core/common/action_tapping.c ****             debug("\n");
 277:tmk_core/common/action_tapping.c ****             tapping_key = (keyrecord_t){};
 278:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 279:tmk_core/common/action_tapping.c ****             return false;
 280:tmk_core/common/action_tapping.c ****         }
 281:tmk_core/common/action_tapping.c ****     }
 282:tmk_core/common/action_tapping.c ****     // not tapping state
 283:tmk_core/common/action_tapping.c ****     else {
 284:tmk_core/common/action_tapping.c ****         if (event.pressed && is_tap_key(event.key)) {
 285:tmk_core/common/action_tapping.c ****             debug("Tapping: Start(Press tap key).\n");
 286:tmk_core/common/action_tapping.c ****             tapping_key = *keyp;
 287:tmk_core/common/action_tapping.c ****             process_record_tap_hint(&tapping_key);
 288:tmk_core/common/action_tapping.c ****             waiting_buffer_scan_tap();
 289:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 290:tmk_core/common/action_tapping.c ****             return true;
 291:tmk_core/common/action_tapping.c ****         } else {
 292:tmk_core/common/action_tapping.c ****             process_record(keyp);
 293:tmk_core/common/action_tapping.c ****             return true;
 294:tmk_core/common/action_tapping.c ****         }
 295:tmk_core/common/action_tapping.c ****     }
 296:tmk_core/common/action_tapping.c **** }
 297:tmk_core/common/action_tapping.c **** 
 298:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer enq
 299:tmk_core/common/action_tapping.c ****  *
 300:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 301:tmk_core/common/action_tapping.c ****  */
 302:tmk_core/common/action_tapping.c **** bool waiting_buffer_enq(keyrecord_t record) {
 303:tmk_core/common/action_tapping.c ****     if (IS_NOEVENT(record.event)) {
 304:tmk_core/common/action_tapping.c ****         return true;
 305:tmk_core/common/action_tapping.c ****     }
 306:tmk_core/common/action_tapping.c **** 
 307:tmk_core/common/action_tapping.c ****     if ((waiting_buffer_head + 1) % WAITING_BUFFER_SIZE == waiting_buffer_tail) {
 308:tmk_core/common/action_tapping.c ****         debug("waiting_buffer_enq: Over flow.\n");
 309:tmk_core/common/action_tapping.c ****         return false;
 310:tmk_core/common/action_tapping.c ****     }
 311:tmk_core/common/action_tapping.c **** 
 312:tmk_core/common/action_tapping.c ****     waiting_buffer[waiting_buffer_head] = record;
 313:tmk_core/common/action_tapping.c ****     waiting_buffer_head                 = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
 314:tmk_core/common/action_tapping.c **** 
 315:tmk_core/common/action_tapping.c ****     debug("waiting_buffer_enq: ");
 316:tmk_core/common/action_tapping.c ****     debug_waiting_buffer();
 317:tmk_core/common/action_tapping.c ****     return true;
 318:tmk_core/common/action_tapping.c **** }
 319:tmk_core/common/action_tapping.c **** 
 320:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer clear
 321:tmk_core/common/action_tapping.c ****  *
 322:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 323:tmk_core/common/action_tapping.c ****  */
 324:tmk_core/common/action_tapping.c **** void waiting_buffer_clear(void) {
 325:tmk_core/common/action_tapping.c ****     waiting_buffer_head = 0;
 326:tmk_core/common/action_tapping.c ****     waiting_buffer_tail = 0;
 327:tmk_core/common/action_tapping.c **** }
 328:tmk_core/common/action_tapping.c **** 
 329:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer typed
 330:tmk_core/common/action_tapping.c ****  *
 331:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 332:tmk_core/common/action_tapping.c ****  */
 333:tmk_core/common/action_tapping.c **** bool waiting_buffer_typed(keyevent_t event) {
 334:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
 335:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 336:tmk_core/common/action_tapping.c ****             return true;
 337:tmk_core/common/action_tapping.c ****         }
 338:tmk_core/common/action_tapping.c ****     }
 339:tmk_core/common/action_tapping.c ****     return false;
 340:tmk_core/common/action_tapping.c **** }
 341:tmk_core/common/action_tapping.c **** 
 342:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer has anykey pressed
 343:tmk_core/common/action_tapping.c ****  *
 344:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 345:tmk_core/common/action_tapping.c ****  */
 346:tmk_core/common/action_tapping.c **** __attribute__((unused)) bool waiting_buffer_has_anykey_pressed(void) {
 347:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
 348:tmk_core/common/action_tapping.c ****         if (waiting_buffer[i].event.pressed) return true;
 349:tmk_core/common/action_tapping.c ****     }
 350:tmk_core/common/action_tapping.c ****     return false;
 351:tmk_core/common/action_tapping.c **** }
 352:tmk_core/common/action_tapping.c **** 
 353:tmk_core/common/action_tapping.c **** /** \brief Scan buffer for tapping
 354:tmk_core/common/action_tapping.c ****  *
 355:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 356:tmk_core/common/action_tapping.c ****  */
 357:tmk_core/common/action_tapping.c **** void waiting_buffer_scan_tap(void) {
 358:tmk_core/common/action_tapping.c ****     // tapping already is settled
 359:tmk_core/common/action_tapping.c ****     if (tapping_key.tap.count > 0) return;
 360:tmk_core/common/action_tapping.c ****     // invalid state: tapping_key released && tap.count == 0
 361:tmk_core/common/action_tapping.c ****     if (!tapping_key.event.pressed) return;
 362:tmk_core/common/action_tapping.c **** 
 363:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
 364:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 365:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 366:tmk_core/common/action_tapping.c ****             waiting_buffer[i].tap.count = 1;
 367:tmk_core/common/action_tapping.c ****             process_record(&tapping_key);
 368:tmk_core/common/action_tapping.c **** 
 369:tmk_core/common/action_tapping.c ****             debug("waiting_buffer_scan_tap: found at [");
 370:tmk_core/common/action_tapping.c ****             debug_dec(i);
 371:tmk_core/common/action_tapping.c ****             debug("]\n");
 372:tmk_core/common/action_tapping.c ****             debug_waiting_buffer();
 373:tmk_core/common/action_tapping.c ****             return;
 374:tmk_core/common/action_tapping.c ****         }
 375:tmk_core/common/action_tapping.c ****     }
 376:tmk_core/common/action_tapping.c **** }
 377:tmk_core/common/action_tapping.c **** 
 378:tmk_core/common/action_tapping.c **** /** \brief Tapping key debug print
 379:tmk_core/common/action_tapping.c ****  *
 380:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 381:tmk_core/common/action_tapping.c ****  */
 382:tmk_core/common/action_tapping.c **** static void debug_tapping_key(void) {
 383:tmk_core/common/action_tapping.c ****     debug("TAPPING_KEY=");
 384:tmk_core/common/action_tapping.c ****     debug_record(tapping_key);
 385:tmk_core/common/action_tapping.c ****     debug("\n");
 386:tmk_core/common/action_tapping.c **** }
 387:tmk_core/common/action_tapping.c **** 
 388:tmk_core/common/action_tapping.c **** /** \brief Waiting buffer debug print
 389:tmk_core/common/action_tapping.c ****  *
 390:tmk_core/common/action_tapping.c ****  * FIXME: Needs docs
 391:tmk_core/common/action_tapping.c ****  */
 392:tmk_core/common/action_tapping.c **** static void debug_waiting_buffer(void) {
  27              		.loc 1 392 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 38B5     		push	{r3, r4, r5, lr}
  32              		.cfi_def_cfa_offset 16
  33              		.cfi_offset 3, -16
  34              		.cfi_offset 4, -12
  35              		.cfi_offset 5, -8
  36              		.cfi_offset 14, -4
  37              	.LBB37:
 393:tmk_core/common/action_tapping.c ****     debug("{ ");
 394:tmk_core/common/action_tapping.c ****     for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SI
  38              		.loc 1 394 0
  39 0002 094D     		ldr	r5, .L4
  40 0004 2C78     		ldrb	r4, [r5]	@ zero_extendqisi2
  41              	.LVL0:
  42              	.L2:
  43              		.loc 1 394 0 is_stmt 0 discriminator 1
  44 0006 95F84230 		ldrb	r3, [r5, #66]	@ zero_extendqisi2
  45 000a A342     		cmp	r3, r4
  46 000c 00D1     		bne	.L3
  47              	.LBE37:
 395:tmk_core/common/action_tapping.c ****         debug("[");
 396:tmk_core/common/action_tapping.c ****         debug_dec(i);
 397:tmk_core/common/action_tapping.c ****         debug("]=");
 398:tmk_core/common/action_tapping.c ****         debug_record(waiting_buffer[i]);
 399:tmk_core/common/action_tapping.c ****         debug(" ");
 400:tmk_core/common/action_tapping.c ****     }
 401:tmk_core/common/action_tapping.c ****     debug("}\n");
 402:tmk_core/common/action_tapping.c **** }
  48              		.loc 1 402 0 is_stmt 1
  49 000e 38BD     		pop	{r3, r4, r5, pc}
  50              	.LVL1:
  51              	.L3:
  52              	.LBB38:
 398:tmk_core/common/action_tapping.c ****         debug(" ");
  53              		.loc 1 398 0 discriminator 3
  54 0010 05EBC403 		add	r3, r5, r4, lsl #3
 394:tmk_core/common/action_tapping.c ****         debug("[");
  55              		.loc 1 394 0 discriminator 3
  56 0014 0134     		adds	r4, r4, #1
  57              	.LVL2:
 398:tmk_core/common/action_tapping.c ****         debug(" ");
  58              		.loc 1 398 0 discriminator 3
  59 0016 D3F80200 		ldr	r0, [r3, #2]	@ unaligned
  60 001a D3F80610 		ldr	r1, [r3, #6]	@ unaligned
  61 001e FFF7FEFF 		bl	debug_record
  62              	.LVL3:
 394:tmk_core/common/action_tapping.c ****         debug("[");
  63              		.loc 1 394 0 discriminator 3
  64 0022 04F00704 		and	r4, r4, #7
  65              	.LVL4:
  66 0026 EEE7     		b	.L2
  67              	.L5:
  68              		.align	2
  69              	.L4:
  70 0028 00000000 		.word	.LANCHOR0
  71              	.LBE38:
  72              		.cfi_endproc
  73              	.LFE14:
  75              		.section	.text.debug_tapping_key,"ax",%progbits
  76              		.align	1
  77              		.syntax unified
  78              		.thumb
  79              		.thumb_func
  80              		.fpu fpv4-sp-d16
  82              	debug_tapping_key:
  83              	.LFB13:
 382:tmk_core/common/action_tapping.c ****     debug("TAPPING_KEY=");
  84              		.loc 1 382 0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              		@ link register save eliminated.
 384:tmk_core/common/action_tapping.c ****     debug("\n");
  89              		.loc 1 384 0
  90 0000 024B     		ldr	r3, .L7
  91 0002 586C     		ldr	r0, [r3, #68]	@ unaligned
  92 0004 996C     		ldr	r1, [r3, #72]	@ unaligned
  93 0006 FFF7FEBF 		b	debug_record
  94              	.LVL5:
  95              	.L8:
  96 000a 00BF     		.align	2
  97              	.L7:
  98 000c 00000000 		.word	.LANCHOR0
  99              		.cfi_endproc
 100              	.LFE13:
 102              		.section	.text.waiting_buffer_scan_tap,"ax",%progbits
 103              		.align	1
 104              		.syntax unified
 105              		.thumb
 106              		.thumb_func
 107              		.fpu fpv4-sp-d16
 109              	waiting_buffer_scan_tap:
 110              	.LFB12:
 357:tmk_core/common/action_tapping.c ****     // tapping already is settled
 111              		.loc 1 357 0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 8
 114              		@ frame_needed = 0, uses_anonymous_args = 0
 115 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 116              		.cfi_def_cfa_offset 32
 117              		.cfi_offset 4, -20
 118              		.cfi_offset 5, -16
 119              		.cfi_offset 6, -12
 120              		.cfi_offset 7, -8
 121              		.cfi_offset 14, -4
 359:tmk_core/common/action_tapping.c ****     // invalid state: tapping_key released && tap.count == 0
 122              		.loc 1 359 0
 123 0002 284B     		ldr	r3, .L28
 124 0004 93F84A20 		ldrb	r2, [r3, #74]	@ zero_extendqisi2
 125 0008 12F0F00F 		tst	r2, #240
 126 000c 09D1     		bne	.L9
 361:tmk_core/common/action_tapping.c **** 
 127              		.loc 1 361 0
 128 000e 93F84620 		ldrb	r2, [r3, #70]	@ zero_extendqisi2
 129 0012 32B1     		cbz	r2, .L9
 130              	.LBB39:
 363:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 131              		.loc 1 363 0
 132 0014 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 133              	.LVL6:
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 134              		.loc 1 364 0
 135 0016 4FF6FF75 		movw	r5, #65535
 136              	.L13:
 363:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 137              		.loc 1 363 0 discriminator 1
 138 001a 93F84220 		ldrb	r2, [r3, #66]	@ zero_extendqisi2
 139 001e 8A42     		cmp	r2, r1
 140 0020 01D1     		bne	.L17
 141              	.LVL7:
 142              	.L9:
 143              	.LBE39:
 376:tmk_core/common/action_tapping.c **** 
 144              		.loc 1 376 0
 145 0022 03B0     		add	sp, sp, #12
 146              		.cfi_remember_state
 147              		.cfi_def_cfa_offset 20
 148              		@ sp needed
 149 0024 F0BD     		pop	{r4, r5, r6, r7, pc}
 150              	.LVL8:
 151              	.L17:
 152              		.cfi_restore_state
 153              	.LBB42:
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 154              		.loc 1 364 0
 155 0026 B3F84820 		ldrh	r2, [r3, #72]
 156              	.LBB40:
 157              	.LBB41:
 158              		.file 2 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 159              		.loc 2 48 0
 160 002a 002A     		cmp	r2, #0
 161 002c 35D0     		beq	.L14
 162 002e 93F84460 		ldrb	r6, [r3, #68]	@ zero_extendqisi2
 163 0032 93F84570 		ldrb	r7, [r3, #69]	@ zero_extendqisi2
 164 0036 8DF80460 		strb	r6, [sp, #4]
 165 003a 8DF80570 		strb	r7, [sp, #5]
 166              	.LBE41:
 167              	.LBE40:
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 168              		.loc 1 364 0
 169 003e BDF80400 		ldrh	r0, [sp, #4]
 170 0042 A842     		cmp	r0, r5
 171 0044 29D0     		beq	.L14
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 172              		.loc 1 364 0 is_stmt 0 discriminator 1
 173 0046 C800     		lsls	r0, r1, #3
 174 0048 1C18     		adds	r4, r3, r0
 175 004a 94F803C0 		ldrb	ip, [r4, #3]	@ zero_extendqisi2
 176 004e BC45     		cmp	ip, r7
 177 0050 23D1     		bne	.L14
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 178              		.loc 1 364 0 discriminator 2
 179 0052 A778     		ldrb	r7, [r4, #2]	@ zero_extendqisi2
 180 0054 B742     		cmp	r7, r6
 181 0056 20D1     		bne	.L14
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 182              		.loc 1 364 0 discriminator 3
 183 0058 2679     		ldrb	r6, [r4, #4]	@ zero_extendqisi2
 184 005a F6B9     		cbnz	r6, .L14
 364:tmk_core/common/action_tapping.c ****             tapping_key.tap.count       = 1;
 185              		.loc 1 364 0 discriminator 4
 186 005c E488     		ldrh	r4, [r4, #6]
 187 005e 9442     		cmp	r4, r2
 188 0060 36BF     		itet	cc
 189 0062 AA1A     		subcc	r2, r5, r2
 190 0064 A21A     		subcs	r2, r4, r2
 191 0066 1219     		addcc	r2, r2, r4
 192 0068 C72A     		cmp	r2, #199
 193 006a CCBF     		ite	gt
 194 006c 0022     		movgt	r2, #0
 195 006e 0122     		movle	r2, #1
 196 0070 9AB1     		cbz	r2, .L14
 365:tmk_core/common/action_tapping.c ****             waiting_buffer[i].tap.count = 1;
 197              		.loc 1 365 0 is_stmt 1
 198 0072 93F84A20 		ldrb	r2, [r3, #74]	@ zero_extendqisi2
 199 0076 0121     		movs	r1, #1
 200              	.LVL9:
 201 0078 61F30712 		bfi	r2, r1, #4, #4
 202 007c 83F84A20 		strb	r2, [r3, #74]
 366:tmk_core/common/action_tapping.c ****             process_record(&tapping_key);
 203              		.loc 1 366 0
 204 0080 0344     		add	r3, r3, r0
 367:tmk_core/common/action_tapping.c **** 
 205              		.loc 1 367 0
 206 0082 0948     		ldr	r0, .L28+4
 366:tmk_core/common/action_tapping.c ****             process_record(&tapping_key);
 207              		.loc 1 366 0
 208 0084 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 209 0086 61F30712 		bfi	r2, r1, #4, #4
 210 008a 1A72     		strb	r2, [r3, #8]
 367:tmk_core/common/action_tapping.c **** 
 211              		.loc 1 367 0
 212 008c FFF7FEFF 		bl	process_record
 213              	.LVL10:
 214              	.LBE42:
 376:tmk_core/common/action_tapping.c **** 
 215              		.loc 1 376 0
 216 0090 03B0     		add	sp, sp, #12
 217              		.cfi_remember_state
 218              		.cfi_def_cfa_offset 20
 219              		@ sp needed
 220 0092 BDE8F040 		pop	{r4, r5, r6, r7, lr}
 221              		.cfi_restore 14
 222              		.cfi_restore 7
 223              		.cfi_restore 6
 224              		.cfi_restore 5
 225              		.cfi_restore 4
 226              		.cfi_def_cfa_offset 0
 227              	.LBB43:
 372:tmk_core/common/action_tapping.c ****             return;
 228              		.loc 1 372 0
 229 0096 FFF7FEBF 		b	debug_waiting_buffer
 230              	.LVL11:
 231              	.L14:
 232              		.cfi_restore_state
 363:tmk_core/common/action_tapping.c ****         if (IS_TAPPING_KEY(waiting_buffer[i].event.key) && !waiting_buffer[i].event.pressed && WITH
 233              		.loc 1 363 0
 234 009a 0131     		adds	r1, r1, #1
 235              	.LVL12:
 236 009c 01F00701 		and	r1, r1, #7
 237              	.LVL13:
 238 00a0 BBE7     		b	.L13
 239              	.L29:
 240 00a2 00BF     		.align	2
 241              	.L28:
 242 00a4 00000000 		.word	.LANCHOR0
 243 00a8 44000000 		.word	.LANCHOR0+68
 244              	.LBE43:
 245              		.cfi_endproc
 246              	.LFE12:
 248              		.section	.text.process_tapping,"ax",%progbits
 249              		.align	1
 250              		.syntax unified
 251              		.thumb
 252              		.thumb_func
 253              		.fpu fpv4-sp-d16
 255              	process_tapping:
 256              	.LFB7:
  91:tmk_core/common/action_tapping.c ****     keyevent_t event = keyp->event;
 257              		.loc 1 91 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 56
 260              		@ frame_needed = 0, uses_anonymous_args = 0
 261              	.LVL14:
 262 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 263              		.cfi_def_cfa_offset 32
 264              		.cfi_offset 4, -32
 265              		.cfi_offset 5, -28
 266              		.cfi_offset 6, -24
 267              		.cfi_offset 7, -20
 268              		.cfi_offset 8, -16
 269              		.cfi_offset 9, -12
 270              		.cfi_offset 10, -8
 271              		.cfi_offset 14, -4
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 272              		.loc 1 95 0
 273 0004 AD4C     		ldr	r4, .L124
  91:tmk_core/common/action_tapping.c ****     keyevent_t event = keyp->event;
 274              		.loc 1 91 0
 275 0006 0546     		mov	r5, r0
 276 0008 8EB0     		sub	sp, sp, #56
 277              		.cfi_def_cfa_offset 88
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 278              		.loc 1 95 0
 279 000a B4F84870 		ldrh	r7, [r4, #72]
  92:tmk_core/common/action_tapping.c **** 
 280              		.loc 1 92 0
 281 000e 0068     		ldr	r0, [r0]	@ unaligned
 282              	.LVL15:
 283 0010 B4F84410 		ldrh	r1, [r4, #68]
 284 0014 0890     		str	r0, [sp, #32]
 285 0016 0DF1200C 		add	ip, sp, #32
 286 001a 2A78     		ldrb	r2, [r5]	@ zero_extendqisi2
 287              	.LVL16:
 288 001c 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 289              	.LVL17:
 290 001e 95F80280 		ldrb	r8, [r5, #2]	@ zero_extendqisi2
 291              	.LVL18:
 292 0022 B5F80490 		ldrh	r9, [r5, #4]
 293              	.LVL19:
 294 0026 ADF80410 		strh	r1, [sp, #4]	@ movhi
 295 002a 94F844E0 		ldrb	lr, [r4, #68]	@ zero_extendqisi2
 296 002e 94F84500 		ldrb	r0, [r4, #69]	@ zero_extendqisi2
 297              	.LBB64:
 298              	.LBB65:
 299              		.loc 2 48 0
 300 0032 002F     		cmp	r7, #0
 301 0034 00F04681 		beq	.L31
 302              	.LBE65:
 303              	.LBE64:
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 304              		.loc 1 95 0
 305 0038 8EB2     		uxth	r6, r1
 306 003a 4FF6FF71 		movw	r1, #65535
 307 003e 8E42     		cmp	r6, r1
 308 0040 00F04081 		beq	.L31
  95:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 309              		.loc 1 95 0 is_stmt 0 discriminator 1
 310 0044 94F84660 		ldrb	r6, [r4, #70]	@ zero_extendqisi2
 311 0048 002E     		cmp	r6, #0
 312 004a 00F03B81 		beq	.L31
  96:tmk_core/common/action_tapping.c ****             if (tapping_key.tap.count == 0) {
 313              		.loc 1 96 0 is_stmt 1
 314 004e 4F45     		cmp	r7, r9
 315 0050 8ABF     		itet	hi
 316 0052 CF1B     		subhi	r7, r1, r7
 317 0054 A9EB0707 		subls	r7, r9, r7
 318 0058 4F44     		addhi	r7, r7, r9
 319 005a C72F     		cmp	r7, #199
 320 005c 94F84A10 		ldrb	r1, [r4, #74]	@ zero_extendqisi2
 321 0060 CCBF     		ite	gt
 322 0062 0027     		movgt	r7, #0
 323 0064 0127     		movle	r7, #1
 324 0066 01F0F00A 		and	r10, r1, #240
 325 006a 002F     		cmp	r7, #0
 326 006c 00F0D080 		beq	.L34
  97:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key) && !event.pressed) {
 327              		.loc 1 97 0
 328 0070 BAF1000F 		cmp	r10, #0
 329 0074 7DD1     		bne	.L35
 330              	.LBB66:
 331              	.LBB67:
 332              		.loc 2 48 0
 333 0076 8DF80900 		strb	r0, [sp, #9]
 334 007a 8DF808E0 		strb	lr, [sp, #8]
 335              	.LBE67:
 336              	.LBE66:
  98:tmk_core/common/action_tapping.c ****                     // first tap!
 337              		.loc 1 98 0
 338 007e BDF808C0 		ldrh	ip, [sp, #8]
 339 0082 4FF6FF70 		movw	r0, #65535
 340 0086 8445     		cmp	ip, r0
 341 0088 4646     		mov	r6, r8
 342 008a 1BD0     		beq	.L36
  98:tmk_core/common/action_tapping.c ****                     // first tap!
 343              		.loc 1 98 0 is_stmt 0 discriminator 1
 344 008c 8DF82020 		strb	r2, [sp, #32]
 345 0090 8DF82130 		strb	r3, [sp, #33]
 346 0094 B4F84400 		ldrh	r0, [r4, #68]
 347 0098 BDF820C0 		ldrh	ip, [sp, #32]
 348 009c 8445     		cmp	ip, r0
 349 009e 11D1     		bne	.L36
  98:tmk_core/common/action_tapping.c ****                     // first tap!
 350              		.loc 1 98 0 discriminator 2
 351 00a0 86B9     		cbnz	r6, .L36
 101:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 352              		.loc 1 101 0 is_stmt 1
 353 00a2 0123     		movs	r3, #1
 354              	.LVL20:
 355 00a4 63F30711 		bfi	r1, r3, #4, #4
 356 00a8 84F84A10 		strb	r1, [r4, #74]
 102:tmk_core/common/action_tapping.c ****                     process_record(&tapping_key);
 357              		.loc 1 102 0
 358 00ac FFF7FEFF 		bl	debug_tapping_key
 359              	.LVL21:
 103:tmk_core/common/action_tapping.c **** 
 360              		.loc 1 103 0
 361 00b0 8348     		ldr	r0, .L124+4
 362 00b2 FFF7FEFF 		bl	process_record
 363              	.LVL22:
 106:tmk_core/common/action_tapping.c ****                     // enqueue
 364              		.loc 1 106 0
 365 00b6 94F84A30 		ldrb	r3, [r4, #74]	@ zero_extendqisi2
 366 00ba AB71     		strb	r3, [r5, #6]
 367              	.LVL23:
 368              	.L67:
 296:tmk_core/common/action_tapping.c **** 
 369              		.loc 1 296 0
 370 00bc 3046     		mov	r0, r6
 371              	.LVL24:
 372 00be 0EB0     		add	sp, sp, #56
 373              		.cfi_remember_state
 374              		.cfi_def_cfa_offset 32
 375              		@ sp needed
 376 00c0 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 377              	.LVL25:
 378              	.L36:
 379              		.cfi_restore_state
 380              	.LBB68:
 381              	.LBB69:
 382              	.LBB70:
 383              	.LBB71:
 384              		.loc 2 48 0
 385 00c4 B9F1000F 		cmp	r9, #0
 386 00c8 0AD1     		bne	.L38
 387              	.L40:
 388              	.LBE71:
 389              	.LBE70:
 390              	.LBE69:
 391              	.LBE68:
 154:tmk_core/common/action_tapping.c ****                         tapping_key.tap.interrupted = true;
 392              		.loc 1 154 0
 393 00ca B8F1000F 		cmp	r8, #0
 394 00ce F5D0     		beq	.L67
 395              	.L39:
 155:tmk_core/common/action_tapping.c ****                     }
 396              		.loc 1 155 0
 397 00d0 94F84A30 		ldrb	r3, [r4, #74]	@ zero_extendqisi2
 398              	.LVL26:
 399 00d4 43F00103 		orr	r3, r3, #1
 400 00d8 84F84A30 		strb	r3, [r4, #74]
 401              	.LVL27:
 402              	.L122:
 158:tmk_core/common/action_tapping.c ****                 }
 403              		.loc 1 158 0
 404 00dc 0026     		movs	r6, #0
 405 00de EDE7     		b	.L67
 406              	.LVL28:
 407              	.L38:
 408              	.LBB75:
 409              	.LBB74:
 410              	.LBB73:
 411              	.LBB72:
 412              		.loc 2 48 0
 413 00e0 8DF81C20 		strb	r2, [sp, #28]
 414 00e4 8DF81D30 		strb	r3, [sp, #29]
 415              	.LBE72:
 416              	.LBE73:
  49:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  50:tmk_core/common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
 417              		.loc 2 50 0
 418 00e8 BDF81C00 		ldrh	r0, [sp, #28]
 419 00ec 4FF6FF71 		movw	r1, #65535
 420 00f0 8842     		cmp	r0, r1
 421 00f2 EAD0     		beq	.L40
 422              	.LBE74:
 423              	.LBE75:
 133:tmk_core/common/action_tapping.c ****                     // Modifier should be retained till end of this tapping.
 424              		.loc 1 133 0
 425 00f4 B8F1000F 		cmp	r8, #0
 426 00f8 EAD1     		bne	.L39
 427              	.LBB76:
 428              	.LBB77:
 334:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 429              		.loc 1 334 0
 430 00fa 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 431              	.LVL29:
 432 00fc 94F842C0 		ldrb	ip, [r4, #66]	@ zero_extendqisi2
 433              	.L41:
 434 0100 6145     		cmp	r1, ip
 435 0102 0FD1     		bne	.L43
 436              	.LVL30:
 437              	.LBE77:
 438              	.LBE76:
 439              	.LBB79:
 135:tmk_core/common/action_tapping.c ****                     switch (action.kind.id) {
 440              		.loc 1 135 0
 441 0104 8DF82020 		strb	r2, [sp, #32]
 442 0108 8DF82130 		strb	r3, [sp, #33]
 443 010c 0898     		ldr	r0, [sp, #32]
 444 010e FFF7FEFF 		bl	layer_switch_get_action
 445              	.LVL31:
 136:tmk_core/common/action_tapping.c ****                         case ACT_LMODS:
 446              		.loc 1 136 0
 447 0112 C0F30332 		ubfx	r2, r0, #12, #4
 135:tmk_core/common/action_tapping.c ****                     switch (action.kind.id) {
 448              		.loc 1 135 0
 449 0116 C3B2     		uxtb	r3, r0
 450              	.LVL32:
 136:tmk_core/common/action_tapping.c ****                         case ACT_LMODS:
 451              		.loc 1 136 0
 452 0118 032A     		cmp	r2, #3
 453 011a 1DD8     		bhi	.L48
 454 011c DFE802F0 		tbb	[pc, r2]
 455              	.L66:
 456 0120 13       		.byte	(.L45-.L66)/2
 457 0121 13       		.byte	(.L45-.L66)/2
 458 0122 21       		.byte	(.L49-.L66)/2
 459 0123 21       		.byte	(.L49-.L66)/2
 460              	.LVL33:
 461              		.p2align 1
 462              	.L43:
 463              	.LBE79:
 464              	.LBB80:
 465              	.LBB78:
 335:tmk_core/common/action_tapping.c ****             return true;
 466              		.loc 1 335 0
 467 0124 04EBC100 		add	r0, r4, r1, lsl #3
 468 0128 90F803E0 		ldrb	lr, [r0, #3]	@ zero_extendqisi2
 469 012c 9E45     		cmp	lr, r3
 470 012e 06D1     		bne	.L42
 471 0130 90F802E0 		ldrb	lr, [r0, #2]	@ zero_extendqisi2
 472 0134 9645     		cmp	lr, r2
 473 0136 02D1     		bne	.L42
 474 0138 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 475 013a 0028     		cmp	r0, #0
 476 013c BED1     		bne	.L67
 477              	.L42:
 334:tmk_core/common/action_tapping.c ****         if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed != waiting_buffer[i].eve
 478              		.loc 1 334 0
 479 013e 0131     		adds	r1, r1, #1
 480              	.LVL34:
 481 0140 01F00701 		and	r1, r1, #7
 482              	.LVL35:
 483 0144 DCE7     		b	.L41
 484              	.LVL36:
 485              	.L45:
 486              	.LBE78:
 487              	.LBE80:
 488              	.LBB81:
 139:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 489              		.loc 1 139 0
 490 0146 10F4706F 		tst	r0, #3840
 491 014a 01D0     		beq	.L50
 139:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 492              		.loc 1 139 0 is_stmt 0 discriminator 1
 493 014c 002B     		cmp	r3, #0
 494 014e B5D0     		beq	.L67
 495              	.L50:
 145:tmk_core/common/action_tapping.c ****                             break;
 496              		.loc 1 145 0 is_stmt 1
 497 0150 2033     		adds	r3, r3, #32
 498              	.LVL37:
 499 0152 DBB2     		uxtb	r3, r3
 500              	.LVL38:
 501 0154 072B     		cmp	r3, #7
 502 0156 B1D9     		bls	.L67
 503              	.L48:
 150:tmk_core/common/action_tapping.c ****                     return true;
 504              		.loc 1 150 0
 505 0158 2846     		mov	r0, r5
 506              	.LVL39:
 507 015a FFF7FEFF 		bl	process_record
 508              	.LVL40:
 509              	.L121:
 510              	.LBE81:
 171:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 511              		.loc 1 171 0
 512 015e 3E46     		mov	r6, r7
 513 0160 ACE7     		b	.L67
 514              	.LVL41:
 515              	.L49:
 516              	.LBB82:
 144:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 517              		.loc 1 144 0
 518 0162 10F4706F 		tst	r0, #3840
 519 0166 F3D0     		beq	.L50
 144:tmk_core/common/action_tapping.c ****                             if (IS_MOD(action.key.code)) return false;
 520              		.loc 1 144 0 is_stmt 0 discriminator 1
 521 0168 AA79     		ldrb	r2, [r5, #6]	@ zero_extendqisi2
 522 016a 12F0F00F 		tst	r2, #240
 523 016e EFD1     		bne	.L50
 524 0170 A4E7     		b	.L67
 525              	.LVL42:
 526              	.L35:
 527              	.LBE82:
 528              	.LBB83:
 529              	.LBB84:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 530              		.loc 2 48 0 is_stmt 1
 531 0172 8DF80D00 		strb	r0, [sp, #13]
 532 0176 8DF80CE0 		strb	lr, [sp, #12]
 533              	.LBE84:
 534              	.LBE83:
 163:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 535              		.loc 1 163 0
 536 017a BDF80C60 		ldrh	r6, [sp, #12]
 537 017e 4FF6FF70 		movw	r0, #65535
 538 0182 8642     		cmp	r6, r0
 539 0184 18D0     		beq	.L51
 163:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 540              		.loc 1 163 0 is_stmt 0 discriminator 1
 541 0186 8DF82020 		strb	r2, [sp, #32]
 542 018a 8DF82130 		strb	r3, [sp, #33]
 543 018e B4F84400 		ldrh	r0, [r4, #68]
 544              	.LVL43:
 545 0192 BDF82060 		ldrh	r6, [sp, #32]
 546 0196 8642     		cmp	r6, r0
 547 0198 0ED1     		bne	.L51
 548              	.LVL44:
 163:tmk_core/common/action_tapping.c ****                     debug("Tapping: Tap release(");
 549              		.loc 1 163 0 discriminator 2
 550 019a B8F1000F 		cmp	r8, #0
 551 019e 0BD1     		bne	.L51
 167:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 552              		.loc 1 167 0 is_stmt 1
 553 01a0 A971     		strb	r1, [r5, #6]
 168:tmk_core/common/action_tapping.c ****                     tapping_key = *keyp;
 554              		.loc 1 168 0
 555 01a2 2846     		mov	r0, r5
 556 01a4 FFF7FEFF 		bl	process_record
 557              	.LVL45:
 169:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 558              		.loc 1 169 0
 559 01a8 2B68     		ldr	r3, [r5]	@ unaligned
 560 01aa 6364     		str	r3, [r4, #68]	@ unaligned
 561 01ac 444A     		ldr	r2, .L124+4
 562 01ae 6B68     		ldr	r3, [r5, #4]	@ unaligned
 563 01b0 5360     		str	r3, [r2, #4]	@ unaligned
 170:tmk_core/common/action_tapping.c ****                     return true;
 564              		.loc 1 170 0
 565 01b2 FFF7FEFF 		bl	debug_tapping_key
 566              	.LVL46:
 567 01b6 D2E7     		b	.L121
 568              	.LVL47:
 569              	.L51:
 172:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 570              		.loc 1 172 0
 571 01b8 8DF82020 		strb	r2, [sp, #32]
 572 01bc 8DF82130 		strb	r3, [sp, #33]
 573 01c0 0898     		ldr	r0, [sp, #32]
 574 01c2 FFF7FEFF 		bl	is_tap_key
 575              	.LVL48:
 576 01c6 F8B1     		cbz	r0, .L62
 172:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 577              		.loc 1 172 0 is_stmt 0 discriminator 1
 578 01c8 B8F1000F 		cmp	r8, #0
 579 01cc 1CD0     		beq	.L62
 173:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last tap(>1).\n");
 580              		.loc 1 173 0 is_stmt 1
 581 01ce 94F84A30 		ldrb	r3, [r4, #74]	@ zero_extendqisi2
 582 01d2 1F2B     		cmp	r3, #31
 583 01d4 0DD9     		bls	.L54
 176:tmk_core/common/action_tapping.c ****                     } else {
 584              		.loc 1 176 0
 585 01d6 B4F84420 		ldrh	r2, [r4, #68]
 586 01da ADF82820 		strh	r2, [sp, #40]	@ movhi
 587 01de 0022     		movs	r2, #0
 588 01e0 8DF82A20 		strb	r2, [sp, #42]
 589 01e4 ADF82C90 		strh	r9, [sp, #44]	@ movhi
 590 01e8 8DF82E30 		strb	r3, [sp, #46]
 591 01ec 0AA8     		add	r0, sp, #40
 592              	.L118:
 593 01ee FFF7FEFF 		bl	process_record
 594              	.LVL49:
 595              	.L54:
 180:tmk_core/common/action_tapping.c ****                     waiting_buffer_scan_tap();
 596              		.loc 1 180 0
 597 01f2 2B68     		ldr	r3, [r5]	@ unaligned
 598 01f4 324A     		ldr	r2, .L124+4
 599 01f6 6364     		str	r3, [r4, #68]	@ unaligned
 600 01f8 6B68     		ldr	r3, [r5, #4]	@ unaligned
 601 01fa 5360     		str	r3, [r2, #4]	@ unaligned
 181:tmk_core/common/action_tapping.c ****                     debug_tapping_key();
 602              		.loc 1 181 0
 603 01fc FFF7FEFF 		bl	waiting_buffer_scan_tap
 604              	.LVL50:
 182:tmk_core/common/action_tapping.c ****                     return true;
 605              		.loc 1 182 0
 606 0200 FFF7FEFF 		bl	debug_tapping_key
 607              	.LVL51:
 608              	.L123:
 189:tmk_core/common/action_tapping.c ****                 }
 609              		.loc 1 189 0
 610 0204 0126     		movs	r6, #1
 611 0206 59E7     		b	.L67
 612              	.L62:
 188:tmk_core/common/action_tapping.c ****                     return true;
 613              		.loc 1 188 0
 614 0208 2846     		mov	r0, r5
 615 020a FFF7FEFF 		bl	process_record
 616              	.LVL52:
 617 020e F9E7     		b	.L123
 618              	.LVL53:
 619              	.L34:
 195:tmk_core/common/action_tapping.c ****                 debug("Tapping: End. Timeout. Not tap(0): ");
 620              		.loc 1 195 0
 621 0210 BAF1000F 		cmp	r10, #0
 622 0214 14D1     		bne	.L55
 197:tmk_core/common/action_tapping.c ****                 debug("\n");
 623              		.loc 1 197 0
 624 0216 8DF82020 		strb	r2, [sp, #32]
 625 021a 8DF82130 		strb	r3, [sp, #33]
 626 021e 8DF82280 		strb	r8, [sp, #34]
 627 0222 ADF82490 		strh	r9, [sp, #36]	@ movhi
 199:tmk_core/common/action_tapping.c ****                 tapping_key = (keyrecord_t){};
 628              		.loc 1 199 0
 629 0226 264D     		ldr	r5, .L124+4
 630              	.LVL54:
 197:tmk_core/common/action_tapping.c ****                 debug("\n");
 631              		.loc 1 197 0
 632 0228 9CE80300 		ldm	ip, {r0, r1}
 633 022c FFF7FEFF 		bl	debug_event
 634              	.LVL55:
 199:tmk_core/common/action_tapping.c ****                 tapping_key = (keyrecord_t){};
 635              		.loc 1 199 0
 636 0230 2846     		mov	r0, r5
 637 0232 FFF7FEFF 		bl	process_record
 638              	.LVL56:
 200:tmk_core/common/action_tapping.c ****                 debug_tapping_key();
 639              		.loc 1 200 0
 640 0236 6764     		str	r7, [r4, #68]	@ unaligned
 641 0238 6F60     		str	r7, [r5, #4]	@ unaligned
 201:tmk_core/common/action_tapping.c ****                 return false;
 642              		.loc 1 201 0
 643 023a FFF7FEFF 		bl	debug_tapping_key
 644              	.LVL57:
 645 023e 4DE7     		b	.L122
 646              	.LVL58:
 647              	.L55:
 648              	.LBB85:
 649              	.LBB86:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 650              		.loc 2 48 0
 651 0240 8DF81100 		strb	r0, [sp, #17]
 652 0244 8DF810E0 		strb	lr, [sp, #16]
 653              	.LBE86:
 654              	.LBE85:
 204:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 655              		.loc 1 204 0
 656 0248 BDF81070 		ldrh	r7, [sp, #16]
 657 024c 4FF6FF70 		movw	r0, #65535
 658 0250 8742     		cmp	r7, r0
 659 0252 16D0     		beq	.L56
 204:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 660              		.loc 1 204 0 is_stmt 0 discriminator 1
 661 0254 8DF82020 		strb	r2, [sp, #32]
 662 0258 8DF82130 		strb	r3, [sp, #33]
 663 025c B4F84400 		ldrh	r0, [r4, #68]
 664              	.LVL59:
 665 0260 BDF82070 		ldrh	r7, [sp, #32]
 666 0264 8742     		cmp	r7, r0
 667 0266 0CD1     		bne	.L56
 668              	.LVL60:
 204:tmk_core/common/action_tapping.c ****                     debug("Tapping: End. last timeout tap release(>0).");
 669              		.loc 1 204 0 discriminator 2
 670 0268 B8F1000F 		cmp	r8, #0
 671 026c 09D1     		bne	.L56
 206:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 672              		.loc 1 206 0 is_stmt 1
 673 026e A971     		strb	r1, [r5, #6]
 207:tmk_core/common/action_tapping.c ****                     tapping_key = (keyrecord_t){};
 674              		.loc 1 207 0
 675 0270 2846     		mov	r0, r5
 676 0272 FFF7FEFF 		bl	process_record
 677              	.LVL61:
 208:tmk_core/common/action_tapping.c ****                     return true;
 678              		.loc 1 208 0
 679 0276 124B     		ldr	r3, .L124+4
 680 0278 C4F84480 		str	r8, [r4, #68]	@ unaligned
 681 027c C3F80480 		str	r8, [r3, #4]	@ unaligned
 209:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key) && event.pressed) {
 682              		.loc 1 209 0
 683 0280 1CE7     		b	.L67
 684              	.LVL62:
 685              	.L56:
 210:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 686              		.loc 1 210 0
 687 0282 8DF82020 		strb	r2, [sp, #32]
 688 0286 8DF82130 		strb	r3, [sp, #33]
 689 028a 0898     		ldr	r0, [sp, #32]
 690 028c FFF7FEFF 		bl	is_tap_key
 691              	.LVL63:
 692 0290 0028     		cmp	r0, #0
 693 0292 B9D0     		beq	.L62
 210:tmk_core/common/action_tapping.c ****                     if (tapping_key.tap.count > 1) {
 694              		.loc 1 210 0 is_stmt 0 discriminator 1
 695 0294 B8F1000F 		cmp	r8, #0
 696 0298 B6D0     		beq	.L62
 211:tmk_core/common/action_tapping.c ****                         debug("Tapping: Start new tap with releasing last timeout tap(>1).\n");
 697              		.loc 1 211 0 is_stmt 1
 698 029a 94F84A30 		ldrb	r3, [r4, #74]	@ zero_extendqisi2
 699 029e 1F2B     		cmp	r3, #31
 700 02a0 A7D9     		bls	.L54
 214:tmk_core/common/action_tapping.c ****                     } else {
 701              		.loc 1 214 0
 702 02a2 B4F84420 		ldrh	r2, [r4, #68]
 703 02a6 ADF83020 		strh	r2, [sp, #48]	@ movhi
 704 02aa 0022     		movs	r2, #0
 705 02ac 8DF83220 		strb	r2, [sp, #50]
 706 02b0 ADF83490 		strh	r9, [sp, #52]	@ movhi
 707 02b4 8DF83630 		strb	r3, [sp, #54]
 708 02b8 0CA8     		add	r0, sp, #48
 709 02ba 98E7     		b	.L118
 710              	.L125:
 711              		.align	2
 712              	.L124:
 713 02bc 00000000 		.word	.LANCHOR0
 714 02c0 44000000 		.word	.LANCHOR0+68
 715              	.LVL64:
 716              	.L31:
 717              	.LBB87:
 718              	.LBB88:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 719              		.loc 2 48 0
 720 02c4 002F     		cmp	r7, #0
 721 02c6 7AD0     		beq	.L58
 722 02c8 8DF814E0 		strb	lr, [sp, #20]
 723 02cc 8DF81500 		strb	r0, [sp, #21]
 724              	.LBE88:
 725              	.LBE87:
 231:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 726              		.loc 1 231 0
 727 02d0 BDF81410 		ldrh	r1, [sp, #20]
 728 02d4 4FF6FF76 		movw	r6, #65535
 729 02d8 B142     		cmp	r1, r6
 730 02da 70D0     		beq	.L58
 231:tmk_core/common/action_tapping.c ****         if (WITHIN_TAPPING_TERM(event)) {
 731              		.loc 1 231 0 is_stmt 0 discriminator 1
 732 02dc 94F84610 		ldrb	r1, [r4, #70]	@ zero_extendqisi2
 733 02e0 0029     		cmp	r1, #0
 734 02e2 6CD1     		bne	.L58
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 735              		.loc 1 232 0 is_stmt 1
 736 02e4 4F45     		cmp	r7, r9
 737 02e6 3DD8     		bhi	.L59
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 738              		.loc 1 232 0 is_stmt 0 discriminator 1
 739 02e8 A9EB0707 		sub	r7, r9, r7
 740 02ec C72F     		cmp	r7, #199
 741              	.L119:
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 742              		.loc 1 232 0 discriminator 2
 743 02ee CCBF     		ite	gt
 744 02f0 0026     		movgt	r6, #0
 745 02f2 0126     		movle	r6, #1
 746 02f4 002E     		cmp	r6, #0
 747 02f6 52D0     		beq	.L61
 233:tmk_core/common/action_tapping.c ****                 if (IS_TAPPING_KEY(event.key)) {
 748              		.loc 1 233 0 is_stmt 1
 749 02f8 4646     		mov	r6, r8
 750 02fa 002E     		cmp	r6, #0
 751 02fc 84D0     		beq	.L62
 752              	.LBB89:
 753              	.LBB90:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 754              		.loc 2 48 0
 755 02fe 8DF818E0 		strb	lr, [sp, #24]
 756 0302 8DF81900 		strb	r0, [sp, #25]
 757              	.LBE90:
 758              	.LBE89:
 234:tmk_core/common/action_tapping.c **** #    ifndef TAPPING_FORCE_HOLD
 759              		.loc 1 234 0
 760 0306 BDF81800 		ldrh	r0, [sp, #24]
 761 030a 4FF6FF71 		movw	r1, #65535
 762 030e 8842     		cmp	r0, r1
 763 0310 31D0     		beq	.L63
 234:tmk_core/common/action_tapping.c **** #    ifndef TAPPING_FORCE_HOLD
 764              		.loc 1 234 0 is_stmt 0 discriminator 1
 765 0312 8DF82020 		strb	r2, [sp, #32]
 766 0316 8DF82130 		strb	r3, [sp, #33]
 767 031a B4F84410 		ldrh	r1, [r4, #68]
 768              	.LVL65:
 769 031e BDF82000 		ldrh	r0, [sp, #32]
 770 0322 8842     		cmp	r0, r1
 771 0324 27D1     		bne	.L63
 772              	.LVL66:
 236:tmk_core/common/action_tapping.c ****                         // sequential tap.
 773              		.loc 1 236 0 is_stmt 1
 774 0326 94F84A30 		ldrb	r3, [r4, #74]	@ zero_extendqisi2
 775              	.LVL67:
 776 032a 314F     		ldr	r7, .L126
 777 032c 13F0010F 		tst	r3, #1
 778 0330 1CD1     		bne	.L64
 236:tmk_core/common/action_tapping.c ****                         // sequential tap.
 779              		.loc 1 236 0 is_stmt 0 discriminator 1
 780 0332 13F0F00F 		tst	r3, #240
 781 0336 19D0     		beq	.L64
 239:tmk_core/common/action_tapping.c ****                         debug("Tapping: Tap press(");
 782              		.loc 1 239 0 is_stmt 1
 783 0338 03F0F002 		and	r2, r3, #240
 784              	.LVL68:
 785 033c F02A     		cmp	r2, #240
 786 033e 1CBF     		itt	ne
 787 0340 C3F30312 		ubfxne	r2, r3, #4, #4
 788 0344 0132     		addne	r2, r2, #1
 238:tmk_core/common/action_tapping.c ****                         if (keyp->tap.count < 15) keyp->tap.count += 1;
 789              		.loc 1 238 0
 790 0346 AB71     		strb	r3, [r5, #6]
 239:tmk_core/common/action_tapping.c ****                         debug("Tapping: Tap press(");
 791              		.loc 1 239 0
 792 0348 1CBF     		itt	ne
 793 034a 62F30713 		bfine	r3, r2, #4, #4
 794 034e AB71     		strbne	r3, [r5, #6]
 243:tmk_core/common/action_tapping.c ****                         tapping_key = *keyp;
 795              		.loc 1 243 0
 796 0350 2846     		mov	r0, r5
 797 0352 FFF7FEFF 		bl	process_record
 798              	.LVL69:
 244:tmk_core/common/action_tapping.c ****                         debug_tapping_key();
 799              		.loc 1 244 0
 800 0356 2B68     		ldr	r3, [r5]	@ unaligned
 801 0358 6364     		str	r3, [r4, #68]	@ unaligned
 802 035a 6B68     		ldr	r3, [r5, #4]	@ unaligned
 803 035c 7B60     		str	r3, [r7, #4]	@ unaligned
 804              	.L120:
 289:tmk_core/common/action_tapping.c ****             return true;
 805              		.loc 1 289 0
 806 035e FFF7FEFF 		bl	debug_tapping_key
 807              	.LVL70:
 290:tmk_core/common/action_tapping.c ****         } else {
 808              		.loc 1 290 0
 809 0362 ABE6     		b	.L67
 810              	.LVL71:
 811              	.L59:
 232:tmk_core/common/action_tapping.c ****             if (event.pressed) {
 812              		.loc 1 232 0 discriminator 2
 813 0364 F61B     		subs	r6, r6, r7
 814 0366 4E44     		add	r6, r6, r9
 815 0368 C72E     		cmp	r6, #199
 816 036a C0E7     		b	.L119
 817              	.LVL72:
 818              	.L64:
 250:tmk_core/common/action_tapping.c ****                     return true;
 819              		.loc 1 250 0
 820 036c 2B68     		ldr	r3, [r5]	@ unaligned
 821 036e 6364     		str	r3, [r4, #68]	@ unaligned
 822 0370 6B68     		ldr	r3, [r5, #4]	@ unaligned
 823 0372 7B60     		str	r3, [r7, #4]	@ unaligned
 251:tmk_core/common/action_tapping.c ****                 } else if (is_tap_key(event.key)) {
 824              		.loc 1 251 0
 825 0374 A2E6     		b	.L67
 826              	.LVL73:
 827              	.L63:
 252:tmk_core/common/action_tapping.c ****                     // Sequential tap can be interfered with other tap key.
 828              		.loc 1 252 0
 829 0376 8DF82020 		strb	r2, [sp, #32]
 830 037a 8DF82130 		strb	r3, [sp, #33]
 831 037e 0898     		ldr	r0, [sp, #32]
 832 0380 FFF7FEFF 		bl	is_tap_key
 833              	.LVL74:
 834 0384 0028     		cmp	r0, #0
 835 0386 7FF434AF 		bne	.L54
 262:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 836              		.loc 1 262 0
 837 038a 94F84A30 		ldrb	r3, [r4, #74]	@ zero_extendqisi2
 263:tmk_core/common/action_tapping.c ****                     return true;
 838              		.loc 1 263 0
 839 038e 2846     		mov	r0, r5
 262:tmk_core/common/action_tapping.c ****                     process_record(keyp);
 840              		.loc 1 262 0
 841 0390 43F00103 		orr	r3, r3, #1
 842 0394 84F84A30 		strb	r3, [r4, #74]
 263:tmk_core/common/action_tapping.c ****                     return true;
 843              		.loc 1 263 0
 844 0398 FFF7FEFF 		bl	process_record
 845              	.LVL75:
 264:tmk_core/common/action_tapping.c ****                 }
 846              		.loc 1 264 0
 847 039c 8EE6     		b	.L67
 848              	.LVL76:
 849              	.L61:
 275:tmk_core/common/action_tapping.c ****             debug("\n");
 850              		.loc 1 275 0
 851 039e 8DF82130 		strb	r3, [sp, #33]
 852 03a2 8DF82280 		strb	r8, [sp, #34]
 853 03a6 ADF82490 		strh	r9, [sp, #36]	@ movhi
 854 03aa 8DF82020 		strb	r2, [sp, #32]
 855 03ae 9CE80300 		ldm	ip, {r0, r1}
 856 03b2 FFF7FEFF 		bl	debug_event
 857              	.LVL77:
 277:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 858              		.loc 1 277 0
 859 03b6 0E4B     		ldr	r3, .L126
 860 03b8 6664     		str	r6, [r4, #68]	@ unaligned
 861 03ba 5E60     		str	r6, [r3, #4]	@ unaligned
 862 03bc CFE7     		b	.L120
 863              	.LVL78:
 864              	.L58:
 284:tmk_core/common/action_tapping.c ****             debug("Tapping: Start(Press tap key).\n");
 865              		.loc 1 284 0
 866 03be B8F1000F 		cmp	r8, #0
 867 03c2 3FF421AF 		beq	.L62
 284:tmk_core/common/action_tapping.c ****             debug("Tapping: Start(Press tap key).\n");
 868              		.loc 1 284 0 is_stmt 0 discriminator 1
 869 03c6 8DF82020 		strb	r2, [sp, #32]
 870 03ca 8DF82130 		strb	r3, [sp, #33]
 871 03ce 0898     		ldr	r0, [sp, #32]
 872 03d0 FFF7FEFF 		bl	is_tap_key
 873              	.LVL79:
 874 03d4 0646     		mov	r6, r0
 875 03d6 0028     		cmp	r0, #0
 876 03d8 3FF416AF 		beq	.L62
 286:tmk_core/common/action_tapping.c ****             process_record_tap_hint(&tapping_key);
 877              		.loc 1 286 0 is_stmt 1
 878 03dc 2B68     		ldr	r3, [r5]	@ unaligned
 879 03de 0448     		ldr	r0, .L126
 880 03e0 6364     		str	r3, [r4, #68]	@ unaligned
 881 03e2 6B68     		ldr	r3, [r5, #4]	@ unaligned
 882 03e4 4360     		str	r3, [r0, #4]	@ unaligned
 287:tmk_core/common/action_tapping.c ****             waiting_buffer_scan_tap();
 883              		.loc 1 287 0
 884 03e6 FFF7FEFF 		bl	process_record_tap_hint
 885              	.LVL80:
 288:tmk_core/common/action_tapping.c ****             debug_tapping_key();
 886              		.loc 1 288 0
 887 03ea FFF7FEFF 		bl	waiting_buffer_scan_tap
 888              	.LVL81:
 889 03ee B6E7     		b	.L120
 890              	.L127:
 891              		.align	2
 892              	.L126:
 893 03f0 44000000 		.word	.LANCHOR0+68
 894              		.cfi_endproc
 895              	.LFE7:
 897              		.section	.text.get_tapping_term,"ax",%progbits
 898              		.align	1
 899              		.weak	get_tapping_term
 900              		.syntax unified
 901              		.thumb
 902              		.thumb_func
 903              		.fpu fpv4-sp-d16
 905              	get_tapping_term:
 906              	.LFB5:
  22:tmk_core/common/action_tapping.c **** 
 907              		.loc 1 22 0
 908              		.cfi_startproc
 909              		@ args = 0, pretend = 0, frame = 0
 910              		@ frame_needed = 0, uses_anonymous_args = 0
 911              		@ link register save eliminated.
 912              	.LVL82:
  22:tmk_core/common/action_tapping.c **** 
 913              		.loc 1 22 0
 914 0000 C820     		movs	r0, #200
 915              	.LVL83:
 916 0002 7047     		bx	lr
 917              		.cfi_endproc
 918              	.LFE5:
 920              		.section	.text.action_tapping_process,"ax",%progbits
 921              		.align	1
 922              		.global	action_tapping_process
 923              		.syntax unified
 924              		.thumb
 925              		.thumb_func
 926              		.fpu fpv4-sp-d16
 928              	action_tapping_process:
 929              	.LFB6:
  48:tmk_core/common/action_tapping.c ****     if (process_tapping(&record)) {
 930              		.loc 1 48 0
 931              		.cfi_startproc
 932              		@ args = 0, pretend = 0, frame = 24
 933              		@ frame_needed = 0, uses_anonymous_args = 0
 934 0000 70B5     		push	{r4, r5, r6, lr}
 935              		.cfi_def_cfa_offset 16
 936              		.cfi_offset 4, -16
 937              		.cfi_offset 5, -12
 938              		.cfi_offset 6, -8
 939              		.cfi_offset 14, -4
 940 0002 86B0     		sub	sp, sp, #24
 941              		.cfi_def_cfa_offset 40
  48:tmk_core/common/action_tapping.c ****     if (process_tapping(&record)) {
 942              		.loc 1 48 0
 943 0004 6D46     		mov	r5, sp
 944 0006 85E80300 		stm	r5, {r0, r1}
  49:tmk_core/common/action_tapping.c ****         if (!IS_NOEVENT(record.event)) {
 945              		.loc 1 49 0
 946 000a 2846     		mov	r0, r5
 947 000c FFF7FEFF 		bl	process_tapping
 948              	.LVL84:
 949 0010 2F4C     		ldr	r4, .L145
 950 0012 0646     		mov	r6, r0
 951 0014 88B1     		cbz	r0, .L130
  50:tmk_core/common/action_tapping.c ****             debug("processed: ");
 952              		.loc 1 50 0
 953 0016 BDF80430 		ldrh	r3, [sp, #4]
 954 001a BDF80020 		ldrh	r2, [sp]
 955 001e ADF80820 		strh	r2, [sp, #8]	@ movhi
 956              	.LBB99:
 957              	.LBB100:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 958              		.loc 2 48 0
 959 0022 43B1     		cbz	r3, .L132
 960              	.LBE100:
 961              	.LBE99:
  50:tmk_core/common/action_tapping.c ****             debug("processed: ");
 962              		.loc 1 50 0
 963 0024 92B2     		uxth	r2, r2
 964 0026 4FF6FF73 		movw	r3, #65535
 965 002a 9A42     		cmp	r2, r3
 966 002c 03D0     		beq	.L132
  52:tmk_core/common/action_tapping.c ****             debug("\n");
 967              		.loc 1 52 0
 968 002e 95E80300 		ldm	r5, {r0, r1}
 969 0032 FFF7FEFF 		bl	debug_record
 970              	.LVL85:
 971              	.L132:
  70:tmk_core/common/action_tapping.c ****             debug("processed: waiting_buffer[");
 972              		.loc 1 70 0 discriminator 1
 973 0036 274D     		ldr	r5, .L145+4
 974 0038 44E0     		b	.L136
 975              	.L130:
 976 003a 95E80300 		ldm	r5, {r0, r1}
 977 003e 04AB     		add	r3, sp, #16
 978 0040 83E80300 		stm	r3, {r0, r1}
 979 0044 BDF80420 		ldrh	r2, [sp, #4]
 980              	.LVL86:
 981 0048 BDF81010 		ldrh	r1, [sp, #16]
 982 004c ADF80C10 		strh	r1, [sp, #12]	@ movhi
 983              	.LBB101:
 984              	.LBB102:
 985              	.LBB103:
 986              	.LBB104:
  48:tmk_core/common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
 987              		.loc 2 48 0
 988 0050 002A     		cmp	r2, #0
 989 0052 F0D0     		beq	.L132
 990              	.LBE104:
 991              	.LBE103:
 303:tmk_core/common/action_tapping.c ****         return true;
 992              		.loc 1 303 0
 993 0054 89B2     		uxth	r1, r1
 994 0056 4FF6FF72 		movw	r2, #65535
 995              	.LVL87:
 996 005a 9142     		cmp	r1, r2
 997 005c EBD0     		beq	.L132
 307:tmk_core/common/action_tapping.c ****         debug("waiting_buffer_enq: Over flow.\n");
 998              		.loc 1 307 0
 999 005e 94F84220 		ldrb	r2, [r4, #66]	@ zero_extendqisi2
 1000 0062 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 1001 0064 551C     		adds	r5, r2, #1
 1002 0066 05F00705 		and	r5, r5, #7
 1003 006a 8D42     		cmp	r5, r1
 1004 006c 0BD0     		beq	.L133
 312:tmk_core/common/action_tapping.c ****     waiting_buffer_head                 = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
 1005              		.loc 1 312 0
 1006 006e 03CB     		ldmia	r3!, {r0, r1}
 1007 0070 04EBC202 		add	r2, r4, r2, lsl #3
 313:tmk_core/common/action_tapping.c **** 
 1008              		.loc 1 313 0
 1009 0074 84F84250 		strb	r5, [r4, #66]
 312:tmk_core/common/action_tapping.c ****     waiting_buffer_head                 = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
 1010              		.loc 1 312 0
 1011 0078 C2F80200 		str	r0, [r2, #2]	@ unaligned
 1012 007c C2F80610 		str	r1, [r2, #6]	@ unaligned
 316:tmk_core/common/action_tapping.c ****     return true;
 1013              		.loc 1 316 0
 1014 0080 FFF7FEFF 		bl	debug_waiting_buffer
 1015              	.LVL88:
 1016 0084 D7E7     		b	.L132
 1017              	.LVL89:
 1018              	.L133:
 1019              	.LBE102:
 1020              	.LBE101:
  59:tmk_core/common/action_tapping.c ****             waiting_buffer_clear();
 1021              		.loc 1 59 0
 1022 0086 FFF7FEFF 		bl	clear_keyboard
 1023              	.LVL90:
 1024              	.LBB105:
 1025              	.LBB106:
 326:tmk_core/common/action_tapping.c **** }
 1026              		.loc 1 326 0
 1027 008a 2346     		mov	r3, r4
 325:tmk_core/common/action_tapping.c ****     waiting_buffer_tail = 0;
 1028              		.loc 1 325 0
 1029 008c 84F84260 		strb	r6, [r4, #66]
 326:tmk_core/common/action_tapping.c **** }
 1030              		.loc 1 326 0
 1031 0090 03F8446B 		strb	r6, [r3], #68
 1032              	.LBE106:
 1033              	.LBE105:
  61:tmk_core/common/action_tapping.c ****         }
 1034              		.loc 1 61 0
 1035 0094 6664     		str	r6, [r4, #68]	@ unaligned
 1036 0096 5E60     		str	r6, [r3, #4]	@ unaligned
 1037              	.L129:
  83:tmk_core/common/action_tapping.c **** 
 1038              		.loc 1 83 0
 1039 0098 06B0     		add	sp, sp, #24
 1040              		.cfi_remember_state
 1041              		.cfi_def_cfa_offset 16
 1042              		@ sp needed
 1043 009a 70BD     		pop	{r4, r5, r6, pc}
 1044              	.L137:
 1045              		.cfi_restore_state
  70:tmk_core/common/action_tapping.c ****             debug("processed: waiting_buffer[");
 1046              		.loc 1 70 0
 1047 009c 05EBC000 		add	r0, r5, r0, lsl #3
 1048 00a0 FFF7FEFF 		bl	process_tapping
 1049              	.LVL91:
 1050 00a4 0028     		cmp	r0, #0
 1051 00a6 F7D0     		beq	.L129
  74:tmk_core/common/action_tapping.c ****             debug("\n\n");
 1052              		.loc 1 74 0
 1053 00a8 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1054 00aa 04EBC303 		add	r3, r4, r3, lsl #3
 1055 00ae D3F80200 		ldr	r0, [r3, #2]	@ unaligned
 1056 00b2 D3F80610 		ldr	r1, [r3, #6]	@ unaligned
 1057 00b6 FFF7FEFF 		bl	debug_record
 1058              	.LVL92:
  69:tmk_core/common/action_tapping.c ****         if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
 1059              		.loc 1 69 0
 1060 00ba 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1061 00bc 0133     		adds	r3, r3, #1
 1062 00be 03F00703 		and	r3, r3, #7
 1063 00c2 2370     		strb	r3, [r4]
 1064              	.L136:
  69:tmk_core/common/action_tapping.c ****         if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
 1065              		.loc 1 69 0 is_stmt 0 discriminator 1
 1066 00c4 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 1067 00c6 94F84230 		ldrb	r3, [r4, #66]	@ zero_extendqisi2
 1068 00ca 8342     		cmp	r3, r0
 1069 00cc E6D1     		bne	.L137
 1070 00ce E3E7     		b	.L129
 1071              	.L146:
 1072              		.align	2
 1073              	.L145:
 1074 00d0 00000000 		.word	.LANCHOR0
 1075 00d4 02000000 		.word	.LANCHOR0+2
 1076              		.cfi_endproc
 1077              	.LFE6:
 1079              		.bss
 1080              		.align	1
 1081              		.set	.LANCHOR0,. + 0
 1084              	waiting_buffer_tail:
 1085 0000 00       		.space	1
 1086 0001 00       		.space	1
 1089              	waiting_buffer:
 1090 0002 00000000 		.space	64
 1090      00000000 
 1090      00000000 
 1090      00000000 
 1090      00000000 
 1093              	waiting_buffer_head:
 1094 0042 00       		.space	1
 1095 0043 00       		.space	1
 1098              	tapping_key:
 1099 0044 00000000 		.space	8
 1099      00000000 
 1100              		.text
 1101              	.Letext0:
 1102              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 1103              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 1104              		.file 5 "tmk_core/common/keycode.h"
 1105              		.file 6 "tmk_core/common/action_code.h"
 1106              		.file 7 "tmk_core/common/action.h"
 1107              		.file 8 "tmk_core/common/action_layer.h"
 1108              		.file 9 "tmk_core/common/timer.h"
 1109              		.file 10 "tmk_core/common/debug.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action_tapping.c
/var/tmp//cchkk3nq.s:18     .text.debug_waiting_buffer:0000000000000000 $t
/var/tmp//cchkk3nq.s:24     .text.debug_waiting_buffer:0000000000000000 debug_waiting_buffer
/var/tmp//cchkk3nq.s:70     .text.debug_waiting_buffer:0000000000000028 $d
/var/tmp//cchkk3nq.s:76     .text.debug_tapping_key:0000000000000000 $t
/var/tmp//cchkk3nq.s:82     .text.debug_tapping_key:0000000000000000 debug_tapping_key
/var/tmp//cchkk3nq.s:98     .text.debug_tapping_key:000000000000000c $d
/var/tmp//cchkk3nq.s:103    .text.waiting_buffer_scan_tap:0000000000000000 $t
/var/tmp//cchkk3nq.s:109    .text.waiting_buffer_scan_tap:0000000000000000 waiting_buffer_scan_tap
/var/tmp//cchkk3nq.s:242    .text.waiting_buffer_scan_tap:00000000000000a4 $d
/var/tmp//cchkk3nq.s:249    .text.process_tapping:0000000000000000 $t
/var/tmp//cchkk3nq.s:255    .text.process_tapping:0000000000000000 process_tapping
/var/tmp//cchkk3nq.s:456    .text.process_tapping:0000000000000120 $d
/var/tmp//cchkk3nq.s:461    .text.process_tapping:0000000000000124 $t
/var/tmp//cchkk3nq.s:713    .text.process_tapping:00000000000002bc $d
/var/tmp//cchkk3nq.s:720    .text.process_tapping:00000000000002c4 $t
/var/tmp//cchkk3nq.s:893    .text.process_tapping:00000000000003f0 $d
/var/tmp//cchkk3nq.s:898    .text.get_tapping_term:0000000000000000 $t
/var/tmp//cchkk3nq.s:905    .text.get_tapping_term:0000000000000000 get_tapping_term
/var/tmp//cchkk3nq.s:921    .text.action_tapping_process:0000000000000000 $t
/var/tmp//cchkk3nq.s:928    .text.action_tapping_process:0000000000000000 action_tapping_process
/var/tmp//cchkk3nq.s:1074   .text.action_tapping_process:00000000000000d0 $d
/var/tmp//cchkk3nq.s:1080   .bss:0000000000000000 $d
/var/tmp//cchkk3nq.s:1084   .bss:0000000000000000 waiting_buffer_tail
/var/tmp//cchkk3nq.s:1089   .bss:0000000000000002 waiting_buffer
/var/tmp//cchkk3nq.s:1093   .bss:0000000000000042 waiting_buffer_head
/var/tmp//cchkk3nq.s:1098   .bss:0000000000000044 tapping_key

UNDEFINED SYMBOLS
debug_record
process_record
layer_switch_get_action
is_tap_key
debug_event
process_record_tap_hint
clear_keyboard

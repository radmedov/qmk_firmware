   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"action_layer.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.default_layer_state_set_user,"ax",%progbits
  18              		.align	1
  19              		.weak	default_layer_state_set_user
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	default_layer_state_set_user:
  26              	.LFB3:
  27              		.file 1 "tmk_core/common/action_layer.c"
   1:tmk_core/common/action_layer.c **** #include <stdint.h>
   2:tmk_core/common/action_layer.c **** #include "keyboard.h"
   3:tmk_core/common/action_layer.c **** #include "action.h"
   4:tmk_core/common/action_layer.c **** #include "util.h"
   5:tmk_core/common/action_layer.c **** #include "action_layer.h"
   6:tmk_core/common/action_layer.c **** 
   7:tmk_core/common/action_layer.c **** #ifdef DEBUG_ACTION
   8:tmk_core/common/action_layer.c **** #    include "debug.h"
   9:tmk_core/common/action_layer.c **** #else
  10:tmk_core/common/action_layer.c **** #    include "nodebug.h"
  11:tmk_core/common/action_layer.c **** #endif
  12:tmk_core/common/action_layer.c **** 
  13:tmk_core/common/action_layer.c **** /** \brief Default Layer State
  14:tmk_core/common/action_layer.c ****  */
  15:tmk_core/common/action_layer.c **** layer_state_t default_layer_state = 0;
  16:tmk_core/common/action_layer.c **** 
  17:tmk_core/common/action_layer.c **** /** \brief Default Layer State Set At user Level
  18:tmk_core/common/action_layer.c ****  *
  19:tmk_core/common/action_layer.c ****  * Run user code on default layer state change
  20:tmk_core/common/action_layer.c ****  */
  21:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_user(layer_state_t state) { return stat
  28              		.loc 1 21 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  34              		.loc 1 21 0
  35 0000 7047     		bx	lr
  36              		.cfi_endproc
  37              	.LFE3:
  39              		.thumb_set default_layer_state_set_user.localalias.0,default_layer_state_set_user
  40              		.section	.text.default_layer_state_set_kb,"ax",%progbits
  41              		.align	1
  42              		.weak	default_layer_state_set_kb
  43              		.syntax unified
  44              		.thumb
  45              		.thumb_func
  46              		.fpu fpv4-sp-d16
  48              	default_layer_state_set_kb:
  49              	.LFB4:
  22:tmk_core/common/action_layer.c **** 
  23:tmk_core/common/action_layer.c **** /** \brief Default Layer State Set At Keyboard Level
  24:tmk_core/common/action_layer.c ****  *
  25:tmk_core/common/action_layer.c ****  *  Run keyboard code on default layer state change
  26:tmk_core/common/action_layer.c ****  */
  27:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t default_layer_state_set_kb(layer_state_t state) { return defaul
  50              		.loc 1 27 0
  51              		.cfi_startproc
  52              		@ args = 0, pretend = 0, frame = 0
  53              		@ frame_needed = 0, uses_anonymous_args = 0
  54              	.LVL1:
  55 0000 08B5     		push	{r3, lr}
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 3, -8
  58              		.cfi_offset 14, -4
  59              		.loc 1 27 0
  60 0002 FFF7FEFF 		bl	default_layer_state_set_user
  61              	.LVL2:
  62 0006 08BD     		pop	{r3, pc}
  63              		.cfi_endproc
  64              	.LFE4:
  66              		.section	.text.default_layer_state_set,"ax",%progbits
  67              		.align	1
  68              		.syntax unified
  69              		.thumb
  70              		.thumb_func
  71              		.fpu fpv4-sp-d16
  73              	default_layer_state_set:
  74              	.LFB5:
  28:tmk_core/common/action_layer.c **** 
  29:tmk_core/common/action_layer.c **** /** \brief Default Layer State Set
  30:tmk_core/common/action_layer.c ****  *
  31:tmk_core/common/action_layer.c ****  * Static function to set the default layer state, prints debug info and clears keys
  32:tmk_core/common/action_layer.c ****  */
  33:tmk_core/common/action_layer.c **** static void default_layer_state_set(layer_state_t state) {
  75              		.loc 1 33 0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
  79              	.LVL3:
  80 0000 08B5     		push	{r3, lr}
  81              		.cfi_def_cfa_offset 8
  82              		.cfi_offset 3, -8
  83              		.cfi_offset 14, -4
  34:tmk_core/common/action_layer.c ****     state = default_layer_state_set_kb(state);
  84              		.loc 1 34 0
  85 0002 FFF7FEFF 		bl	default_layer_state_set_kb
  86              	.LVL4:
  35:tmk_core/common/action_layer.c ****     debug("default_layer_state: ");
  36:tmk_core/common/action_layer.c ****     default_layer_debug();
  37:tmk_core/common/action_layer.c ****     debug(" to ");
  38:tmk_core/common/action_layer.c ****     default_layer_state = state;
  87              		.loc 1 38 0
  88 0006 034B     		ldr	r3, .L4
  89 0008 1860     		str	r0, [r3]
  39:tmk_core/common/action_layer.c ****     default_layer_debug();
  40:tmk_core/common/action_layer.c ****     debug("\n");
  41:tmk_core/common/action_layer.c **** #ifdef STRICT_LAYER_RELEASE
  42:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
  43:tmk_core/common/action_layer.c **** #else
  44:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
  45:tmk_core/common/action_layer.c **** #endif
  46:tmk_core/common/action_layer.c **** }
  90              		.loc 1 46 0
  91 000a BDE80840 		pop	{r3, lr}
  92              		.cfi_restore 14
  93              		.cfi_restore 3
  94              		.cfi_def_cfa_offset 0
  44:tmk_core/common/action_layer.c **** #endif
  95              		.loc 1 44 0
  96 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
  97              	.LVL5:
  98              	.L5:
  99 0012 00BF     		.align	2
 100              	.L4:
 101 0014 00000000 		.word	.LANCHOR0
 102              		.cfi_endproc
 103              	.LFE5:
 105              		.section	.text.default_layer_debug,"ax",%progbits
 106              		.align	1
 107              		.global	default_layer_debug
 108              		.syntax unified
 109              		.thumb
 110              		.thumb_func
 111              		.fpu fpv4-sp-d16
 113              	default_layer_debug:
 114              	.LFB6:
  47:tmk_core/common/action_layer.c **** 
  48:tmk_core/common/action_layer.c **** /** \brief Default Layer Print
  49:tmk_core/common/action_layer.c ****  *
  50:tmk_core/common/action_layer.c ****  * Print out the hex value of the 32-bit default layer state, as well as the value of the highest b
  51:tmk_core/common/action_layer.c ****  */
  52:tmk_core/common/action_layer.c **** void default_layer_debug(void) { dprintf("%08lX(%u)", default_layer_state, biton32(default_layer_st
 115              		.loc 1 52 0
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              		.loc 1 52 0
 121 0000 7047     		bx	lr
 122              		.cfi_endproc
 123              	.LFE6:
 125              		.section	.text.default_layer_set,"ax",%progbits
 126              		.align	1
 127              		.global	default_layer_set
 128              		.syntax unified
 129              		.thumb
 130              		.thumb_func
 131              		.fpu fpv4-sp-d16
 133              	default_layer_set:
 134              	.LFB7:
  53:tmk_core/common/action_layer.c **** 
  54:tmk_core/common/action_layer.c **** /** \brief Default Layer Set
  55:tmk_core/common/action_layer.c ****  *
  56:tmk_core/common/action_layer.c ****  * Sets the default layer state.
  57:tmk_core/common/action_layer.c ****  */
  58:tmk_core/common/action_layer.c **** void default_layer_set(layer_state_t state) { default_layer_state_set(state); }
 135              		.loc 1 58 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140              	.LVL6:
 141              		.loc 1 58 0
 142 0000 FFF7FEBF 		b	default_layer_state_set
 143              	.LVL7:
 144              		.cfi_endproc
 145              	.LFE7:
 147              		.section	.text.default_layer_or,"ax",%progbits
 148              		.align	1
 149              		.global	default_layer_or
 150              		.syntax unified
 151              		.thumb
 152              		.thumb_func
 153              		.fpu fpv4-sp-d16
 155              	default_layer_or:
 156              	.LFB8:
  59:tmk_core/common/action_layer.c **** 
  60:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
  61:tmk_core/common/action_layer.c **** /** \brief Default Layer Or
  62:tmk_core/common/action_layer.c ****  *
  63:tmk_core/common/action_layer.c ****  * Turns on the default layer based on matching bits between specifed layer and existing layer stat
  64:tmk_core/common/action_layer.c ****  */
  65:tmk_core/common/action_layer.c **** void default_layer_or(layer_state_t state) { default_layer_state_set(default_layer_state | state); 
 157              		.loc 1 65 0
 158              		.cfi_startproc
 159              		@ args = 0, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              		@ link register save eliminated.
 162              	.LVL8:
 163              		.loc 1 65 0
 164 0000 024B     		ldr	r3, .L9
 165 0002 1B68     		ldr	r3, [r3]
 166 0004 1843     		orrs	r0, r0, r3
 167              	.LVL9:
 168 0006 FFF7FEBF 		b	default_layer_state_set
 169              	.LVL10:
 170              	.L10:
 171 000a 00BF     		.align	2
 172              	.L9:
 173 000c 00000000 		.word	.LANCHOR0
 174              		.cfi_endproc
 175              	.LFE8:
 177              		.section	.text.default_layer_and,"ax",%progbits
 178              		.align	1
 179              		.global	default_layer_and
 180              		.syntax unified
 181              		.thumb
 182              		.thumb_func
 183              		.fpu fpv4-sp-d16
 185              	default_layer_and:
 186              	.LFB9:
  66:tmk_core/common/action_layer.c **** /** \brief Default Layer And
  67:tmk_core/common/action_layer.c ****  *
  68:tmk_core/common/action_layer.c ****  * Turns on default layer based on matching enabled bits between specifed layer and existing layer 
  69:tmk_core/common/action_layer.c ****  */
  70:tmk_core/common/action_layer.c **** void default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state);
 187              		.loc 1 70 0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 0
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              		@ link register save eliminated.
 192              	.LVL11:
 193              		.loc 1 70 0
 194 0000 024B     		ldr	r3, .L12
 195 0002 1B68     		ldr	r3, [r3]
 196 0004 1840     		ands	r0, r0, r3
 197              	.LVL12:
 198 0006 FFF7FEBF 		b	default_layer_state_set
 199              	.LVL13:
 200              	.L13:
 201 000a 00BF     		.align	2
 202              	.L12:
 203 000c 00000000 		.word	.LANCHOR0
 204              		.cfi_endproc
 205              	.LFE9:
 207              		.section	.text.default_layer_xor,"ax",%progbits
 208              		.align	1
 209              		.global	default_layer_xor
 210              		.syntax unified
 211              		.thumb
 212              		.thumb_func
 213              		.fpu fpv4-sp-d16
 215              	default_layer_xor:
 216              	.LFB10:
  71:tmk_core/common/action_layer.c **** /** \brief Default Layer Xor
  72:tmk_core/common/action_layer.c ****  *
  73:tmk_core/common/action_layer.c ****  * Turns on default layer based on non-matching bits between specifed layer and existing layer stat
  74:tmk_core/common/action_layer.c ****  */
  75:tmk_core/common/action_layer.c **** void default_layer_xor(layer_state_t state) { default_layer_state_set(default_layer_state ^ state);
 217              		.loc 1 75 0
 218              		.cfi_startproc
 219              		@ args = 0, pretend = 0, frame = 0
 220              		@ frame_needed = 0, uses_anonymous_args = 0
 221              		@ link register save eliminated.
 222              	.LVL14:
 223              		.loc 1 75 0
 224 0000 024B     		ldr	r3, .L15
 225 0002 1B68     		ldr	r3, [r3]
 226 0004 5840     		eors	r0, r0, r3
 227              	.LVL15:
 228 0006 FFF7FEBF 		b	default_layer_state_set
 229              	.LVL16:
 230              	.L16:
 231 000a 00BF     		.align	2
 232              	.L15:
 233 000c 00000000 		.word	.LANCHOR0
 234              		.cfi_endproc
 235              	.LFE10:
 237              		.section	.text.layer_state_set_user,"ax",%progbits
 238              		.align	1
 239              		.weak	layer_state_set_user
 240              		.syntax unified
 241              		.thumb
 242              		.thumb_func
 243              		.fpu fpv4-sp-d16
 245              	layer_state_set_user:
 246              	.LFB33:
 247              		.cfi_startproc
 248              		@ args = 0, pretend = 0, frame = 0
 249              		@ frame_needed = 0, uses_anonymous_args = 0
 250              		@ link register save eliminated.
 251 0000 FFF7FEBF 		b	default_layer_state_set_user.localalias.0
 252              		.cfi_endproc
 253              	.LFE33:
 255              		.section	.text.layer_state_set_kb,"ax",%progbits
 256              		.align	1
 257              		.weak	layer_state_set_kb
 258              		.syntax unified
 259              		.thumb
 260              		.thumb_func
 261              		.fpu fpv4-sp-d16
 263              	layer_state_set_kb:
 264              	.LFB12:
  76:tmk_core/common/action_layer.c **** #endif
  77:tmk_core/common/action_layer.c **** 
  78:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
  79:tmk_core/common/action_layer.c **** /** \brief Keymap Layer State
  80:tmk_core/common/action_layer.c ****  */
  81:tmk_core/common/action_layer.c **** layer_state_t layer_state = 0;
  82:tmk_core/common/action_layer.c **** 
  83:tmk_core/common/action_layer.c **** /** \brief Layer state set user
  84:tmk_core/common/action_layer.c ****  *
  85:tmk_core/common/action_layer.c ****  * Runs user code on layer state change
  86:tmk_core/common/action_layer.c ****  */
  87:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_user(layer_state_t state) { return state; }
  88:tmk_core/common/action_layer.c **** 
  89:tmk_core/common/action_layer.c **** /** \brief Layer state set keyboard
  90:tmk_core/common/action_layer.c ****  *
  91:tmk_core/common/action_layer.c ****  * Runs keyboard code on layer state change
  92:tmk_core/common/action_layer.c ****  */
  93:tmk_core/common/action_layer.c **** __attribute__((weak)) layer_state_t layer_state_set_kb(layer_state_t state) { return layer_state_se
 265              		.loc 1 93 0
 266              		.cfi_startproc
 267              		@ args = 0, pretend = 0, frame = 0
 268              		@ frame_needed = 0, uses_anonymous_args = 0
 269              	.LVL17:
 270              		.loc 1 93 0
 271 0000 08B5     		push	{r3, lr}
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 3, -8
 274              		.cfi_offset 14, -4
 275              		.loc 1 93 0
 276 0002 FFF7FEFF 		bl	layer_state_set_user
 277              	.LVL18:
 278 0006 08BD     		pop	{r3, pc}
 279              		.cfi_endproc
 280              	.LFE12:
 282              		.section	.text.layer_state_set,"ax",%progbits
 283              		.align	1
 284              		.global	layer_state_set
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 288              		.fpu fpv4-sp-d16
 290              	layer_state_set:
 291              	.LFB13:
  94:tmk_core/common/action_layer.c **** 
  95:tmk_core/common/action_layer.c **** /** \brief Layer state set
  96:tmk_core/common/action_layer.c ****  *
  97:tmk_core/common/action_layer.c ****  * Sets the layer to match the specifed state (a bitmask)
  98:tmk_core/common/action_layer.c ****  */
  99:tmk_core/common/action_layer.c **** void layer_state_set(layer_state_t state) {
 292              		.loc 1 99 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 296              	.LVL19:
 297 0000 08B5     		push	{r3, lr}
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 3, -8
 300              		.cfi_offset 14, -4
 100:tmk_core/common/action_layer.c ****     state = layer_state_set_kb(state);
 301              		.loc 1 100 0
 302 0002 FFF7FEFF 		bl	layer_state_set_kb
 303              	.LVL20:
 101:tmk_core/common/action_layer.c ****     dprint("layer_state: ");
 102:tmk_core/common/action_layer.c ****     layer_debug();
 103:tmk_core/common/action_layer.c ****     dprint(" to ");
 104:tmk_core/common/action_layer.c ****     layer_state = state;
 304              		.loc 1 104 0
 305 0006 034B     		ldr	r3, .L20
 306 0008 5860     		str	r0, [r3, #4]
 105:tmk_core/common/action_layer.c ****     layer_debug();
 106:tmk_core/common/action_layer.c ****     dprintln();
 107:tmk_core/common/action_layer.c **** #    ifdef STRICT_LAYER_RELEASE
 108:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods();  // To avoid stuck keys
 109:tmk_core/common/action_layer.c **** #    else
 110:tmk_core/common/action_layer.c ****     clear_keyboard_but_mods_and_keys();  // Don't reset held keys
 111:tmk_core/common/action_layer.c **** #    endif
 112:tmk_core/common/action_layer.c **** }
 307              		.loc 1 112 0
 308 000a BDE80840 		pop	{r3, lr}
 309              		.cfi_restore 14
 310              		.cfi_restore 3
 311              		.cfi_def_cfa_offset 0
 110:tmk_core/common/action_layer.c **** #    endif
 312              		.loc 1 110 0
 313 000e FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 314              	.LVL21:
 315              	.L21:
 316 0012 00BF     		.align	2
 317              	.L20:
 318 0014 00000000 		.word	.LANCHOR0
 319              		.cfi_endproc
 320              	.LFE13:
 322              		.section	.text.layer_clear,"ax",%progbits
 323              		.align	1
 324              		.global	layer_clear
 325              		.syntax unified
 326              		.thumb
 327              		.thumb_func
 328              		.fpu fpv4-sp-d16
 330              	layer_clear:
 331              	.LFB14:
 113:tmk_core/common/action_layer.c **** 
 114:tmk_core/common/action_layer.c **** /** \brief Layer clear
 115:tmk_core/common/action_layer.c ****  *
 116:tmk_core/common/action_layer.c ****  * Turn off all layers
 117:tmk_core/common/action_layer.c ****  */
 118:tmk_core/common/action_layer.c **** void layer_clear(void) { layer_state_set(0); }
 332              		.loc 1 118 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 0
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              		@ link register save eliminated.
 337              		.loc 1 118 0
 338 0000 0020     		movs	r0, #0
 339 0002 FFF7FEBF 		b	layer_state_set
 340              	.LVL22:
 341              		.cfi_endproc
 342              	.LFE14:
 344              		.section	.text.layer_state_cmp,"ax",%progbits
 345              		.align	1
 346              		.global	layer_state_cmp
 347              		.syntax unified
 348              		.thumb
 349              		.thumb_func
 350              		.fpu fpv4-sp-d16
 352              	layer_state_cmp:
 353              	.LFB16:
 119:tmk_core/common/action_layer.c **** 
 120:tmk_core/common/action_layer.c **** /** \brief Layer state is
 121:tmk_core/common/action_layer.c ****  *
 122:tmk_core/common/action_layer.c ****  * Return whether the given state is on (it might still be shadowed by a higher state, though)
 123:tmk_core/common/action_layer.c ****  */
 124:tmk_core/common/action_layer.c **** bool layer_state_is(uint8_t layer) { return layer_state_cmp(layer_state, layer); }
 125:tmk_core/common/action_layer.c **** 
 126:tmk_core/common/action_layer.c **** /** \brief Layer state compare
 127:tmk_core/common/action_layer.c ****  *
 128:tmk_core/common/action_layer.c ****  * Used for comparing layers {mostly used for unit testing}
 129:tmk_core/common/action_layer.c ****  */
 130:tmk_core/common/action_layer.c **** bool layer_state_cmp(layer_state_t cmp_layer_state, uint8_t layer) {
 354              		.loc 1 130 0
 355              		.cfi_startproc
 356              		@ args = 0, pretend = 0, frame = 0
 357              		@ frame_needed = 0, uses_anonymous_args = 0
 358              		@ link register save eliminated.
 359              	.LVL23:
 131:tmk_core/common/action_layer.c ****     if (!cmp_layer_state) {
 360              		.loc 1 131 0
 361 0000 18B9     		cbnz	r0, .L24
 132:tmk_core/common/action_layer.c ****         return layer == 0;
 362              		.loc 1 132 0
 363 0002 B1FA81F0 		clz	r0, r1
 364              	.LVL24:
 365 0006 4009     		lsrs	r0, r0, #5
 366 0008 7047     		bx	lr
 367              	.LVL25:
 368              	.L24:
 133:tmk_core/common/action_layer.c ****     }
 134:tmk_core/common/action_layer.c ****     return (cmp_layer_state & (1UL << layer)) != 0;
 369              		.loc 1 134 0
 370 000a C840     		lsrs	r0, r0, r1
 371              	.LVL26:
 372 000c 00F00100 		and	r0, r0, #1
 135:tmk_core/common/action_layer.c **** }
 373              		.loc 1 135 0
 374 0010 7047     		bx	lr
 375              		.cfi_endproc
 376              	.LFE16:
 378              		.section	.text.layer_state_is,"ax",%progbits
 379              		.align	1
 380              		.global	layer_state_is
 381              		.syntax unified
 382              		.thumb
 383              		.thumb_func
 384              		.fpu fpv4-sp-d16
 386              	layer_state_is:
 387              	.LFB15:
 124:tmk_core/common/action_layer.c **** 
 388              		.loc 1 124 0
 389              		.cfi_startproc
 390              		@ args = 0, pretend = 0, frame = 0
 391              		@ frame_needed = 0, uses_anonymous_args = 0
 392              		@ link register save eliminated.
 393              	.LVL27:
 124:tmk_core/common/action_layer.c **** 
 394              		.loc 1 124 0
 395 0000 024B     		ldr	r3, .L27
 396 0002 0146     		mov	r1, r0
 397 0004 5868     		ldr	r0, [r3, #4]
 398              	.LVL28:
 399 0006 FFF7FEBF 		b	layer_state_cmp
 400              	.LVL29:
 401              	.L28:
 402 000a 00BF     		.align	2
 403              	.L27:
 404 000c 00000000 		.word	.LANCHOR0
 405              		.cfi_endproc
 406              	.LFE15:
 408              		.section	.text.layer_move,"ax",%progbits
 409              		.align	1
 410              		.global	layer_move
 411              		.syntax unified
 412              		.thumb
 413              		.thumb_func
 414              		.fpu fpv4-sp-d16
 416              	layer_move:
 417              	.LFB17:
 136:tmk_core/common/action_layer.c **** 
 137:tmk_core/common/action_layer.c **** /** \brief Layer move
 138:tmk_core/common/action_layer.c ****  *
 139:tmk_core/common/action_layer.c ****  * Turns on the given layer and turn off all other layers
 140:tmk_core/common/action_layer.c ****  */
 141:tmk_core/common/action_layer.c **** void layer_move(uint8_t layer) { layer_state_set(1UL << layer); }
 418              		.loc 1 141 0
 419              		.cfi_startproc
 420              		@ args = 0, pretend = 0, frame = 0
 421              		@ frame_needed = 0, uses_anonymous_args = 0
 422              		@ link register save eliminated.
 423              	.LVL30:
 424              		.loc 1 141 0
 425 0000 0123     		movs	r3, #1
 426 0002 03FA00F0 		lsl	r0, r3, r0
 427              	.LVL31:
 428 0006 FFF7FEBF 		b	layer_state_set
 429              	.LVL32:
 430              		.cfi_endproc
 431              	.LFE17:
 433              		.section	.text.layer_on,"ax",%progbits
 434              		.align	1
 435              		.global	layer_on
 436              		.syntax unified
 437              		.thumb
 438              		.thumb_func
 439              		.fpu fpv4-sp-d16
 441              	layer_on:
 442              	.LFB18:
 142:tmk_core/common/action_layer.c **** 
 143:tmk_core/common/action_layer.c **** /** \brief Layer on
 144:tmk_core/common/action_layer.c ****  *
 145:tmk_core/common/action_layer.c ****  * Turns on given layer
 146:tmk_core/common/action_layer.c ****  */
 147:tmk_core/common/action_layer.c **** void layer_on(uint8_t layer) { layer_state_set(layer_state | (1UL << layer)); }
 443              		.loc 1 147 0
 444              		.cfi_startproc
 445              		@ args = 0, pretend = 0, frame = 0
 446              		@ frame_needed = 0, uses_anonymous_args = 0
 447              		@ link register save eliminated.
 448              	.LVL33:
 449              		.loc 1 147 0
 450 0000 0123     		movs	r3, #1
 451 0002 03FA00F0 		lsl	r0, r3, r0
 452              	.LVL34:
 453 0006 024B     		ldr	r3, .L31
 454 0008 5B68     		ldr	r3, [r3, #4]
 455 000a 1843     		orrs	r0, r0, r3
 456 000c FFF7FEBF 		b	layer_state_set
 457              	.LVL35:
 458              	.L32:
 459              		.align	2
 460              	.L31:
 461 0010 00000000 		.word	.LANCHOR0
 462              		.cfi_endproc
 463              	.LFE18:
 465              		.section	.text.layer_off,"ax",%progbits
 466              		.align	1
 467              		.global	layer_off
 468              		.syntax unified
 469              		.thumb
 470              		.thumb_func
 471              		.fpu fpv4-sp-d16
 473              	layer_off:
 474              	.LFB19:
 148:tmk_core/common/action_layer.c **** 
 149:tmk_core/common/action_layer.c **** /** \brief Layer off
 150:tmk_core/common/action_layer.c ****  *
 151:tmk_core/common/action_layer.c ****  * Turns off given layer
 152:tmk_core/common/action_layer.c ****  */
 153:tmk_core/common/action_layer.c **** void layer_off(uint8_t layer) { layer_state_set(layer_state & ~(1UL << layer)); }
 475              		.loc 1 153 0
 476              		.cfi_startproc
 477              		@ args = 0, pretend = 0, frame = 0
 478              		@ frame_needed = 0, uses_anonymous_args = 0
 479              		@ link register save eliminated.
 480              	.LVL36:
 481              		.loc 1 153 0
 482 0000 0123     		movs	r3, #1
 483 0002 03FA00F0 		lsl	r0, r3, r0
 484              	.LVL37:
 485 0006 034B     		ldr	r3, .L34
 486 0008 5B68     		ldr	r3, [r3, #4]
 487 000a 23EA0000 		bic	r0, r3, r0
 488 000e FFF7FEBF 		b	layer_state_set
 489              	.LVL38:
 490              	.L35:
 491 0012 00BF     		.align	2
 492              	.L34:
 493 0014 00000000 		.word	.LANCHOR0
 494              		.cfi_endproc
 495              	.LFE19:
 497              		.section	.text.layer_invert,"ax",%progbits
 498              		.align	1
 499              		.global	layer_invert
 500              		.syntax unified
 501              		.thumb
 502              		.thumb_func
 503              		.fpu fpv4-sp-d16
 505              	layer_invert:
 506              	.LFB20:
 154:tmk_core/common/action_layer.c **** 
 155:tmk_core/common/action_layer.c **** /** \brief Layer invert
 156:tmk_core/common/action_layer.c ****  *
 157:tmk_core/common/action_layer.c ****  * Toggle the given layer (set it if it's unset, or unset it if it's set)
 158:tmk_core/common/action_layer.c ****  */
 159:tmk_core/common/action_layer.c **** void layer_invert(uint8_t layer) { layer_state_set(layer_state ^ (1UL << layer)); }
 507              		.loc 1 159 0
 508              		.cfi_startproc
 509              		@ args = 0, pretend = 0, frame = 0
 510              		@ frame_needed = 0, uses_anonymous_args = 0
 511              		@ link register save eliminated.
 512              	.LVL39:
 513              		.loc 1 159 0
 514 0000 0123     		movs	r3, #1
 515 0002 03FA00F0 		lsl	r0, r3, r0
 516              	.LVL40:
 517 0006 024B     		ldr	r3, .L37
 518 0008 5B68     		ldr	r3, [r3, #4]
 519 000a 5840     		eors	r0, r0, r3
 520 000c FFF7FEBF 		b	layer_state_set
 521              	.LVL41:
 522              	.L38:
 523              		.align	2
 524              	.L37:
 525 0010 00000000 		.word	.LANCHOR0
 526              		.cfi_endproc
 527              	.LFE20:
 529              		.section	.text.layer_or,"ax",%progbits
 530              		.align	1
 531              		.global	layer_or
 532              		.syntax unified
 533              		.thumb
 534              		.thumb_func
 535              		.fpu fpv4-sp-d16
 537              	layer_or:
 538              	.LFB21:
 160:tmk_core/common/action_layer.c **** 
 161:tmk_core/common/action_layer.c **** /** \brief Layer or
 162:tmk_core/common/action_layer.c ****  *
 163:tmk_core/common/action_layer.c ****  * Turns on layers based on matching bits between specifed layer and existing layer state
 164:tmk_core/common/action_layer.c ****  */
 165:tmk_core/common/action_layer.c **** void layer_or(layer_state_t state) { layer_state_set(layer_state | state); }
 539              		.loc 1 165 0
 540              		.cfi_startproc
 541              		@ args = 0, pretend = 0, frame = 0
 542              		@ frame_needed = 0, uses_anonymous_args = 0
 543              		@ link register save eliminated.
 544              	.LVL42:
 545              		.loc 1 165 0
 546 0000 024B     		ldr	r3, .L40
 547 0002 5B68     		ldr	r3, [r3, #4]
 548 0004 1843     		orrs	r0, r0, r3
 549              	.LVL43:
 550 0006 FFF7FEBF 		b	layer_state_set
 551              	.LVL44:
 552              	.L41:
 553 000a 00BF     		.align	2
 554              	.L40:
 555 000c 00000000 		.word	.LANCHOR0
 556              		.cfi_endproc
 557              	.LFE21:
 559              		.section	.text.layer_and,"ax",%progbits
 560              		.align	1
 561              		.global	layer_and
 562              		.syntax unified
 563              		.thumb
 564              		.thumb_func
 565              		.fpu fpv4-sp-d16
 567              	layer_and:
 568              	.LFB22:
 166:tmk_core/common/action_layer.c **** /** \brief Layer and
 167:tmk_core/common/action_layer.c ****  *
 168:tmk_core/common/action_layer.c ****  * Turns on layers based on matching enabled bits between specifed layer and existing layer state
 169:tmk_core/common/action_layer.c ****  */
 170:tmk_core/common/action_layer.c **** void layer_and(layer_state_t state) { layer_state_set(layer_state & state); }
 569              		.loc 1 170 0
 570              		.cfi_startproc
 571              		@ args = 0, pretend = 0, frame = 0
 572              		@ frame_needed = 0, uses_anonymous_args = 0
 573              		@ link register save eliminated.
 574              	.LVL45:
 575              		.loc 1 170 0
 576 0000 024B     		ldr	r3, .L43
 577 0002 5B68     		ldr	r3, [r3, #4]
 578 0004 1840     		ands	r0, r0, r3
 579              	.LVL46:
 580 0006 FFF7FEBF 		b	layer_state_set
 581              	.LVL47:
 582              	.L44:
 583 000a 00BF     		.align	2
 584              	.L43:
 585 000c 00000000 		.word	.LANCHOR0
 586              		.cfi_endproc
 587              	.LFE22:
 589              		.section	.text.layer_xor,"ax",%progbits
 590              		.align	1
 591              		.global	layer_xor
 592              		.syntax unified
 593              		.thumb
 594              		.thumb_func
 595              		.fpu fpv4-sp-d16
 597              	layer_xor:
 598              	.LFB23:
 171:tmk_core/common/action_layer.c **** /** \brief Layer xor
 172:tmk_core/common/action_layer.c ****  *
 173:tmk_core/common/action_layer.c ****  * Turns on layers based on non-matching bits between specifed layer and existing layer state
 174:tmk_core/common/action_layer.c ****  */
 175:tmk_core/common/action_layer.c **** void layer_xor(layer_state_t state) { layer_state_set(layer_state ^ state); }
 599              		.loc 1 175 0
 600              		.cfi_startproc
 601              		@ args = 0, pretend = 0, frame = 0
 602              		@ frame_needed = 0, uses_anonymous_args = 0
 603              		@ link register save eliminated.
 604              	.LVL48:
 605              		.loc 1 175 0
 606 0000 024B     		ldr	r3, .L46
 607 0002 5B68     		ldr	r3, [r3, #4]
 608 0004 5840     		eors	r0, r0, r3
 609              	.LVL49:
 610 0006 FFF7FEBF 		b	layer_state_set
 611              	.LVL50:
 612              	.L47:
 613 000a 00BF     		.align	2
 614              	.L46:
 615 000c 00000000 		.word	.LANCHOR0
 616              		.cfi_endproc
 617              	.LFE23:
 619              		.section	.text.layer_debug,"ax",%progbits
 620              		.align	1
 621              		.global	layer_debug
 622              		.syntax unified
 623              		.thumb
 624              		.thumb_func
 625              		.fpu fpv4-sp-d16
 627              	layer_debug:
 628              	.LFB31:
 629              		.cfi_startproc
 630              		@ args = 0, pretend = 0, frame = 0
 631              		@ frame_needed = 0, uses_anonymous_args = 0
 632              		@ link register save eliminated.
 633 0000 7047     		bx	lr
 634              		.cfi_endproc
 635              	.LFE31:
 637              		.section	.text.update_source_layers_cache,"ax",%progbits
 638              		.align	1
 639              		.global	update_source_layers_cache
 640              		.syntax unified
 641              		.thumb
 642              		.thumb_func
 643              		.fpu fpv4-sp-d16
 645              	update_source_layers_cache:
 646              	.LFB25:
 176:tmk_core/common/action_layer.c **** 
 177:tmk_core/common/action_layer.c **** /** \brief Layer debug printing
 178:tmk_core/common/action_layer.c ****  *
 179:tmk_core/common/action_layer.c ****  * Print out the hex value of the 32-bit layer state, as well as the value of the highest bit.
 180:tmk_core/common/action_layer.c ****  */
 181:tmk_core/common/action_layer.c **** void layer_debug(void) { dprintf("%08lX(%u)", layer_state, biton32(layer_state)); }
 182:tmk_core/common/action_layer.c **** #endif
 183:tmk_core/common/action_layer.c **** 
 184:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 185:tmk_core/common/action_layer.c **** /** \brief source layer cache
 186:tmk_core/common/action_layer.c ****  */
 187:tmk_core/common/action_layer.c **** 
 188:tmk_core/common/action_layer.c **** uint8_t source_layers_cache[(MATRIX_ROWS * MATRIX_COLS + 7) / 8][MAX_LAYER_BITS] = {{0}};
 189:tmk_core/common/action_layer.c **** 
 190:tmk_core/common/action_layer.c **** /** \brief update source layers cache
 191:tmk_core/common/action_layer.c ****  *
 192:tmk_core/common/action_layer.c ****  * Updates the cached keys when changing layers
 193:tmk_core/common/action_layer.c ****  */
 194:tmk_core/common/action_layer.c **** void update_source_layers_cache(keypos_t key, uint8_t layer) {
 647              		.loc 1 194 0
 648              		.cfi_startproc
 649              		@ args = 0, pretend = 0, frame = 8
 650              		@ frame_needed = 0, uses_anonymous_args = 0
 651              	.LVL51:
 195:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 652              		.loc 1 195 0
 653 0000 C0F30723 		ubfx	r3, r0, #8, #8
 654 0004 C3EB0313 		rsb	r3, r3, r3, lsl #4
 655 0008 53FA80F3 		uxtab	r3, r3, r0
 656 000c DBB2     		uxtb	r3, r3
 657              	.LVL52:
 194:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 658              		.loc 1 194 0
 659 000e 37B5     		push	{r0, r1, r2, r4, r5, lr}
 660              		.cfi_def_cfa_offset 24
 661              		.cfi_offset 4, -12
 662              		.cfi_offset 5, -8
 663              		.cfi_offset 14, -4
 664              	.LBB2:
 196:tmk_core/common/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 197:tmk_core/common/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 198:tmk_core/common/action_layer.c **** 
 199:tmk_core/common/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 200:tmk_core/common/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 665              		.loc 1 200 0
 666 0010 03F00702 		and	r2, r3, #7
 667 0014 0120     		movs	r0, #1
 668 0016 9040     		lsls	r0, r0, r2
 669 0018 DB08     		lsrs	r3, r3, #3
 670              	.LVL53:
 671 001a 0A4A     		ldr	r2, .L52
 672 001c 03EB8303 		add	r3, r3, r3, lsl #2
 673 0020 C0B2     		uxtb	r0, r0
 674 0022 1344     		add	r3, r3, r2
 675 0024 0024     		movs	r4, #0
 676              	.LVL54:
 677              	.L50:
 678              		.loc 1 200 0 is_stmt 0 discriminator 3
 679 0026 13F8015F 		ldrb	r5, [r3, #1]!	@ zero_extendqisi2
 680 002a 21FA04F2 		lsr	r2, r1, r4
 681 002e 42F30002 		sbfx	r2, r2, #0, #1
 682 0032 6A40     		eors	r2, r2, r5
 683 0034 0240     		ands	r2, r2, r0
 684 0036 0134     		adds	r4, r4, #1
 685              	.LVL55:
 686 0038 6A40     		eors	r2, r2, r5
 199:tmk_core/common/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 687              		.loc 1 199 0 is_stmt 1 discriminator 3
 688 003a 052C     		cmp	r4, #5
 689              		.loc 1 200 0 discriminator 3
 690 003c 1A70     		strb	r2, [r3]
 199:tmk_core/common/action_layer.c ****         source_layers_cache[storage_row][bit_number] ^= (-((layer & (1U << bit_number)) != 0) ^ sou
 691              		.loc 1 199 0 discriminator 3
 692 003e F2D1     		bne	.L50
 693              	.LBE2:
 201:tmk_core/common/action_layer.c ****     }
 202:tmk_core/common/action_layer.c **** }
 694              		.loc 1 202 0
 695 0040 03B0     		add	sp, sp, #12
 696              		.cfi_def_cfa_offset 12
 697              		@ sp needed
 698 0042 30BD     		pop	{r4, r5, pc}
 699              	.L53:
 700              		.align	2
 701              	.L52:
 702 0044 07000000 		.word	.LANCHOR0+7
 703              		.cfi_endproc
 704              	.LFE25:
 706              		.section	.text.read_source_layers_cache,"ax",%progbits
 707              		.align	1
 708              		.global	read_source_layers_cache
 709              		.syntax unified
 710              		.thumb
 711              		.thumb_func
 712              		.fpu fpv4-sp-d16
 714              	read_source_layers_cache:
 715              	.LFB26:
 203:tmk_core/common/action_layer.c **** 
 204:tmk_core/common/action_layer.c **** /** \brief read source layers cache
 205:tmk_core/common/action_layer.c ****  *
 206:tmk_core/common/action_layer.c ****  * reads the cached keys stored when the layer was changed
 207:tmk_core/common/action_layer.c ****  */
 208:tmk_core/common/action_layer.c **** uint8_t read_source_layers_cache(keypos_t key) {
 716              		.loc 1 208 0
 717              		.cfi_startproc
 718              		@ args = 0, pretend = 0, frame = 8
 719              		@ frame_needed = 0, uses_anonymous_args = 0
 209:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 720              		.loc 1 209 0
 721 0000 C0F30723 		ubfx	r3, r0, #8, #8
 722 0004 C3EB0313 		rsb	r3, r3, r3, lsl #4
 208:tmk_core/common/action_layer.c ****     const uint8_t key_number  = key.col + (key.row * MATRIX_COLS);
 723              		.loc 1 208 0
 724 0008 13B5     		push	{r0, r1, r4, lr}
 725              		.cfi_def_cfa_offset 16
 726              		.cfi_offset 4, -8
 727              		.cfi_offset 14, -4
 728              		.loc 1 209 0
 729 000a 53FA80F0 		uxtab	r0, r3, r0
 730 000e C0B2     		uxtb	r0, r0
 731              	.LVL56:
 210:tmk_core/common/action_layer.c ****     const uint8_t storage_row = key_number / 8;
 211:tmk_core/common/action_layer.c ****     const uint8_t storage_bit = key_number % 8;
 732              		.loc 1 211 0
 733 0010 00F00704 		and	r4, r0, #7
 734              	.LVL57:
 735 0014 0949     		ldr	r1, .L57
 736 0016 C008     		lsrs	r0, r0, #3
 737              	.LVL58:
 738 0018 00EB8000 		add	r0, r0, r0, lsl #2
 739 001c 0022     		movs	r2, #0
 740 001e 0144     		add	r1, r1, r0
 212:tmk_core/common/action_layer.c ****     uint8_t       layer       = 0;
 741              		.loc 1 212 0
 742 0020 1046     		mov	r0, r2
 743              	.LVL59:
 744              	.L55:
 745              	.LBB3:
 213:tmk_core/common/action_layer.c **** 
 214:tmk_core/common/action_layer.c ****     for (uint8_t bit_number = 0; bit_number < MAX_LAYER_BITS; bit_number++) {
 215:tmk_core/common/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 746              		.loc 1 215 0 discriminator 3
 747 0022 8B5C     		ldrb	r3, [r1, r2]	@ zero_extendqisi2
 748 0024 E340     		lsrs	r3, r3, r4
 749 0026 03F00103 		and	r3, r3, #1
 750 002a 9340     		lsls	r3, r3, r2
 751 002c 0132     		adds	r2, r2, #1
 752              	.LVL60:
 753 002e 1843     		orrs	r0, r0, r3
 754              	.LVL61:
 214:tmk_core/common/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 755              		.loc 1 214 0 discriminator 3
 756 0030 052A     		cmp	r2, #5
 757              		.loc 1 215 0 discriminator 3
 758 0032 C0B2     		uxtb	r0, r0
 759              	.LVL62:
 214:tmk_core/common/action_layer.c ****         layer |= ((source_layers_cache[storage_row][bit_number] & (1U << storage_bit)) != 0) << bit
 760              		.loc 1 214 0 discriminator 3
 761 0034 F5D1     		bne	.L55
 762              	.LBE3:
 216:tmk_core/common/action_layer.c ****     }
 217:tmk_core/common/action_layer.c **** 
 218:tmk_core/common/action_layer.c ****     return layer;
 219:tmk_core/common/action_layer.c **** }
 763              		.loc 1 219 0
 764 0036 02B0     		add	sp, sp, #8
 765              		.cfi_def_cfa_offset 8
 766              		@ sp needed
 767 0038 10BD     		pop	{r4, pc}
 768              	.LVL63:
 769              	.L58:
 770 003a 00BF     		.align	2
 771              	.L57:
 772 003c 08000000 		.word	.LANCHOR0+8
 773              		.cfi_endproc
 774              	.LFE26:
 776              		.section	.text.layer_switch_get_layer,"ax",%progbits
 777              		.align	1
 778              		.global	layer_switch_get_layer
 779              		.syntax unified
 780              		.thumb
 781              		.thumb_func
 782              		.fpu fpv4-sp-d16
 784              	layer_switch_get_layer:
 785              	.LFB28:
 220:tmk_core/common/action_layer.c **** #endif
 221:tmk_core/common/action_layer.c **** 
 222:tmk_core/common/action_layer.c **** /** \brief Store or get action (FIXME: Needs better summary)
 223:tmk_core/common/action_layer.c ****  *
 224:tmk_core/common/action_layer.c ****  * Make sure the action triggered when the key is released is the same
 225:tmk_core/common/action_layer.c ****  * one as the one triggered on press. It's important for the mod keys
 226:tmk_core/common/action_layer.c ****  * when the layer is switched after the down event but before the up
 227:tmk_core/common/action_layer.c ****  * event as they may get stuck otherwise.
 228:tmk_core/common/action_layer.c ****  */
 229:tmk_core/common/action_layer.c **** action_t store_or_get_action(bool pressed, keypos_t key) {
 230:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 231:tmk_core/common/action_layer.c ****     if (disable_action_cache) {
 232:tmk_core/common/action_layer.c ****         return layer_switch_get_action(key);
 233:tmk_core/common/action_layer.c ****     }
 234:tmk_core/common/action_layer.c **** 
 235:tmk_core/common/action_layer.c ****     uint8_t layer;
 236:tmk_core/common/action_layer.c **** 
 237:tmk_core/common/action_layer.c ****     if (pressed) {
 238:tmk_core/common/action_layer.c ****         layer = layer_switch_get_layer(key);
 239:tmk_core/common/action_layer.c ****         update_source_layers_cache(key, layer);
 240:tmk_core/common/action_layer.c ****     } else {
 241:tmk_core/common/action_layer.c ****         layer = read_source_layers_cache(key);
 242:tmk_core/common/action_layer.c ****     }
 243:tmk_core/common/action_layer.c ****     return action_for_key(layer, key);
 244:tmk_core/common/action_layer.c **** #else
 245:tmk_core/common/action_layer.c ****     return layer_switch_get_action(key);
 246:tmk_core/common/action_layer.c **** #endif
 247:tmk_core/common/action_layer.c **** }
 248:tmk_core/common/action_layer.c **** 
 249:tmk_core/common/action_layer.c **** /** \brief Layer switch get layer
 250:tmk_core/common/action_layer.c ****  *
 251:tmk_core/common/action_layer.c ****  * Gets the layer based on key info
 252:tmk_core/common/action_layer.c ****  */
 253:tmk_core/common/action_layer.c **** uint8_t layer_switch_get_layer(keypos_t key) {
 786              		.loc 1 253 0
 787              		.cfi_startproc
 788              		@ args = 0, pretend = 0, frame = 8
 789              		@ frame_needed = 0, uses_anonymous_args = 0
 790              	.LVL64:
 791 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 792              		.cfi_def_cfa_offset 24
 793              		.cfi_offset 4, -16
 794              		.cfi_offset 5, -12
 795              		.cfi_offset 6, -8
 796              		.cfi_offset 14, -4
 254:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
 255:tmk_core/common/action_layer.c ****     action_t action;
 256:tmk_core/common/action_layer.c ****     action.code = ACTION_TRANSPARENT;
 257:tmk_core/common/action_layer.c **** 
 258:tmk_core/common/action_layer.c ****     layer_state_t layers = layer_state | default_layer_state;
 797              		.loc 1 258 0
 798 0002 0D4B     		ldr	r3, .L68
 253:tmk_core/common/action_layer.c **** #ifndef NO_ACTION_LAYER
 799              		.loc 1 253 0
 800 0004 ADF80400 		strh	r0, [sp, #4]	@ movhi
 801              		.loc 1 258 0
 802 0008 D3E90036 		ldrd	r3, r6, [r3]
 803 000c 1F24     		movs	r4, #31
 804 000e 1E43     		orrs	r6, r6, r3
 805              	.LVL65:
 806              	.L61:
 807              	.LBB4:
 259:tmk_core/common/action_layer.c ****     /* check top layer first */
 260:tmk_core/common/action_layer.c ****     for (int8_t i = sizeof(layer_state_t) * 8 - 1; i >= 0; i--) {
 261:tmk_core/common/action_layer.c ****         if (layers & (1UL << i)) {
 808              		.loc 1 261 0
 809 0010 26FA04F3 		lsr	r3, r6, r4
 810 0014 DB07     		lsls	r3, r3, #31
 811 0016 E5B2     		uxtb	r5, r4
 812 0018 06D4     		bmi	.L60
 813              	.L63:
 814              	.LVL66:
 260:tmk_core/common/action_layer.c ****         if (layers & (1UL << i)) {
 815              		.loc 1 260 0
 816 001a 14F1FF34 		adds	r4, r4, #-1
 817              	.LVL67:
 818 001e F7D2     		bcs	.L61
 819              	.LBE4:
 262:tmk_core/common/action_layer.c ****             action = action_for_key(i, key);
 263:tmk_core/common/action_layer.c ****             if (action.code != ACTION_TRANSPARENT) {
 264:tmk_core/common/action_layer.c ****                 return i;
 265:tmk_core/common/action_layer.c ****             }
 266:tmk_core/common/action_layer.c ****         }
 267:tmk_core/common/action_layer.c ****     }
 268:tmk_core/common/action_layer.c ****     /* fall back to layer 0 */
 269:tmk_core/common/action_layer.c ****     return 0;
 820              		.loc 1 269 0
 821 0020 0025     		movs	r5, #0
 822              	.LVL68:
 823              	.L62:
 270:tmk_core/common/action_layer.c **** #else
 271:tmk_core/common/action_layer.c ****     return biton32(default_layer_state);
 272:tmk_core/common/action_layer.c **** #endif
 273:tmk_core/common/action_layer.c **** }
 824              		.loc 1 273 0
 825 0022 2846     		mov	r0, r5
 826              	.LVL69:
 827 0024 02B0     		add	sp, sp, #8
 828              		.cfi_remember_state
 829              		.cfi_def_cfa_offset 16
 830              		@ sp needed
 831 0026 70BD     		pop	{r4, r5, r6, pc}
 832              	.LVL70:
 833              	.L60:
 834              		.cfi_restore_state
 835              	.LBB5:
 262:tmk_core/common/action_layer.c ****             action = action_for_key(i, key);
 836              		.loc 1 262 0
 837 0028 0199     		ldr	r1, [sp, #4]
 838 002a 2846     		mov	r0, r5
 839              	.LVL71:
 840 002c FFF7FEFF 		bl	action_for_key
 841              	.LVL72:
 263:tmk_core/common/action_layer.c ****                 return i;
 842              		.loc 1 263 0
 843 0030 80B2     		uxth	r0, r0
 844              	.LVL73:
 845 0032 0128     		cmp	r0, #1
 846 0034 F1D0     		beq	.L63
 847 0036 F4E7     		b	.L62
 848              	.L69:
 849              		.align	2
 850              	.L68:
 851 0038 00000000 		.word	.LANCHOR0
 852              	.LBE5:
 853              		.cfi_endproc
 854              	.LFE28:
 856              		.section	.text.layer_switch_get_action,"ax",%progbits
 857              		.align	1
 858              		.global	layer_switch_get_action
 859              		.syntax unified
 860              		.thumb
 861              		.thumb_func
 862              		.fpu fpv4-sp-d16
 864              	layer_switch_get_action:
 865              	.LFB29:
 274:tmk_core/common/action_layer.c **** 
 275:tmk_core/common/action_layer.c **** /** \brief Layer switch get layer
 276:tmk_core/common/action_layer.c ****  *
 277:tmk_core/common/action_layer.c ****  * Gets action code based on key position
 278:tmk_core/common/action_layer.c ****  */
 279:tmk_core/common/action_layer.c **** action_t layer_switch_get_action(keypos_t key) { return action_for_key(layer_switch_get_layer(key),
 866              		.loc 1 279 0
 867              		.cfi_startproc
 868              		@ args = 0, pretend = 0, frame = 8
 869              		@ frame_needed = 0, uses_anonymous_args = 0
 870 0000 07B5     		push	{r0, r1, r2, lr}
 871              		.cfi_def_cfa_offset 16
 872              		.cfi_offset 14, -4
 873              		.loc 1 279 0
 874 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 875 0006 0198     		ldr	r0, [sp, #4]
 876 0008 FFF7FEFF 		bl	layer_switch_get_layer
 877              	.LVL74:
 878 000c 0199     		ldr	r1, [sp, #4]
 879 000e 03B0     		add	sp, sp, #12
 880              		.cfi_def_cfa_offset 4
 881              		@ sp needed
 882 0010 5DF804EB 		ldr	lr, [sp], #4
 883              		.cfi_restore 14
 884              		.cfi_def_cfa_offset 0
 885 0014 FFF7FEBF 		b	action_for_key
 886              	.LVL75:
 887              		.cfi_endproc
 888              	.LFE29:
 890              		.section	.text.store_or_get_action,"ax",%progbits
 891              		.align	1
 892              		.global	store_or_get_action
 893              		.syntax unified
 894              		.thumb
 895              		.thumb_func
 896              		.fpu fpv4-sp-d16
 898              	store_or_get_action:
 899              	.LFB27:
 229:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 900              		.loc 1 229 0
 901              		.cfi_startproc
 902              		@ args = 0, pretend = 0, frame = 8
 903              		@ frame_needed = 0, uses_anonymous_args = 0
 904              	.LVL76:
 905 0000 13B5     		push	{r0, r1, r4, lr}
 906              		.cfi_def_cfa_offset 16
 907              		.cfi_offset 4, -8
 908              		.cfi_offset 14, -4
 231:tmk_core/common/action_layer.c ****         return layer_switch_get_action(key);
 909              		.loc 1 231 0
 910 0002 104B     		ldr	r3, .L75
 229:tmk_core/common/action_layer.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 911              		.loc 1 229 0
 912 0004 ADF80410 		strh	r1, [sp, #4]	@ movhi
 231:tmk_core/common/action_layer.c ****         return layer_switch_get_action(key);
 913              		.loc 1 231 0
 914 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 915 000a 2BB1     		cbz	r3, .L72
 232:tmk_core/common/action_layer.c ****     }
 916              		.loc 1 232 0
 917 000c 0198     		ldr	r0, [sp, #4]
 918              	.LVL77:
 247:tmk_core/common/action_layer.c **** 
 919              		.loc 1 247 0
 920 000e 02B0     		add	sp, sp, #8
 921              		.cfi_remember_state
 922              		.cfi_def_cfa_offset 8
 923              		@ sp needed
 924 0010 BDE81040 		pop	{r4, lr}
 925              		.cfi_restore 14
 926              		.cfi_restore 4
 927              		.cfi_def_cfa_offset 0
 232:tmk_core/common/action_layer.c ****     }
 928              		.loc 1 232 0
 929 0014 FFF7FEBF 		b	layer_switch_get_action
 930              	.LVL78:
 931              	.L72:
 932              		.cfi_restore_state
 237:tmk_core/common/action_layer.c ****         layer = layer_switch_get_layer(key);
 933              		.loc 1 237 0
 934 0018 70B1     		cbz	r0, .L73
 238:tmk_core/common/action_layer.c ****         update_source_layers_cache(key, layer);
 935              		.loc 1 238 0
 936 001a 0198     		ldr	r0, [sp, #4]
 937              	.LVL79:
 938 001c FFF7FEFF 		bl	layer_switch_get_layer
 939              	.LVL80:
 940 0020 0446     		mov	r4, r0
 941              	.LVL81:
 239:tmk_core/common/action_layer.c ****     } else {
 942              		.loc 1 239 0
 943 0022 0146     		mov	r1, r0
 944 0024 0198     		ldr	r0, [sp, #4]
 945              	.LVL82:
 946 0026 FFF7FEFF 		bl	update_source_layers_cache
 947              	.LVL83:
 948              	.L74:
 243:tmk_core/common/action_layer.c **** #else
 949              		.loc 1 243 0
 950 002a 0199     		ldr	r1, [sp, #4]
 951 002c 2046     		mov	r0, r4
 247:tmk_core/common/action_layer.c **** 
 952              		.loc 1 247 0
 953 002e 02B0     		add	sp, sp, #8
 954              		.cfi_remember_state
 955              		.cfi_def_cfa_offset 8
 956              		@ sp needed
 957 0030 BDE81040 		pop	{r4, lr}
 958              		.cfi_restore 14
 959              		.cfi_restore 4
 960              		.cfi_def_cfa_offset 0
 961              	.LVL84:
 243:tmk_core/common/action_layer.c **** #else
 962              		.loc 1 243 0
 963 0034 FFF7FEBF 		b	action_for_key
 964              	.LVL85:
 965              	.L73:
 966              		.cfi_restore_state
 241:tmk_core/common/action_layer.c ****     }
 967              		.loc 1 241 0
 968 0038 0198     		ldr	r0, [sp, #4]
 969              	.LVL86:
 970 003a FFF7FEFF 		bl	read_source_layers_cache
 971              	.LVL87:
 972 003e 0446     		mov	r4, r0
 973              	.LVL88:
 974 0040 F3E7     		b	.L74
 975              	.L76:
 976 0042 00BF     		.align	2
 977              	.L75:
 978 0044 00000000 		.word	disable_action_cache
 979              		.cfi_endproc
 980              	.LFE27:
 982              		.global	source_layers_cache
 983              		.global	layer_state
 984              		.global	default_layer_state
 985              		.bss
 986              		.align	2
 987              		.set	.LANCHOR0,. + 0
 990              	default_layer_state:
 991 0000 00000000 		.space	4
 994              	layer_state:
 995 0004 00000000 		.space	4
 998              	source_layers_cache:
 999 0008 00000000 		.space	50
 999      00000000 
 999      00000000 
 999      00000000 
 999      00000000 
 1000              		.text
 1001              	.Letext0:
 1002              		.file 2 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 1003              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 1004              		.file 4 "tmk_core/common/keyboard.h"
 1005              		.file 5 "tmk_core/common/action_code.h"
 1006              		.file 6 "tmk_core/common/action_layer.h"
 1007              		.file 7 "tmk_core/common/action.h"
 1008              		.file 8 "tmk_core/common/debug.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action_layer.c
/var/tmp//ccXYu6Ez.s:18     .text.default_layer_state_set_user:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:25     .text.default_layer_state_set_user:0000000000000000 default_layer_state_set_user
/var/tmp//ccXYu6Ez.s:25     .text.default_layer_state_set_user:0000000000000000 default_layer_state_set_user.localalias.0
/var/tmp//ccXYu6Ez.s:41     .text.default_layer_state_set_kb:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:48     .text.default_layer_state_set_kb:0000000000000000 default_layer_state_set_kb
/var/tmp//ccXYu6Ez.s:67     .text.default_layer_state_set:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:73     .text.default_layer_state_set:0000000000000000 default_layer_state_set
/var/tmp//ccXYu6Ez.s:101    .text.default_layer_state_set:0000000000000014 $d
/var/tmp//ccXYu6Ez.s:106    .text.default_layer_debug:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:113    .text.default_layer_debug:0000000000000000 default_layer_debug
/var/tmp//ccXYu6Ez.s:126    .text.default_layer_set:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:133    .text.default_layer_set:0000000000000000 default_layer_set
/var/tmp//ccXYu6Ez.s:148    .text.default_layer_or:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:155    .text.default_layer_or:0000000000000000 default_layer_or
/var/tmp//ccXYu6Ez.s:173    .text.default_layer_or:000000000000000c $d
/var/tmp//ccXYu6Ez.s:178    .text.default_layer_and:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:185    .text.default_layer_and:0000000000000000 default_layer_and
/var/tmp//ccXYu6Ez.s:203    .text.default_layer_and:000000000000000c $d
/var/tmp//ccXYu6Ez.s:208    .text.default_layer_xor:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:215    .text.default_layer_xor:0000000000000000 default_layer_xor
/var/tmp//ccXYu6Ez.s:233    .text.default_layer_xor:000000000000000c $d
/var/tmp//ccXYu6Ez.s:238    .text.layer_state_set_user:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:245    .text.layer_state_set_user:0000000000000000 layer_state_set_user
/var/tmp//ccXYu6Ez.s:256    .text.layer_state_set_kb:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:263    .text.layer_state_set_kb:0000000000000000 layer_state_set_kb
/var/tmp//ccXYu6Ez.s:283    .text.layer_state_set:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:290    .text.layer_state_set:0000000000000000 layer_state_set
/var/tmp//ccXYu6Ez.s:318    .text.layer_state_set:0000000000000014 $d
/var/tmp//ccXYu6Ez.s:323    .text.layer_clear:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:330    .text.layer_clear:0000000000000000 layer_clear
/var/tmp//ccXYu6Ez.s:345    .text.layer_state_cmp:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:352    .text.layer_state_cmp:0000000000000000 layer_state_cmp
/var/tmp//ccXYu6Ez.s:379    .text.layer_state_is:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:386    .text.layer_state_is:0000000000000000 layer_state_is
/var/tmp//ccXYu6Ez.s:404    .text.layer_state_is:000000000000000c $d
/var/tmp//ccXYu6Ez.s:409    .text.layer_move:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:416    .text.layer_move:0000000000000000 layer_move
/var/tmp//ccXYu6Ez.s:434    .text.layer_on:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:441    .text.layer_on:0000000000000000 layer_on
/var/tmp//ccXYu6Ez.s:461    .text.layer_on:0000000000000010 $d
/var/tmp//ccXYu6Ez.s:466    .text.layer_off:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:473    .text.layer_off:0000000000000000 layer_off
/var/tmp//ccXYu6Ez.s:493    .text.layer_off:0000000000000014 $d
/var/tmp//ccXYu6Ez.s:498    .text.layer_invert:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:505    .text.layer_invert:0000000000000000 layer_invert
/var/tmp//ccXYu6Ez.s:525    .text.layer_invert:0000000000000010 $d
/var/tmp//ccXYu6Ez.s:530    .text.layer_or:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:537    .text.layer_or:0000000000000000 layer_or
/var/tmp//ccXYu6Ez.s:555    .text.layer_or:000000000000000c $d
/var/tmp//ccXYu6Ez.s:560    .text.layer_and:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:567    .text.layer_and:0000000000000000 layer_and
/var/tmp//ccXYu6Ez.s:585    .text.layer_and:000000000000000c $d
/var/tmp//ccXYu6Ez.s:590    .text.layer_xor:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:597    .text.layer_xor:0000000000000000 layer_xor
/var/tmp//ccXYu6Ez.s:615    .text.layer_xor:000000000000000c $d
/var/tmp//ccXYu6Ez.s:620    .text.layer_debug:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:627    .text.layer_debug:0000000000000000 layer_debug
/var/tmp//ccXYu6Ez.s:638    .text.update_source_layers_cache:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:645    .text.update_source_layers_cache:0000000000000000 update_source_layers_cache
/var/tmp//ccXYu6Ez.s:702    .text.update_source_layers_cache:0000000000000044 $d
/var/tmp//ccXYu6Ez.s:707    .text.read_source_layers_cache:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:714    .text.read_source_layers_cache:0000000000000000 read_source_layers_cache
/var/tmp//ccXYu6Ez.s:772    .text.read_source_layers_cache:000000000000003c $d
/var/tmp//ccXYu6Ez.s:777    .text.layer_switch_get_layer:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:784    .text.layer_switch_get_layer:0000000000000000 layer_switch_get_layer
/var/tmp//ccXYu6Ez.s:851    .text.layer_switch_get_layer:0000000000000038 $d
/var/tmp//ccXYu6Ez.s:857    .text.layer_switch_get_action:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:864    .text.layer_switch_get_action:0000000000000000 layer_switch_get_action
/var/tmp//ccXYu6Ez.s:891    .text.store_or_get_action:0000000000000000 $t
/var/tmp//ccXYu6Ez.s:898    .text.store_or_get_action:0000000000000000 store_or_get_action
/var/tmp//ccXYu6Ez.s:978    .text.store_or_get_action:0000000000000044 $d
/var/tmp//ccXYu6Ez.s:998    .bss:0000000000000008 source_layers_cache
/var/tmp//ccXYu6Ez.s:994    .bss:0000000000000004 layer_state
/var/tmp//ccXYu6Ez.s:990    .bss:0000000000000000 default_layer_state
/var/tmp//ccXYu6Ez.s:986    .bss:0000000000000000 $d

UNDEFINED SYMBOLS
clear_keyboard_but_mods_and_keys
action_for_key
disable_action_cache

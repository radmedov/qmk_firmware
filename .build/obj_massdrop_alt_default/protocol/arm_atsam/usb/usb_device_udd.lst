   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"usb_device_udd.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.udd_ep_get_job,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	udd_ep_get_job:
  25              	.LFB144:
  26              		.file 1 "tmk_core/protocol/arm_atsam/usb/usb_device_udd.c"
   1:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
   2:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \file
   3:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
   4:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief USB Device wrapper layer for compliance with common driver UDD
   5:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
   6:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Copyright (C) 2014-2016 Atmel Corporation. All rights reserved.
   7:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
   8:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \asf_license_start
   9:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  10:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \page License
  11:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  12:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Redistribution and use in source and binary forms, with or without
  13:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * modification, are permitted provided that the following conditions are met:
  14:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  15:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    this list of conditions and the following disclaimer.
  17:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  18:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    and/or other materials provided with the distribution.
  21:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  22:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    from this software without specific prior written permission.
  24:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  25:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 4. This software may only be redistributed and used in connection with an
  26:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    Atmel microcontroller product.
  27:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  28:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * POSSIBILITY OF SUCH DAMAGE.
  39:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  40:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \asf_license_stop
  41:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  42:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  43:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /*
  44:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
  45:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  46:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "samd51j18a.h"
  47:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include <string.h>
  48:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include <stdlib.h>
  49:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  50:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** // Get USB device configuration
  51:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "conf_usb.h"
  52:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "udd.h"
  53:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "usb.h"
  54:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "status_codes.h"
  55:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  56:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
  57:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \ingroup usb_device_group
  58:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \defgroup usb_device_udd_group USB Device Driver Implement (UDD)
  59:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * USB low-level driver for USB device mode
  60:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
  61:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  62:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** // Check USB device configuration
  63:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_HS_SUPPORT
  64:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    error The High speed mode is not supported on this part, please remove USB_DEVICE_HS_SUPPORT i
  65:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  66:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  67:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** // Note: This driver is adapted for SAMD51
  68:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  69:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef UDC_REMOTEWAKEUP_LPM_ENABLE
  70:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define UDC_REMOTEWAKEUP_LPM_ENABLE()
  71:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  72:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef UDC_REMOTEWAKEUP_LPM_DISABLE
  73:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define UDC_REMOTEWAKEUP_LPM_DISABLE()
  74:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  75:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef UDC_SUSPEND_LPM_EVENT
  76:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define UDC_SUSPEND_LPM_EVENT()
  77:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  78:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  79:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /* for debug text */
  80:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEBUG
  81:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define dbg_print printf
  82:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #else
  83:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define dbg_print(...)
  84:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  85:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  86:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Maximum size of a transfer in multi-packet mode */
  87:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #define UDD_ENDPOINT_MAX_TRANS ((8 * 1024) - 1)
  88:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  89:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** USB software device instance structure */
  90:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** struct usb_module usb_device;
  91:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  92:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
  93:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Clock management
  94:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  95:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
  96:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  97:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  98:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #define UDD_CLOCK_GEN 0
  99:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 100:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static inline void udd_wait_clock_ready(void) {}
 101:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 102:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 103:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Power management
 104:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 105:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
 106:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 107:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #define udd_sleep_mode(arg)
 108:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** @} */
 109:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 110:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 111:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Control endpoint low level management routine.
 112:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 113:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * This function performs control endpoint management.
 114:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * It handles the SETUP/DATA/HANDSHAKE phases of a control transaction.
 115:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 116:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
 117:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 118:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 119:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 120:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Buffer to store the data received on control endpoint (SETUP/OUT endpoint 0)
 121:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 122:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Used to avoid a RAM buffer overflow in case of the payload buffer
 123:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * is smaller than control endpoint size
 124:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 125:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4)
 126:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint8_t udd_ctrl_buffer[USB_DEVICE_EP_CTRL_SIZE];
 127:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 128:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Bit definitions about endpoint control state machine for udd_ep_control_state */
 129:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** typedef enum {
 130:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_SETUP                  = 0,  //!< Wait a SETUP packet
 131:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_DATA_OUT               = 1,  //!< Wait a OUT data packet
 132:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_DATA_IN                = 2,  //!< Wait a IN data packet
 133:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP  = 3,  //!< Wait a IN ZLP packet
 134:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP = 4,  //!< Wait a OUT ZLP packet
 135:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_STALL_REQ              = 5,  //!< STALL enabled on IN & OUT packet
 136:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** } udd_ctrl_ep_state_t;
 137:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 138:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Global variable to give and record information of the set up request management */
 139:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** udd_ctrl_request_t udd_g_ctrlreq;
 140:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 141:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** State of the endpoint control management */
 142:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static udd_ctrl_ep_state_t udd_ep_control_state;
 143:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 144:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Total number of data received/sent during data packet phase with previous payload buffers */
 145:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static uint16_t udd_ctrl_prev_payload_nb_trans;
 146:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 147:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Number of data received/sent to/from udd_g_ctrlreq.payload buffer */
 148:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static uint16_t udd_ctrl_payload_nb_trans;
 149:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 150:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** @} */
 151:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 152:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 153:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Management of bulk/interrupt/isochronous endpoints
 154:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 155:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * The UDD manages the data transfer on endpoints:
 156:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * - Start data transfer on endpoint with USB Device DMA
 157:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * - Send a ZLP packet if requested
 158:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * - Call callback registered to signal end of transfer
 159:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * The transfer abort and stall feature are supported.
 160:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 161:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
 162:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 163:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 164:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 165:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Buffer to store the data received on bulk/interrupt endpoints
 166:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 167:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Used to avoid a RAM buffer overflow in case of the user buffer
 168:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * is smaller than endpoint size
 169:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 170:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \warning The protected interrupt endpoint size is 512 bytes maximum.
 171:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \warning The isochronous and endpoint is not protected by this system and
 172:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *          the user must always use a buffer corresponding at endpoint size.
 173:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 174:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 175:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #if (defined USB_DEVICE_LOW_SPEED)
 176:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4) uint8_t udd_ep_out_cache_buffer[USB_DEVICE_MAX_EP][8];
 177:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #elif (defined USB_DEVICE_HS_SUPPORT)
 178:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4) uint8_t udd_ep_out_cache_buffer[USB_DEVICE_MAX_EP][512];
 179:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #else
 180:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4) uint8_t udd_ep_out_cache_buffer[USB_DEVICE_MAX_EP][64];
 181:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 182:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 183:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Structure definition about job registered on an endpoint */
 184:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** typedef struct {
 185:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     union {
 186:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         //! Callback to call at the end of transfer
 187:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_callback_trans_t call_trans;
 188:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         //! Callback to call when the endpoint halt is cleared
 189:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_callback_halt_cleared_t call_nohalt;
 190:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     };
 191:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Buffer located in internal RAM to send or fill during job
 192:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t *buf;
 193:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Size of buffer to send or fill
 194:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     iram_size_t buf_size;
 195:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Total number of data transferred on endpoint
 196:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     iram_size_t nb_trans;
 197:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Endpoint size
 198:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t ep_size;
 199:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! A job is registered on this endpoint
 200:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t busy : 1;
 201:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! A short packet is requested for this job on endpoint IN
 202:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t b_shortpacket : 1;
 203:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! The cache buffer is currently used on endpoint OUT
 204:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t b_use_out_cache_buffer : 1;
 205:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** } udd_ep_job_t;
 206:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 207:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Array to register a job on bulk/interrupt/isochronous endpoint */
 208:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static udd_ep_job_t udd_ep_job[2 * USB_DEVICE_MAX_EP];
 209:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 210:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** @} */
 211:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 212:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 213:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Get the detailed job by endpoint number
 214:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] ep  Endpoint Address
 215:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \retval    pointer to an udd_ep_job_t structure instance
 216:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 217:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static udd_ep_job_t *udd_ep_get_job(udd_ep_id_t ep) {
  27              		.loc 1 217 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
 218:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((ep == 0) || (ep == 0x80)) {
  33              		.loc 1 218 0
  34 0000 10F07F03 		ands	r3, r0, #127
 219:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return NULL;
 220:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 221:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return &udd_ep_job[(2 * (ep & USB_EP_ADDR_MASK) + ((ep & USB_EP_DIR_IN) ? 1 : 0)) - 2];
  35              		.loc 1 221 0
  36 0004 1FBF     		itttt	ne
  37 0006 00F00F03 		andne	r3, r0, #15
  38 000a C009     		lsrne	r0, r0, #7
  39              	.LVL1:
  40 000c 00EB4300 		addne	r0, r0, r3, lsl #1
  41 0010 034A     		ldrne	r2, .L4
  42 0012 1DBF     		ittte	ne
  43 0014 0238     		subne	r0, r0, #2
  44 0016 1423     		movne	r3, #20
  45 0018 03FB0020 		mlane	r0, r3, r0, r2
 219:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return NULL;
  46              		.loc 1 219 0
  47 001c 1846     		moveq	r0, r3
 222:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 223:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
  48              		.loc 1 223 0
  49 001e 7047     		bx	lr
  50              	.L5:
  51              		.align	2
  52              	.L4:
  53 0020 00000000 		.word	.LANCHOR0
  54              		.cfi_endproc
  55              	.LFE144:
  57              		.section	.text.udd_ep_transfer_process,"ax",%progbits
  58              		.align	1
  59              		.syntax unified
  60              		.thumb
  61              		.thumb_func
  62              		.fpu fpv4-sp-d16
  64              	udd_ep_transfer_process:
  65              	.LFB147:
 224:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 225:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 226:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint IN process, continue to send packets or zero length packet
 227:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 228:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 229:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ep_trans_in_next(void *pointer) {
 230:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 231:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
 232:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                ep_size, nb_trans;
 233:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                next_trans;
 234:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep_num;
 235:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *                          ptr_job;
 236:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 237:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 238:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num  = ep & USB_EP_ADDR_MASK;
 239:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 240:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_size = ptr_job->ep_size;
 241:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 242:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_trans = ep_callback_para->sent_bytes;
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans += nb_trans;
 244:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 245:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Need to send other data */
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans != ptr_job->buf_size) {
 247:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 248:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 249:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum
 250:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * transfer size of UDD_ENDPOINT_MAX_TRANS Bytes */
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ep_size);
 252:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 253:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Need ZLP, if requested and last packet is not a short packet */
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = ptr_job->b_shortpacket && (0 == (next_trans % ep_size));
 255:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 256:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 257:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 258:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 259:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Need to send a ZLP after all data transfer */
 260:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->b_shortpacket) {
 261:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = false;
 262:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Start new transfer */
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 264:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 265:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 266:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 267:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Job complete then call callback */
 268:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = false;
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 270:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 271:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 272:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 273:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 274:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 275:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint OUT process, continue to receive packets or zero length packet
 276:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 277:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 278:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ep_trans_out_next(void *pointer) {
 279:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 280:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
 281:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                ep_size, nb_trans;
 282:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                next_trans;
 283:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep_num;
 284:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *                          ptr_job;
 285:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 286:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 287:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num  = ep & USB_EP_ADDR_MASK;
 288:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 289:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_size = ptr_job->ep_size;
 290:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 291:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_trans = ep_callback_para->received_bytes;
 292:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 293:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Can be necessary to copy data receive from cache buffer to user buffer */
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->b_use_out_cache_buffer) {
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 296:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 297:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 298:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans += nb_trans;
 300:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 301:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->nb_trans = ptr_job->buf_size;
 302:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 303:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 304:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* If all previous data requested are received and user buffer not full
 305:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****      * then need to receive other data */
 306:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((nb_trans == ep_callback_para->out_buffer_size) && (ptr_job->nb_trans != ptr_job->buf_size)
 307:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 308:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 309:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum transfer size
 310:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * of UDD_ENDPOINT_MAX_TRANS Bytes */
 311:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ep_size);
 312:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 313:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans -= next_trans % ep_size;
 314:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 315:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 316:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (next_trans < ep_size) {
 317:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Use the cache buffer for Bulk or Interrupt size endpoint */
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_use_out_cache_buffer = true;
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 320:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_tran
 322:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 323:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 324:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 325:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 326:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Job complete then call callback */
 327:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = false;
 328:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 330:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 331:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 332:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 333:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 334:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint Transfer Complete callback function, to do the next transfer depends on the 
 335:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 336:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 337:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 338:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ep_transfer_process(struct usb_module *module_inst, void *pointer) {
  66              		.loc 1 338 0
  67              		.cfi_startproc
  68              		@ args = 0, pretend = 0, frame = 0
  69              		@ frame_needed = 0, uses_anonymous_args = 0
  70              	.LVL2:
  71 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  72              		.cfi_def_cfa_offset 32
  73              		.cfi_offset 4, -32
  74              		.cfi_offset 5, -28
  75              		.cfi_offset 6, -24
  76              		.cfi_offset 7, -20
  77              		.cfi_offset 8, -16
  78              		.cfi_offset 9, -12
  79              		.cfi_offset 10, -8
  80              		.cfi_offset 14, -4
 339:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 340:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
  81              		.loc 1 340 0
  82 0004 8F79     		ldrb	r7, [r1, #6]	@ zero_extendqisi2
  83              	.LVL3:
  84 0006 3846     		mov	r0, r7
  85              	.LVL4:
 338:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
  86              		.loc 1 338 0
  87 0008 8846     		mov	r8, r1
  88 000a FFF7FEFF 		bl	udd_ep_get_job
  89              	.LVL5:
 341:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 342:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ep & USB_EP_DIR_IN) {
  90              		.loc 1 342 0
  91 000e 3A06     		lsls	r2, r7, #24
  92 0010 0446     		mov	r4, r0
  93 0012 068A     		ldrh	r6, [r0, #16]
  94 0014 90F812C0 		ldrb	ip, [r0, #18]	@ zero_extendqisi2
  95 0018 07F00F05 		and	r5, r7, #15
  96 001c D0E90230 		ldrd	r3, r0, [r0, #8]
  97 0020 3BD5     		bpl	.L7
  98              	.LVL6:
  99              	.LBB64:
 100              	.LBB65:
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 101              		.loc 1 243 0
 102 0022 4988     		ldrh	r1, [r1, #2]
 103              	.LVL7:
 104 0024 0144     		add	r1, r1, r0
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 105              		.loc 1 246 0
 106 0026 9942     		cmp	r1, r3
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 107              		.loc 1 243 0
 108 0028 E160     		str	r1, [r4, #12]
 109              	.LVL8:
 110 002a 0CF00200 		and	r0, ip, #2
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 111              		.loc 1 246 0
 112 002e 21D0     		beq	.L8
 247:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 113              		.loc 1 247 0
 114 0030 5B1A     		subs	r3, r3, r1
 115 0032 9BB2     		uxth	r3, r3
 116              	.LVL9:
 248:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum
 117              		.loc 1 248 0
 118 0034 B3F5005F 		cmp	r3, #8192
 119 0038 07D3     		bcc	.L9
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 120              		.loc 1 251 0
 121 003a 41F6FF73 		movw	r3, #8191
 122              	.LVL10:
 123 003e 93FBF6F2 		sdiv	r2, r3, r6
 124 0042 06FB1232 		mls	r2, r6, r2, r3
 125 0046 9B1A     		subs	r3, r3, r2
 126 0048 9BB2     		uxth	r3, r3
 127              	.LVL11:
 128              	.L9:
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 129              		.loc 1 254 0
 130 004a 38B1     		cbz	r0, .L10
 131 004c B3FBF6F0 		udiv	r0, r3, r6
 132 0050 06FB1030 		mls	r0, r6, r0, r3
 133 0054 80B2     		uxth	r0, r0
 134 0056 B0FA80F0 		clz	r0, r0
 135 005a 4009     		lsrs	r0, r0, #5
 136              	.L10:
 137 005c A27C     		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 138 005e 60F34102 		bfi	r2, r0, #1, #1
 139 0062 A274     		strb	r2, [r4, #18]
 255:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 140              		.loc 1 255 0
 141 0064 6268     		ldr	r2, [r4, #4]
 142              	.LVL12:
 143              	.L29:
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 144              		.loc 1 263 0
 145 0066 3448     		ldr	r0, .L32
 146 0068 0A44     		add	r2, r2, r1
 147 006a 2946     		mov	r1, r5
 148              	.LBE65:
 149              	.LBE64:
 343:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_trans_in_next(pointer);
 344:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 345:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_trans_out_next(pointer);
 346:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 347:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 150              		.loc 1 347 0
 151 006c BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 152              		.cfi_remember_state
 153              		.cfi_restore 14
 154              		.cfi_restore 10
 155              		.cfi_restore 9
 156              		.cfi_restore 8
 157              		.cfi_restore 7
 158              		.cfi_restore 6
 159              		.cfi_restore 5
 160              		.cfi_restore 4
 161              		.cfi_def_cfa_offset 0
 162              	.LVL13:
 163              	.LBB67:
 164              	.LBB66:
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 165              		.loc 1 263 0
 166 0070 FFF7FEBF 		b	usb_device_endpoint_write_buffer_job
 167              	.LVL14:
 168              	.L8:
 169              		.cfi_restore_state
 260:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = false;
 170              		.loc 1 260 0
 171 0074 30B1     		cbz	r0, .L11
 261:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Start new transfer */
 172              		.loc 1 261 0
 173 0076 6FF3410C 		bfc	ip, #1, #1
 174 007a 84F812C0 		strb	ip, [r4, #18]
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 175              		.loc 1 263 0
 176 007e 6268     		ldr	r2, [r4, #4]
 177 0080 0023     		movs	r3, #0
 178 0082 F0E7     		b	.L29
 179              	.L11:
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 180              		.loc 1 269 0
 181 0084 2368     		ldr	r3, [r4]
 268:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 182              		.loc 1 268 0
 183 0086 60F3000C 		bfi	ip, r0, #0, #1
 184 008a 84F812C0 		strb	ip, [r4, #18]
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 185              		.loc 1 269 0
 186 008e 002B     		cmp	r3, #0
 187 0090 4FD0     		beq	.L6
 270:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 188              		.loc 1 270 0
 189 0092 3A46     		mov	r2, r7
 190              	.LVL15:
 191              	.L30:
 192              	.LBE66:
 193              	.LBE67:
 194              		.loc 1 347 0
 195 0094 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 196              		.cfi_remember_state
 197              		.cfi_restore 14
 198              		.cfi_restore 10
 199              		.cfi_restore 9
 200              		.cfi_restore 8
 201              		.cfi_restore 7
 202              		.cfi_restore 6
 203              		.cfi_restore 5
 204              		.cfi_restore 4
 205              		.cfi_def_cfa_offset 0
 206              	.LVL16:
 207              	.LBB68:
 208              	.LBB69:
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 209              		.loc 1 329 0
 210 0098 1847     		bx	r3	@ indirect register sibling call
 211              	.LVL17:
 212              	.L7:
 213              		.cfi_restore_state
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 214              		.loc 1 294 0
 215 009a 1CF0040F 		tst	ip, #4
 291:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 216              		.loc 1 291 0
 217 009e B1F80090 		ldrh	r9, [r1]
 218              	.LVL18:
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 219              		.loc 1 294 0
 220 00a2 0BD0     		beq	.L14
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 221              		.loc 1 295 0
 222 00a4 B3FBF6F2 		udiv	r2, r3, r6
 223 00a8 06FB1232 		mls	r2, r6, r2, r3
 224 00ac 234B     		ldr	r3, .L32+4
 225 00ae 691E     		subs	r1, r5, #1
 226              	.LVL19:
 227 00b0 03EB8111 		add	r1, r3, r1, lsl #6
 228 00b4 6368     		ldr	r3, [r4, #4]
 229 00b6 1844     		add	r0, r0, r3
 230 00b8 FFF7FEFF 		bl	memcpy
 231              	.LVL20:
 232              	.L14:
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 233              		.loc 1 299 0
 234 00bc E368     		ldr	r3, [r4, #12]
 300:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->nb_trans = ptr_job->buf_size;
 235              		.loc 1 300 0
 236 00be A168     		ldr	r1, [r4, #8]
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 237              		.loc 1 299 0
 238 00c0 4B44     		add	r3, r3, r9
 300:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->nb_trans = ptr_job->buf_size;
 239              		.loc 1 300 0
 240 00c2 8B42     		cmp	r3, r1
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 241              		.loc 1 299 0
 242 00c4 E360     		str	r3, [r4, #12]
 301:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 243              		.loc 1 301 0
 244 00c6 88BF     		it	hi
 245 00c8 E160     		strhi	r1, [r4, #12]
 306:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 246              		.loc 1 306 0
 247 00ca B8F80430 		ldrh	r3, [r8, #4]
 248 00ce 4B45     		cmp	r3, r9
 249 00d0 25D1     		bne	.L16
 250 00d2 E268     		ldr	r2, [r4, #12]
 251 00d4 9142     		cmp	r1, r2
 252 00d6 22D0     		beq	.L16
 307:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 253              		.loc 1 307 0
 254 00d8 891A     		subs	r1, r1, r2
 255 00da 89B2     		uxth	r1, r1
 256              	.LVL21:
 308:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum transfer size
 257              		.loc 1 308 0
 258 00dc B1F5005F 		cmp	r1, #8192
 311:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 259              		.loc 1 311 0
 260 00e0 2ABF     		itet	cs
 261 00e2 41F6FF71 		movwcs	r1, #8191
 262              	.LVL22:
 313:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 263              		.loc 1 313 0
 264 00e6 B1FBF6F3 		udivcc	r3, r1, r6
 311:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 265              		.loc 1 311 0
 266 00ea 91FBF6F3 		sdivcs	r3, r1, r6
 313:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 267              		.loc 1 313 0
 268 00ee 06FB1313 		mls	r3, r6, r3, r1
 269 00f2 C91A     		subs	r1, r1, r3
 270 00f4 8BB2     		uxth	r3, r1
 271              	.LVL23:
 316:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Use the cache buffer for Bulk or Interrupt size endpoint */
 272              		.loc 1 316 0
 273 00f6 B342     		cmp	r3, r6
 274 00f8 0ED2     		bcs	.L19
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 275              		.loc 1 318 0
 276 00fa A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 277              	.LVL24:
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 278              		.loc 1 319 0
 279 00fc 0F4A     		ldr	r2, .L32+4
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 280              		.loc 1 318 0
 281 00fe 43F00403 		orr	r3, r3, #4
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 282              		.loc 1 319 0
 283 0102 691E     		subs	r1, r5, #1
 284              	.LVL25:
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 285              		.loc 1 318 0
 286 0104 A374     		strb	r3, [r4, #18]
 287              	.LVL26:
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 288              		.loc 1 319 0
 289 0106 02EB8112 		add	r2, r2, r1, lsl #6
 290 010a 3346     		mov	r3, r6
 291              	.L31:
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 292              		.loc 1 321 0
 293 010c 2946     		mov	r1, r5
 294 010e 0A48     		ldr	r0, .L32
 295              	.LBE69:
 296              	.LBE68:
 297              		.loc 1 347 0
 298 0110 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 299              		.cfi_remember_state
 300              		.cfi_restore 14
 301              		.cfi_restore 10
 302              		.cfi_restore 9
 303              		.cfi_restore 8
 304              		.cfi_restore 7
 305              		.cfi_restore 6
 306              		.cfi_restore 5
 307              		.cfi_restore 4
 308              		.cfi_def_cfa_offset 0
 309              	.LVL27:
 310              	.LBB71:
 311              	.LBB70:
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 312              		.loc 1 321 0
 313 0114 FFF7FEBF 		b	usb_device_endpoint_read_buffer_job
 314              	.LVL28:
 315              	.L19:
 316              		.cfi_restore_state
 317 0118 6068     		ldr	r0, [r4, #4]
 318 011a 0244     		add	r2, r2, r0
 319 011c F6E7     		b	.L31
 320              	.LVL29:
 321              	.L16:
 327:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 322              		.loc 1 327 0
 323 011e A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 324 0120 6FF30003 		bfc	r3, #0, #1
 325 0124 A374     		strb	r3, [r4, #18]
 328:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 326              		.loc 1 328 0
 327 0126 2368     		ldr	r3, [r4]
 328 0128 1BB1     		cbz	r3, .L6
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 329              		.loc 1 329 0
 330 012a 3A46     		mov	r2, r7
 331 012c E168     		ldr	r1, [r4, #12]
 332 012e 0020     		movs	r0, #0
 333 0130 B0E7     		b	.L30
 334              	.LVL30:
 335              	.L6:
 336              	.LBE70:
 337              	.LBE71:
 338              		.loc 1 347 0
 339 0132 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 340              	.LVL31:
 341              	.L33:
 342 0136 00BF     		.align	2
 343              	.L32:
 344 0138 00000000 		.word	usb_device
 345 013c 00000000 		.word	udd_ep_out_cache_buffer
 346              		.cfi_endproc
 347              	.LFE147:
 349              		.section	.text.udd_ctrl_stall_data,"ax",%progbits
 350              		.align	1
 351              		.syntax unified
 352              		.thumb
 353              		.thumb_func
 354              		.fpu fpv4-sp-d16
 356              	udd_ctrl_stall_data:
 357              	.LFB158:
 348:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_ep_abort(udd_ep_id_t ep) {
 350:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 351:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_abort_job(&usb_device, ep);
 353:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 354:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Job complete then call callback */
 355:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 356:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!ptr_job->busy) {
 357:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 358:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 359:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = false;
 360:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 361:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* It can be a Transfer or stall callback */
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_ABORT, ptr_job->nb_trans, ep);
 363:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 364:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 365:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_is_high_speed(void) { return false; }
 367:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint16_t udd_get_frame_number(void) { return usb_device_get_frame_number(&usb_device); }
 369:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint16_t udd_get_micro_frame_number(void) { return usb_device_get_micro_frame_number(&usb_device); 
 371:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_ep_free(udd_ep_id_t ep) {
 373:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 374:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep);
 375:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 376:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 377:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_abort(ep);
 378:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 379:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_address = ep;
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_type    = USB_DEVICE_ENDPOINT_TYPE_DISABLE;
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 382:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 383:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_disable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 384:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 385:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes, uint16_t MaxEndpointSize) {
 387:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep);
 389:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 390:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_address = ep;
 391:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (MaxEndpointSize <= 8) {
 393:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 394:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 16) {
 395:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_16_BYTE;
 396:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 32) {
 397:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_32_BYTE;
 398:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 64) {
 399:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_64_BYTE;
 400:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 128) {
 401:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_128_BYTE;
 402:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 256) {
 403:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_256_BYTE;
 404:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 512) {
 405:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_512_BYTE;
 406:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 1023) {
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_1023_BYTE;
 408:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 409:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 410:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job = udd_ep_get_job(ep);
 412:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 413:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 414:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     bmAttributes = bmAttributes & USB_EP_TYPE_MASK;
 415:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 416:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Check endpoint type */
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_EP_TYPE_ISOCHRONOUS == bmAttributes) {
 418:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 419:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_BULK == bmAttributes) {
 420:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_BULK;
 421:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_INTERRUPT == bmAttributes) {
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_INTERRUPT;
 423:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 424:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 425:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 426:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 427:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 428:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (STATUS_OK != usb_device_endpoint_set_config(&usb_device, &config_ep)) {
 430:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 431:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 432:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT, 
 433:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 434:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 435:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 436:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 437:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 438:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_is_halted(udd_ep_id_t ep) { return usb_device_endpoint_is_halted(&usb_device, ep); }
 440:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_set_halt(udd_ep_id_t ep) {
 442:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 443:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 445:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 446:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 447:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 448:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_halt(&usb_device, ep);
 449:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 450:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_abort(ep);
 451:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 452:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 453:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_clear_halt(udd_ep_id_t ep) {
 455:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 456:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t       ep_num = ep & USB_EP_ADDR_MASK;
 457:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 459:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 460:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 461:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 462:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 463:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_clear_halt(&usb_device, ep);
 464:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 465:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* If a job is register on clear halt action then execute callback */
 466:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 467:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy = false;
 468:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt();
 469:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 470:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 471:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 472:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 473:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_wait_stall_clear(udd_ep_id_t ep, udd_callback_halt_cleared_t callback) {
 475:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 476:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 477:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 478:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num = ep & USB_EP_ADDR_MASK;
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 480:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 481:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 482:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 485:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 486:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 487:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 488:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Wait clear halt endpoint */
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (usb_device_endpoint_is_halted(&usb_device, ep)) {
 490:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy        = true;
 492:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 493:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 494:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (usb_device_endpoint_is_configured(&usb_device, ep)) {
 495:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         callback(); /* Endpoint not halted then call directly callback */
 496:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 497:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 498:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 499:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 500:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 501:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 502:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 503:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint stall sending data
 504:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 505:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_stall_data(void) {
 358              		.loc 1 505 0
 359              		.cfi_startproc
 360              		@ args = 0, pretend = 0, frame = 0
 361              		@ frame_needed = 0, uses_anonymous_args = 0
 362 0000 10B5     		push	{r4, lr}
 363              		.cfi_def_cfa_offset 8
 364              		.cfi_offset 4, -8
 365              		.cfi_offset 14, -4
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 507:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 508:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_halt(&usb_device, USB_EP_DIR_IN);
 366              		.loc 1 508 0
 367 0002 074C     		ldr	r4, .L35
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 368              		.loc 1 506 0
 369 0004 074B     		ldr	r3, .L35+4
 370              		.loc 1 508 0
 371 0006 2046     		mov	r0, r4
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 372              		.loc 1 506 0
 373 0008 0522     		movs	r2, #5
 374              		.loc 1 508 0
 375 000a 8021     		movs	r1, #128
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 376              		.loc 1 506 0
 377 000c 83F8A020 		strb	r2, [r3, #160]
 378              		.loc 1 508 0
 379 0010 FFF7FEFF 		bl	usb_device_endpoint_set_halt
 380              	.LVL32:
 509:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_clear_halt(&usb_device, USB_EP_DIR_OUT);
 381              		.loc 1 509 0
 382 0014 2046     		mov	r0, r4
 383 0016 0021     		movs	r1, #0
 510:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 384              		.loc 1 510 0
 385 0018 BDE81040 		pop	{r4, lr}
 386              		.cfi_restore 14
 387              		.cfi_restore 4
 388              		.cfi_def_cfa_offset 0
 509:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_clear_halt(&usb_device, USB_EP_DIR_OUT);
 389              		.loc 1 509 0
 390 001c FFF7FEBF 		b	usb_device_endpoint_clear_halt
 391              	.LVL33:
 392              	.L36:
 393              		.align	2
 394              	.L35:
 395 0020 00000000 		.word	usb_device
 396 0024 00000000 		.word	.LANCHOR0
 397              		.cfi_endproc
 398              	.LFE158:
 400              		.section	.text._usb_on_wakeup,"ax",%progbits
 401              		.align	1
 402              		.syntax unified
 403              		.thumb
 404              		.thumb_func
 405              		.fpu fpv4-sp-d16
 407              	_usb_on_wakeup:
 408              	.LFB177:
 511:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket, uint8_t *buf, iram_size_t buf_size, udd_callbac
 513:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 514:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 515:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t      irqflags;
 516:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 517:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num = ep & USB_EP_ADDR_MASK;
 518:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((USB_DEVICE_MAX_EP < ep_num) || (udd_ep_is_halted(ep))) {
 520:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 521:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 522:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 523:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 524:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 525:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     irqflags = __get_PRIMASK();
 526:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __disable_irq();
 527:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 528:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 529:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 530:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __DMB();
 531:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __set_PRIMASK(irqflags);
 532:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 533:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 534:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 535:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = true;
 536:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 537:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __set_PRIMASK(irqflags);
 538:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 539:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* No job running, set up a new one */
 540:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->buf                    = buf;
 541:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->buf_size               = buf_size;
 542:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans               = 0;
 543:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->call_trans             = callback;
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_shortpacket          = b_shortpacket;
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 546:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 547:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Initialize value to simulate a empty transfer */
 548:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t next_trans;
 549:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ep & USB_EP_DIR_IN) {
 551:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 552:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 553:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 555:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = ptr_job->b_shortpacket && (0 == (next_trans % ptr_job->ep_size
 557:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 558:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = false; /* avoid to send zero length packet again */
 559:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans             = 0;
 560:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 561:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->busy = false;
 562:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 563:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 564:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 565:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return true;
 566:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return (STATUS_OK == usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->bu
 568:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 569:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 570:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 571:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 572:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* The USB hardware support a maximum transfer size
 573:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                  * of UDD_ENDPOINT_MAX_TRANS Bytes */
 574:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 575:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 576:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans -= next_trans % ptr_job->ep_size;
 577:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 578:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (next_trans < ptr_job->ep_size) {
 579:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->b_use_out_cache_buffer = true;
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_e
 581:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, &ptr_
 583:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 584:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 585:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->busy = false;
 586:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 587:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 588:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 589:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return true;
 590:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 591:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 592:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 593:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_set_address(uint8_t address) { usb_device_set_address(&usb_device, address); }
 595:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint8_t udd_getaddress(void) { return usb_device_get_address(&usb_device); }
 597:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 598:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_send_remotewakeup(void) {
 599:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t try
 600:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         = 5;
 601:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
 602:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     while (2 != usb_get_state_machine_status(&usb_device) && try --) {
 604:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 605:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 606:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 607:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 608:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_set_setup_payload(uint8_t *payload, uint16_t payload_size) {
 609:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload      = payload;
 610:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload_size = payload_size;
 611:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 612:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 613:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 614:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint translate the data in buffer into Device Request Struct
 615:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 616:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_fetch_ram(void) {
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bmRequestType = udd_ctrl_buffer[0];
 618:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wValue        = ((uint16_t)(udd_ctrl_buffer[3]) << 8) + udd_ctrl_buffer[2];
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 622:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 623:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 624:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 625:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint send out zero length packet
 626:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 627:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_send_zlp_in(void) {
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 630:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 631:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 632:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 633:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 634:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Process control endpoint IN transaction
 635:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 636:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_in_sent(void) {
 637:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     static bool b_shortpacket = false;
 638:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t    nb_remain;
 639:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
 641:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 642:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (0 == nb_remain) {
 643:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* All content of current buffer payload are sent Update number of total data sending by pr
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 646:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 647:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Generate an OUT ZLP for handshake phase */
 648:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
 649:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 650:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 651:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 652:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Need of new buffer because the data phase is not complete */
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((!udd_g_ctrlreq.over_under_run) || (!udd_g_ctrlreq.over_under_run())) {
 654:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 655:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Here nb_remain=0, this allows to send a IN ZLP */
 656:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 657:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* A new payload buffer is given */
 658:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans = 0;
 659:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             nb_remain                 = udd_g_ctrlreq.payload_size;
 660:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 661:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 662:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 663:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Continue transfer and send next data */
 664:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
 665:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_remain     = USB_DEVICE_EP_CTRL_SIZE;
 666:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         b_shortpacket = false;
 667:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 668:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         b_shortpacket = true;
 669:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 670:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 671:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Link payload buffer directly on USB hardware */
 672:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload + udd_ctrl_payload_n
 673:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 674:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_remain;
 675:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 676:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 677:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 678:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Process control endpoint OUT transaction
 679:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 680:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 681:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_out_received(void *pointer) {
 682:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 683:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 684:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t nb_data;
 685:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_data = ep_callback_para->received_bytes; /* Read data received during OUT phase */
 686:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
 688:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 689:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
 690:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 691:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     memcpy((uint8_t *)(udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans), udd_ctrl_buffer, nb_data
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 694:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) || (udd_g_ctrlreq.req.wLength <= (udd_ctrl_prev_payloa
 696:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 697:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * or all data are transferred */
 698:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 699:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Before send ZLP, call intermediate callback
 700:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * in case of data receive generate a stall */
 701:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.over_under_run) {
 703:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 704:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall ZLP */
 705:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 706:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall all packets on IN & OUT control endpoint */
 707:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_set_halt(0);
 708:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Ack reception of OUT to replace NAK by a STALL */
 709:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 710:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 711:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 712:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Send IN ZLP to ACK setup request */
 713:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_send_zlp_in();
 714:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 715:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 716:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 717:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
 718:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Overrun then request a new payload buffer */
 719:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (!udd_g_ctrlreq.over_under_run) {
 720:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No callback available to request a new payload buffer
 721:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Stall ZLP */
 722:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 723:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Stall all packets on IN & OUT control endpoint */
 724:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_set_halt(0);
 725:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 726:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 727:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (!udd_g_ctrlreq.over_under_run()) {
 728:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No new payload buffer delivered
 729:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Stall ZLP */
 730:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 731:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Stall all packets on IN & OUT control endpoint */
 732:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_set_halt(0);
 733:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 734:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 735:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* New payload buffer available
 736:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * Update number of total data received */
 737:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
 738:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 739:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Reinitialize reception on payload buffer */
 740:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_payload_nb_trans = 0;
 741:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL_SIZE);
 743:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 744:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 745:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 746:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 747:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint 0 (control) SETUP received callback
 748:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst pointer to USB module instance
 749:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 750:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_ep0_on_setup(struct usb_module *module_inst, void *pointer) {
 752:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 753:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
 755:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 756:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 757:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 758:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_control_state = UDD_EPCTRL_SETUP;
 759:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 760:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (8 != ep_callback_para->received_bytes) {
 761:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_stall_data();
 762:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 763:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 764:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_fetch_ram();
 765:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (false == udc_process_setup()) {
 766:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_stall_data();
 767:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 768:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (Udd_setup_is_in()) {
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_prev_payload_nb_trans = 0;
 770:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state           = UDD_EPCTRL_DATA_IN;
 772:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 773:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_in_sent();
 774:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 775:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (0 == udd_g_ctrlreq.req.wLength) {
 776:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_send_zlp_in();
 777:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 778:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_prev_payload_nb_trans = 0;
 780:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 781:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state           = UDD_EPCTRL_DATA_OUT;
 782:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Initialize buffer size and enable OUT bank */
 783:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_
 784:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 785:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 786:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 788:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 789:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 790:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint Process when underflow condition has occurred
 791:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 792:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 793:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_underflow(void *pointer) {
 794:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 795:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 796:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
 797:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop OUT transaction
 798:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * then stop to wait OUT data phase and wait IN ZLP handshake */
 799:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_send_zlp_in();
 800:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
 801:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A OUT handshake is waiting by device,
 802:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * but host want extra IN data then stall extra IN data */
 803:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
 804:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 805:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 806:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 807:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 808:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint Process when overflow condition has occurred
 809:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 810:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 811:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_overflow(void *pointer) {
 812:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 813:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 814:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) {
 815:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop IN transaction
 816:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * then stop to wait IN data phase and wait OUT ZLP handshake */
 817:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
 819:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 820:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * but host want extra OUT data then stall extra OUT data and following status stage */
 821:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
 822:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 823:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 824:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 825:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 826:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 827:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint transfer fail callback function
 828:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 829:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 830:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 831:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_ep0_on_tansfer_fail(struct usb_module *module_inst, void *pointer) {
 832:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 833:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ep_callback_para->endpoint_address & USB_EP_DIR_IN) {
 835:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 836:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 837:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_overflow(pointer);
 838:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 839:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 840:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 841:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 842:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 843:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint transfer complete callback function
 844:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 845:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 846:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 847:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_ep0_on_tansfer_ok(struct usb_module *module_inst, void *pointer) {
 848:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) { /* handshake Out for status stage */
 849:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_out_received(pointer);
 850:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) { /* handshake In for status stage */
 851:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_in_sent();
 852:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 853:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 854:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 855:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 856:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_control_state = UDD_EPCTRL_SETUP;
 857:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 859:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 860:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 861:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Enable Control Endpoint
 862:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 863:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 864:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_ep_enable(struct usb_module *module_inst) {
 865:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Device Endpoint0 Configuration */
 866:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep0;
 867:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 868:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep0);
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SI
 870:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 871:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 872:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(module_inst, udd_ctrl_buffer);
 873:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 874:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_RXSTP, _usb_
 875:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT, _usb_
 876:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL, _usb
 877:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_RXSTP);
 878:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 879:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 880:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 881:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 882:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Enable LPM feature
 883:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_lpm_mode(module_inst, USB_DEVICE_LPM_ACK);
 884:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 885:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 886:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_SETUP;
 887:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 888:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 889:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 890:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 891:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint Suspend callback function
 892:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 893:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 894:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 895:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_suspend(struct usb_module *module_inst, void *pointer) {
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 897:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 898:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 899:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SUSPEND_EVENT
 900:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_SUSPEND_EVENT();
 901:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 902:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 903:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 904:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 905:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_device_lpm_suspend(struct usb_module *module_inst, void *pointer) {
 906:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     dbg_print("LPM_SUSP\n");
 907:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 908:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t *lpm_wakeup_enable;
 909:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     lpm_wakeup_enable = (uint32_t *)pointer;
 910:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 911:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
 912:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 913:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 914:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 915:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //#warning Here the sleep mode must be choose to have a DFLL startup time < bmAttribut.HIRD
 916:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND_LPM);  // Enter in LPM SUSPEND mode
 917:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((*lpm_wakeup_enable)) {
 918:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         UDC_REMOTEWAKEUP_LPM_ENABLE();
 919:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 920:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!(*lpm_wakeup_enable)) {
 921:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         UDC_REMOTEWAKEUP_LPM_DISABLE();
 922:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 923:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_SUSPEND_LPM_EVENT();
 924:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 925:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 926:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 927:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 928:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 929:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint SOF callback function
 930:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 931:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 932:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 933:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_sof_notify(struct usb_module *module_inst, void *pointer) {
 934:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_sof_notify();
 935:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SOF_EVENT
 936:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_SOF_EVENT();
 937:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 938:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 939:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 940:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 941:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 942:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint Reset callback function
 943:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 944:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 945:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_bus_reset(struct usb_module *module_inst, void *pointer) {
 947:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 948:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_reset();
 949:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_address(module_inst, 0);
 950:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_ep_enable(module_inst);
 951:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 952:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 953:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 954:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 955:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint Wakeup callback function
 956:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 957:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 958:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 959:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_wakeup(struct usb_module *module_inst, void *pointer) {
 409              		.loc 1 959 0
 410              		.cfi_startproc
 411              		@ args = 0, pretend = 0, frame = 0
 412              		@ frame_needed = 0, uses_anonymous_args = 0
 413              	.LVL34:
 414 0000 10B5     		push	{r4, lr}
 415              		.cfi_def_cfa_offset 8
 416              		.cfi_offset 4, -8
 417              		.cfi_offset 14, -4
 960:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
 961:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 962:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 418              		.loc 1 962 0
 419 0002 064C     		ldr	r4, .L38
 420 0004 0221     		movs	r1, #2
 421              	.LVL35:
 422 0006 2046     		mov	r0, r4
 423              	.LVL36:
 424 0008 FFF7FEFF 		bl	usb_device_disable_callback
 425              	.LVL37:
 963:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 426              		.loc 1 963 0
 427 000c 2046     		mov	r0, r4
 428 000e 0421     		movs	r1, #4
 429 0010 FFF7FEFF 		bl	usb_device_enable_callback
 430              	.LVL38:
 964:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 965:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP, _usb_device_lpm_suspend)
 966:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
 967:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 968:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 969:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_RESUME_EVENT
 970:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_RESUME_EVENT();
 971:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 972:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 431              		.loc 1 972 0
 432 0014 BDE81040 		pop	{r4, lr}
 433              		.cfi_restore 14
 434              		.cfi_restore 4
 435              		.cfi_def_cfa_offset 0
 970:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 436              		.loc 1 970 0
 437 0018 FFF7FEBF 		b	main_resume_action
 438              	.LVL39:
 439              	.L39:
 440              		.align	2
 441              	.L38:
 442 001c 00000000 		.word	usb_device
 443              		.cfi_endproc
 444              	.LFE177:
 446              		.section	.text._usb_on_bus_reset,"ax",%progbits
 447              		.align	1
 448              		.syntax unified
 449              		.thumb
 450              		.thumb_func
 451              		.fpu fpv4-sp-d16
 453              	_usb_on_bus_reset:
 454              	.LFB176:
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 455              		.loc 1 946 0
 456              		.cfi_startproc
 457              		@ args = 0, pretend = 0, frame = 8
 458              		@ frame_needed = 0, uses_anonymous_args = 0
 459              	.LVL40:
 460 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 461              		.cfi_def_cfa_offset 24
 462              		.cfi_offset 4, -12
 463              		.cfi_offset 5, -8
 464              		.cfi_offset 14, -4
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 465              		.loc 1 946 0
 466 0002 0546     		mov	r5, r0
 948:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_address(module_inst, 0);
 467              		.loc 1 948 0
 468 0004 FFF7FEFF 		bl	udc_reset
 469              	.LVL41:
 949:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_ep_enable(module_inst);
 470              		.loc 1 949 0
 471 0008 2B68     		ldr	r3, [r5]
 472              	.LVL42:
 473              	.LBB76:
 474              	.LBB77:
 475              		.file 2 "tmk_core/protocol/arm_atsam/usb/usb.h"
   1:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
   2:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \file
   3:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
   4:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief SAM USB Driver
   5:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
   6:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Copyright (C) 2014-2016 Atmel Corporation. All rights reserved.
   7:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
   8:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \asf_license_start
   9:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  10:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \page License
  11:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  12:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Redistribution and use in source and binary forms, with or without
  13:tmk_core/protocol/arm_atsam/usb/usb.h ****  * modification, are permitted provided that the following conditions are met:
  14:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  15:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    this list of conditions and the following disclaimer.
  17:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  18:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    and/or other materials provided with the distribution.
  21:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  22:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    from this software without specific prior written permission.
  24:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  25:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 4. This software may only be redistributed and used in connection with an
  26:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    Atmel microcontroller product.
  27:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  28:tmk_core/protocol/arm_atsam/usb/usb.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:tmk_core/protocol/arm_atsam/usb/usb.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:tmk_core/protocol/arm_atsam/usb/usb.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:tmk_core/protocol/arm_atsam/usb/usb.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:tmk_core/protocol/arm_atsam/usb/usb.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:tmk_core/protocol/arm_atsam/usb/usb.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:tmk_core/protocol/arm_atsam/usb/usb.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:tmk_core/protocol/arm_atsam/usb/usb.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:tmk_core/protocol/arm_atsam/usb/usb.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:tmk_core/protocol/arm_atsam/usb/usb.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:tmk_core/protocol/arm_atsam/usb/usb.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  40:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \asf_license_stop
  41:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  42:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
  43:tmk_core/protocol/arm_atsam/usb/usb.h **** /*
  44:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
  45:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
  46:tmk_core/protocol/arm_atsam/usb/usb.h **** #ifndef USB_H_INCLUDED
  47:tmk_core/protocol/arm_atsam/usb/usb.h **** #define USB_H_INCLUDED
  48:tmk_core/protocol/arm_atsam/usb/usb.h **** 
  49:tmk_core/protocol/arm_atsam/usb/usb.h **** #ifdef __cplusplus
  50:tmk_core/protocol/arm_atsam/usb/usb.h **** extern "C" {
  51:tmk_core/protocol/arm_atsam/usb/usb.h **** #endif
  52:tmk_core/protocol/arm_atsam/usb/usb.h **** 
  53:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
  54:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \defgroup asfdoc_sam0_usb_group SAM Universal Serial Bus (USB)
  55:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  56:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The Universal Serial Bus (USB) module complies with the USB 2.1 specification.
  57:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  58:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The following peripherals are used by this module:
  59:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB (Universal Serial Bus)
  60:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  61:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The following devices can use this module:
  62:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - Atmel | SMART SAM D51
  63:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  64:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The USB module covers following mode:
  65:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_DEVICE_MODE
  66:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Device Mode
  67:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  68:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_HOST_MODE
  69:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Host Mode
  70:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  71:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  72:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The USB module covers following speed:
  73:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_HS_MODE
  74:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB High Speed (480Mbit/s)
  75:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  76:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Full Speed (12Mbit/s)
  77:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_LS_MODE
  78:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Low Speed (1.5Mbit/s)
  79:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  80:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  81:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_LPM_MODE
  82:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The USB module supports Link Power Management (LPM-L1) protocol.
  83:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  84:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  85:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB support needs whole set of enumeration process, to make the device
  86:tmk_core/protocol/arm_atsam/usb/usb.h ****  * recognizable and usable. The USB driver is designed to interface to the
  87:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB Stack in Atmel Software Framework (ASF).
  88:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  89:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_DEVICE_MODE
  90:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \section asfdoc_sam0_usb_device USB Device Mode
  91:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The ASF USB Device Stack has defined the USB Device Driver (UDD) interface,
  92:tmk_core/protocol/arm_atsam/usb/usb.h ****  * to support USB device operations. The USB module device driver complies with
  93:tmk_core/protocol/arm_atsam/usb/usb.h ****  * this interface, so that the USB Device Stack can work based on the
  94:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB module.
  95:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  96:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Refer to <a href="http://www.atmel.com/images/doc8360.pdf">
  97:tmk_core/protocol/arm_atsam/usb/usb.h ****  * "ASF - USB Device Stack"</a> for more details.
  98:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  99:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 100:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_HOST_MODE
 101:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \section adfdoc_sam0_usb_host USB Host Mode
 102:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The ASF USB Host Stack has defined the USB Host Driver (UHD) interface,
 103:tmk_core/protocol/arm_atsam/usb/usb.h ****  * to support USB host operations. The USB module host driver complies with
 104:tmk_core/protocol/arm_atsam/usb/usb.h ****  * this interface, so that the USB Host Stack can work based on the USB module.
 105:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 106:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Refer to <a href="http://www.atmel.com/images/doc8486.pdf">
 107:tmk_core/protocol/arm_atsam/usb/usb.h ****  * "ASF - USB Host Stack"</a> for more details.
 108:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
 109:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 110:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 111:tmk_core/protocol/arm_atsam/usb/usb.h **** /** Enum for the speed status for the USB module */
 112:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_speed {
 113:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_SPEED_LOW,
 114:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_SPEED_FULL,
 115:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 116:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 117:tmk_core/protocol/arm_atsam/usb/usb.h **** /** Enum for the possible callback types for the USB in host module */
 118:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_callback {
 119:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_SOF,
 120:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_RESET,
 121:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_WAKEUP,
 122:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_DNRSM,
 123:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_UPRSM,
 124:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_RAMACER,
 125:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_CONNECT,
 126:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_DISCONNECT,
 127:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_N,
 128:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 129:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 130:tmk_core/protocol/arm_atsam/usb/usb.h **** /** Enum for the possible callback types for the USB pipe in host module */
 131:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_pipe_callback {
 132:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE,
 133:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_ERROR,
 134:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_SETUP,
 135:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_STALL,
 136:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_N,
 137:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 138:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 139:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 140:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Host pipe types.
 141:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 142:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_pipe_type {
 143:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_DISABLE,
 144:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_CONTROL,
 145:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_ISO,
 146:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_BULK,
 147:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_INTERRUPT,
 148:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_EXTENDED,
 149:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 150:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 151:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 152:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Host pipe token types.
 153:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 154:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_pipe_token {
 155:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TOKEN_SETUP,
 156:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TOKEN_IN,
 157:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TOKEN_OUT,
 158:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 159:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 160:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 161:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Enumeration for the possible callback types for the USB in device module
 162:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 163:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_callback {
 164:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_SOF,
 165:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_RESET,
 166:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_WAKEUP,
 167:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_RAMACER,
 168:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_SUSPEND,
 169:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_LPMNYET,
 170:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_LPMSUSP,
 171:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_N,
 172:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 173:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 174:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 175:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Enumeration for the possible callback types for the USB endpoint in device module
 176:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 177:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_endpoint_callback {
 178:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_TRCPT,
 179:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL,
 180:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_RXSTP,
 181:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_STALL,
 182:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_EP_CALLBACK_N,
 183:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 184:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 185:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 186:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Device Endpoint types.
 187:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 188:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_endpoint_type {
 189:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_DISABLE,
 190:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_CONTROL,
 191:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS,
 192:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_BULK,
 193:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_INTERRUPT,
 194:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 195:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 196:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 197:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Endpoint Size
 198:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 199:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_endpoint_size {
 200:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_8_BYTE,
 201:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_16_BYTE,
 202:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_32_BYTE,
 203:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_64_BYTE,
 204:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_128_BYTE,
 205:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_256_BYTE,
 206:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_512_BYTE,
 207:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_1023_BYTE,
 208:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 209:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 210:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 211:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Link Power Management Handshake.
 212:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 213:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_lpm_mode {
 214:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_LPM_NOT_SUPPORT,
 215:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_LPM_ACK,
 216:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_LPM_NYET,
 217:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 218:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 219:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 220:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Module structure
 221:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 222:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_module;
 223:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 224:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 225:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \name Host Callback Functions Types
 226:tmk_core/protocol/arm_atsam/usb/usb.h ****  * @{
 227:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 228:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_host_callback_t)(struct usb_module *module_inst);
 229:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_host_pipe_callback_t)(struct usb_module *module_inst, void *);
 230:tmk_core/protocol/arm_atsam/usb/usb.h **** /** @} */
 231:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 232:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 233:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \name Device Callback Functions Types
 234:tmk_core/protocol/arm_atsam/usb/usb.h ****  * @{
 235:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 236:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_device_callback_t)(struct usb_module *module_inst, void *pointer);
 237:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_device_endpoint_callback_t)(struct usb_module *module_inst, void *pointer);
 238:tmk_core/protocol/arm_atsam/usb/usb.h **** /** @} */
 239:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 240:tmk_core/protocol/arm_atsam/usb/usb.h **** /** USB configurations */
 241:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_config {
 242:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** \c true for host, \c false for device. */
 243:tmk_core/protocol/arm_atsam/usb/usb.h ****     bool select_host_mode;
 244:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** When \c true the module is enabled during standby. */
 245:tmk_core/protocol/arm_atsam/usb/usb.h ****     bool run_in_standby;
 246:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Generic Clock Generator source channel. */
 247:tmk_core/protocol/arm_atsam/usb/usb.h ****     // enum gclk_generator source_generator;
 248:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t source_generator;
 249:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Speed mode */
 250:tmk_core/protocol/arm_atsam/usb/usb.h ****     // enum usb_speed speed_mode;
 251:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t speed_mode;
 252:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 253:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 254:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 255:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief USB software module instance structure.
 256:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 257:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB software module instance structure, used to retain software state
 258:tmk_core/protocol/arm_atsam/usb/usb.h ****  * information of an associated hardware module instance.
 259:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 260:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 261:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_module {
 262:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Hardware module pointer of the associated USB peripheral. */
 263:tmk_core/protocol/arm_atsam/usb/usb.h ****     Usb *hw;
 264:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 265:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Array to store device related callback functions */
 266:tmk_core/protocol/arm_atsam/usb/usb.h ****     usb_device_callback_t          device_callback[USB_DEVICE_CALLBACK_N];
 267:tmk_core/protocol/arm_atsam/usb/usb.h ****     usb_device_endpoint_callback_t device_endpoint_callback[USB_EPT_NUM][USB_DEVICE_EP_CALLBACK_N];
 268:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device callbacks registered */
 269:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t device_registered_callback_mask;
 270:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device callbacks enabled */
 271:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t device_enabled_callback_mask;
 272:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device endpoint callbacks registered */
 273:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t device_endpoint_registered_callback_mask[USB_EPT_NUM];
 274:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device endpoint callbacks enabled */
 275:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t device_endpoint_enabled_callback_mask[USB_EPT_NUM];
 276:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 277:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 278:tmk_core/protocol/arm_atsam/usb/usb.h **** /** USB device endpoint configurations */
 279:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_device_endpoint_config {
 280:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** device address */
 281:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t ep_address;
 282:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** endpoint size */
 283:tmk_core/protocol/arm_atsam/usb/usb.h ****     enum usb_endpoint_size ep_size;
 284:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** automatic zero length packet mode, \c true to enable */
 285:tmk_core/protocol/arm_atsam/usb/usb.h ****     bool auto_zlp;
 286:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** type of endpoint with Bank */
 287:tmk_core/protocol/arm_atsam/usb/usb.h ****     enum usb_device_endpoint_type ep_type;
 288:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 289:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 290:tmk_core/protocol/arm_atsam/usb/usb.h **** /** USB device endpoint callback status parameter structure */
 291:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_endpoint_callback_parameter {
 292:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t received_bytes;
 293:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t sent_bytes;
 294:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t out_buffer_size;
 295:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t  endpoint_address;
 296:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 297:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 298:tmk_core/protocol/arm_atsam/usb/usb.h **** void usb_enable(struct usb_module *module_inst);
 299:tmk_core/protocol/arm_atsam/usb/usb.h **** void usb_disable(struct usb_module *module_inst);
 300:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 301:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 302:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the status of USB module's state machine
 303:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 304:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB module instance
 305:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 306:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint8_t usb_get_state_machine_status(struct usb_module *module_inst) {
 307:tmk_core/protocol/arm_atsam/usb/usb.h ****     /* Sanity check arguments */
 308:tmk_core/protocol/arm_atsam/usb/usb.h ****     Assert(module_inst);
 309:tmk_core/protocol/arm_atsam/usb/usb.h ****     Assert(module_inst->hw);
 310:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 311:tmk_core/protocol/arm_atsam/usb/usb.h ****     return module_inst->hw->DEVICE.FSMSTATUS.reg;
 312:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 313:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 314:tmk_core/protocol/arm_atsam/usb/usb.h **** void             usb_get_config_defaults(struct usb_config *module_config);
 315:tmk_core/protocol/arm_atsam/usb/usb.h **** enum status_code usb_init(struct usb_module *module_inst, Usb *const hw, struct usb_config *module_
 316:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 317:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 318:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Attach USB device to the bus
 319:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 320:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 321:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 322:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_attach(struct usb_module *module_inst) { module_inst->hw->DEVICE.CTRL
 323:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 324:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 325:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Detach USB device from the bus
 326:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 327:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 328:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 329:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_detach(struct usb_module *module_inst) { module_inst->hw->DEVICE.CTRL
 330:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 331:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 332:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the speed mode of USB device
 333:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 334:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 335:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB Speed mode (\ref usb_speed).
 336:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 337:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline enum usb_speed usb_device_get_speed(struct usb_module *module_inst) {
 338:tmk_core/protocol/arm_atsam/usb/usb.h ****     if (!(module_inst->hw->DEVICE.STATUS.reg & USB_DEVICE_STATUS_SPEED_Msk)) {
 339:tmk_core/protocol/arm_atsam/usb/usb.h ****         return USB_SPEED_FULL;
 340:tmk_core/protocol/arm_atsam/usb/usb.h ****     } else {
 341:tmk_core/protocol/arm_atsam/usb/usb.h ****         return USB_SPEED_LOW;
 342:tmk_core/protocol/arm_atsam/usb/usb.h ****     }
 343:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 344:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 345:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 346:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the address of USB device
 347:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 348:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 349:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB device address value.
 350:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 351:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint8_t usb_device_get_address(struct usb_module *module_inst) { return ((uint8_t)(mo
 352:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 353:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 354:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Set the speed mode of USB device
 355:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 356:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 357:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param address     USB device address value
 358:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_set_address(struct usb_module *module_inst, uint8_t address) { module
 476              		.loc 2 359 0
 477 000a 8022     		movs	r2, #128
 478 000c 9A72     		strb	r2, [r3, #10]
 479              	.LVL43:
 480              	.LBE77:
 481              	.LBE76:
 482              	.LBB78:
 483              	.LBB79:
 868:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SI
 484              		.loc 1 868 0
 485 000e 01A8     		add	r0, sp, #4
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 486              		.loc 1 869 0
 487 0010 0024     		movs	r4, #0
 868:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SI
 488              		.loc 1 868 0
 489 0012 FFF7FEFF 		bl	usb_device_endpoint_get_config_defaults
 490              	.LVL44:
 870:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 491              		.loc 1 870 0
 492 0016 01A9     		add	r1, sp, #4
 493 0018 2846     		mov	r0, r5
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 494              		.loc 1 869 0
 495 001a 8DF80540 		strb	r4, [sp, #5]
 870:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 496              		.loc 1 870 0
 497 001e FFF7FEFF 		bl	usb_device_endpoint_set_config
 498              	.LVL45:
 872:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 499              		.loc 1 872 0
 500 0022 1549     		ldr	r1, .L41
 501 0024 2846     		mov	r0, r5
 502 0026 FFF7FEFF 		bl	usb_device_endpoint_setup_buffer_job
 503              	.LVL46:
 874:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT, _usb_
 504              		.loc 1 874 0
 505 002a 2146     		mov	r1, r4
 506 002c 134B     		ldr	r3, .L41+4
 507 002e 0222     		movs	r2, #2
 508 0030 2846     		mov	r0, r5
 509 0032 FFF7FEFF 		bl	usb_device_endpoint_register_callback
 510              	.LVL47:
 875:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL, _usb
 511              		.loc 1 875 0
 512 0036 2246     		mov	r2, r4
 513 0038 2146     		mov	r1, r4
 514 003a 114B     		ldr	r3, .L41+8
 515 003c 2846     		mov	r0, r5
 516 003e FFF7FEFF 		bl	usb_device_endpoint_register_callback
 517              	.LVL48:
 876:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_RXSTP);
 518              		.loc 1 876 0
 519 0042 104B     		ldr	r3, .L41+12
 520 0044 2146     		mov	r1, r4
 521 0046 0122     		movs	r2, #1
 522 0048 2846     		mov	r0, r5
 523 004a FFF7FEFF 		bl	usb_device_endpoint_register_callback
 524              	.LVL49:
 877:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 525              		.loc 1 877 0
 526 004e 2146     		mov	r1, r4
 527 0050 0222     		movs	r2, #2
 528 0052 2846     		mov	r0, r5
 529 0054 FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 530              	.LVL50:
 878:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 531              		.loc 1 878 0
 532 0058 2246     		mov	r2, r4
 533 005a 2146     		mov	r1, r4
 534 005c 2846     		mov	r0, r5
 535 005e FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 536              	.LVL51:
 879:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 537              		.loc 1 879 0
 538 0062 0122     		movs	r2, #1
 539 0064 2146     		mov	r1, r4
 540 0066 2846     		mov	r0, r5
 541 0068 FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 542              	.LVL52:
 886:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 543              		.loc 1 886 0
 544 006c 064B     		ldr	r3, .L41+16
 545 006e 83F8A040 		strb	r4, [r3, #160]
 546              	.LVL53:
 547              	.LBE79:
 548              	.LBE78:
 951:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 549              		.loc 1 951 0
 550 0072 03B0     		add	sp, sp, #12
 551              		.cfi_def_cfa_offset 12
 552              		@ sp needed
 553 0074 30BD     		pop	{r4, r5, pc}
 554              	.LVL54:
 555              	.L42:
 556 0076 00BF     		.align	2
 557              	.L41:
 558 0078 00000000 		.word	udd_ctrl_buffer
 559 007c 00000000 		.word	_usb_ep0_on_setup
 560 0080 00000000 		.word	_usb_ep0_on_tansfer_ok
 561 0084 00000000 		.word	_usb_ep0_on_tansfer_fail
 562 0088 00000000 		.word	.LANCHOR0
 563              		.cfi_endproc
 564              	.LFE176:
 566              		.section	.text.udd_ctrl_send_zlp_in,"ax",%progbits
 567              		.align	1
 568              		.syntax unified
 569              		.thumb
 570              		.thumb_func
 571              		.fpu fpv4-sp-d16
 573              	udd_ctrl_send_zlp_in:
 574              	.LFB165:
 627:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
 575              		.loc 1 627 0
 576              		.cfi_startproc
 577              		@ args = 0, pretend = 0, frame = 0
 578              		@ frame_needed = 0, uses_anonymous_args = 0
 579 0000 10B5     		push	{r4, lr}
 580              		.cfi_def_cfa_offset 8
 581              		.cfi_offset 4, -8
 582              		.cfi_offset 14, -4
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 583              		.loc 1 629 0
 584 0002 094C     		ldr	r4, .L44
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 585              		.loc 1 628 0
 586 0004 094B     		ldr	r3, .L44+4
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 587              		.loc 1 629 0
 588 0006 0A49     		ldr	r1, .L44+8
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 589              		.loc 1 628 0
 590 0008 0322     		movs	r2, #3
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 591              		.loc 1 629 0
 592 000a 2046     		mov	r0, r4
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 593              		.loc 1 628 0
 594 000c 83F8A020 		strb	r2, [r3, #160]
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 595              		.loc 1 629 0
 596 0010 FFF7FEFF 		bl	usb_device_endpoint_setup_buffer_job
 597              	.LVL55:
 630:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 598              		.loc 1 630 0
 599 0014 074A     		ldr	r2, .L44+12
 600 0016 0023     		movs	r3, #0
 601 0018 2046     		mov	r0, r4
 602 001a 9268     		ldr	r2, [r2, #8]
 603 001c 1946     		mov	r1, r3
 631:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 604              		.loc 1 631 0
 605 001e BDE81040 		pop	{r4, lr}
 606              		.cfi_restore 14
 607              		.cfi_restore 4
 608              		.cfi_def_cfa_offset 0
 630:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 609              		.loc 1 630 0
 610 0022 FFF7FEBF 		b	usb_device_endpoint_write_buffer_job
 611              	.LVL56:
 612              	.L45:
 613 0026 00BF     		.align	2
 614              	.L44:
 615 0028 00000000 		.word	usb_device
 616 002c 00000000 		.word	.LANCHOR0
 617 0030 00000000 		.word	udd_ctrl_buffer
 618 0034 00000000 		.word	udd_g_ctrlreq
 619              		.cfi_endproc
 620              	.LFE165:
 622              		.section	.text._usb_ep0_on_tansfer_fail,"ax",%progbits
 623              		.align	1
 624              		.syntax unified
 625              		.thumb
 626              		.thumb_func
 627              		.fpu fpv4-sp-d16
 629              	_usb_ep0_on_tansfer_fail:
 630              	.LFB171:
 831:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 631              		.loc 1 831 0
 632              		.cfi_startproc
 633              		@ args = 0, pretend = 0, frame = 0
 634              		@ frame_needed = 0, uses_anonymous_args = 0
 635              		@ link register save eliminated.
 636              	.LVL57:
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 637              		.loc 1 834 0
 638 0000 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 639              	.LVL58:
 640 0002 0B4A     		ldr	r2, .L54
 641 0004 0806     		lsls	r0, r1, #24
 642              	.LVL59:
 643 0006 92F8A030 		ldrb	r3, [r2, #160]	@ zero_extendqisi2
 644 000a 08D5     		bpl	.L47
 645              	.LVL60:
 646              	.LBB84:
 647              	.LBB85:
 796:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop OUT transaction
 648              		.loc 1 796 0
 649 000c 012B     		cmp	r3, #1
 650 000e 01D1     		bne	.L48
 799:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
 651              		.loc 1 799 0
 652 0010 FFF7FEBF 		b	udd_ctrl_send_zlp_in
 653              	.LVL61:
 654              	.L48:
 800:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A OUT handshake is waiting by device,
 655              		.loc 1 800 0
 656 0014 042B     		cmp	r3, #4
 657              	.LVL62:
 658              	.L53:
 659              	.LBE85:
 660              	.LBE84:
 661              	.LBB86:
 662              	.LBB87:
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 663              		.loc 1 818 0
 664 0016 0AD1     		bne	.L46
 821:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 665              		.loc 1 821 0
 666 0018 0648     		ldr	r0, .L54+4
 667 001a FFF7FEBF 		b	usb_device_endpoint_set_halt
 668              	.LVL63:
 669              	.L47:
 814:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop IN transaction
 670              		.loc 1 814 0
 671 001e 022B     		cmp	r3, #2
 672 0020 03D1     		bne	.L50
 817:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
 673              		.loc 1 817 0
 674 0022 0423     		movs	r3, #4
 675 0024 82F8A030 		strb	r3, [r2, #160]
 676 0028 7047     		bx	lr
 677              	.L50:
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 678              		.loc 1 818 0
 679 002a 032B     		cmp	r3, #3
 680 002c F3E7     		b	.L53
 681              	.LVL64:
 682              	.L46:
 683              	.LBE87:
 684              	.LBE86:
 839:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 685              		.loc 1 839 0
 686 002e 7047     		bx	lr
 687              	.L55:
 688              		.align	2
 689              	.L54:
 690 0030 00000000 		.word	.LANCHOR0
 691 0034 00000000 		.word	usb_device
 692              		.cfi_endproc
 693              	.LFE171:
 695              		.section	.text.udd_ctrl_in_sent,"ax",%progbits
 696              		.align	1
 697              		.syntax unified
 698              		.thumb
 699              		.thumb_func
 700              		.fpu fpv4-sp-d16
 702              	udd_ctrl_in_sent:
 703              	.LFB166:
 636:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     static bool b_shortpacket = false;
 704              		.loc 1 636 0
 705              		.cfi_startproc
 706              		@ args = 0, pretend = 0, frame = 0
 707              		@ frame_needed = 0, uses_anonymous_args = 0
 708 0000 70B5     		push	{r4, r5, r6, lr}
 709              		.cfi_def_cfa_offset 16
 710              		.cfi_offset 4, -16
 711              		.cfi_offset 5, -12
 712              		.cfi_offset 6, -8
 713              		.cfi_offset 14, -4
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 714              		.loc 1 640 0
 715 0002 1E4C     		ldr	r4, .L69
 716 0004 1E4E     		ldr	r6, .L69+4
 717 0006 B4F8A230 		ldrh	r3, [r4, #162]
 718 000a B589     		ldrh	r5, [r6, #12]
 719 000c ED1A     		subs	r5, r5, r3
 720 000e ADB2     		uxth	r5, r5
 721              	.LVL65:
 642:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* All content of current buffer payload are sent Update number of total data sending by pr
 722              		.loc 1 642 0
 723 0010 DDB9     		cbnz	r5, .L57
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 724              		.loc 1 644 0
 725 0012 B4F8A420 		ldrh	r2, [r4, #164]
 726 0016 1344     		add	r3, r3, r2
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 727              		.loc 1 645 0
 728 0018 F288     		ldrh	r2, [r6, #6]
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 729              		.loc 1 644 0
 730 001a 9BB2     		uxth	r3, r3
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 731              		.loc 1 645 0
 732 001c 9A42     		cmp	r2, r3
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 733              		.loc 1 644 0
 734 001e A4F8A430 		strh	r3, [r4, #164]	@ movhi
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 735              		.loc 1 645 0
 736 0022 02D0     		beq	.L58
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 737              		.loc 1 645 0 is_stmt 0 discriminator 1
 738 0024 94F8A630 		ldrb	r3, [r4, #166]	@ zero_extendqisi2
 739 0028 43B1     		cbz	r3, .L59
 740              	.L58:
 648:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 741              		.loc 1 648 0 is_stmt 1
 742 002a 0423     		movs	r3, #4
 743 002c 84F8A030 		strb	r3, [r4, #160]
 649:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 744              		.loc 1 649 0
 745 0030 1449     		ldr	r1, .L69+8
 746 0032 1548     		ldr	r0, .L69+12
 675:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 747              		.loc 1 675 0
 748 0034 BDE87040 		pop	{r4, r5, r6, lr}
 749              		.cfi_remember_state
 750              		.cfi_restore 14
 751              		.cfi_restore 6
 752              		.cfi_restore 5
 753              		.cfi_restore 4
 754              		.cfi_def_cfa_offset 0
 755              	.LVL66:
 649:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 756              		.loc 1 649 0
 757 0038 FFF7FEBF 		b	usb_device_endpoint_setup_buffer_job
 758              	.LVL67:
 759              	.L59:
 760              		.cfi_restore_state
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 761              		.loc 1 653 0
 762 003c 7369     		ldr	r3, [r6, #20]
 763 003e CBB1     		cbz	r3, .L61
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 764              		.loc 1 653 0 is_stmt 0 discriminator 1
 765 0040 9847     		blx	r3
 766              	.LVL68:
 767 0042 B8B1     		cbz	r0, .L61
 658:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             nb_remain                 = udd_g_ctrlreq.payload_size;
 768              		.loc 1 658 0 is_stmt 1
 769 0044 A4F8A250 		strh	r5, [r4, #162]	@ movhi
 659:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 770              		.loc 1 659 0
 771 0048 B589     		ldrh	r5, [r6, #12]
 772              	.LVL69:
 773              	.L57:
 664:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_remain     = USB_DEVICE_EP_CTRL_SIZE;
 774              		.loc 1 664 0
 775 004a 072D     		cmp	r5, #7
 776 004c 12D9     		bls	.L61
 777              	.LVL70:
 666:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 778              		.loc 1 666 0
 779 004e 0023     		movs	r3, #0
 780 0050 84F8A630 		strb	r3, [r4, #166]
 665:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         b_shortpacket = false;
 781              		.loc 1 665 0
 782 0054 0825     		movs	r5, #8
 783              	.LVL71:
 784              	.L62:
 672:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 785              		.loc 1 672 0
 786 0056 B168     		ldr	r1, [r6, #8]
 787 0058 B4F8A220 		ldrh	r2, [r4, #162]
 788 005c 0A48     		ldr	r0, .L69+12
 789 005e 2B46     		mov	r3, r5
 790 0060 0A44     		add	r2, r2, r1
 791 0062 0021     		movs	r1, #0
 792 0064 FFF7FEFF 		bl	usb_device_endpoint_write_buffer_job
 793              	.LVL72:
 674:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 794              		.loc 1 674 0
 795 0068 B4F8A230 		ldrh	r3, [r4, #162]
 796 006c 1D44     		add	r5, r5, r3
 797              	.LVL73:
 798 006e A4F8A250 		strh	r5, [r4, #162]	@ movhi
 675:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 799              		.loc 1 675 0
 800 0072 70BD     		pop	{r4, r5, r6, pc}
 801              	.LVL74:
 802              	.L61:
 668:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 803              		.loc 1 668 0
 804 0074 0123     		movs	r3, #1
 805 0076 84F8A630 		strb	r3, [r4, #166]
 806 007a ECE7     		b	.L62
 807              	.L70:
 808              		.align	2
 809              	.L69:
 810 007c 00000000 		.word	.LANCHOR0
 811 0080 00000000 		.word	udd_g_ctrlreq
 812 0084 00000000 		.word	udd_ctrl_buffer
 813 0088 00000000 		.word	usb_device
 814              		.cfi_endproc
 815              	.LFE166:
 817              		.section	.text._usb_ep0_on_setup,"ax",%progbits
 818              		.align	1
 819              		.syntax unified
 820              		.thumb
 821              		.thumb_func
 822              		.fpu fpv4-sp-d16
 824              	_usb_ep0_on_setup:
 825              	.LFB168:
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 826              		.loc 1 751 0
 827              		.cfi_startproc
 828              		@ args = 0, pretend = 0, frame = 0
 829              		@ frame_needed = 0, uses_anonymous_args = 0
 830              	.LVL75:
 831 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 832              		.cfi_def_cfa_offset 24
 833              		.cfi_offset 4, -24
 834              		.cfi_offset 5, -20
 835              		.cfi_offset 6, -16
 836              		.cfi_offset 7, -12
 837              		.cfi_offset 8, -8
 838              		.cfi_offset 14, -4
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 839              		.loc 1 754 0
 840 0004 2A4D     		ldr	r5, .L87
 841 0006 95F8A030 		ldrb	r3, [r5, #160]	@ zero_extendqisi2
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 842              		.loc 1 751 0
 843 000a 0C46     		mov	r4, r1
 844              	.LVL76:
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 845              		.loc 1 754 0
 846 000c 33B1     		cbz	r3, .L72
 755:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 847              		.loc 1 755 0
 848 000e 294B     		ldr	r3, .L87+4
 849 0010 1B69     		ldr	r3, [r3, #16]
 850 0012 03B1     		cbz	r3, .L73
 756:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 851              		.loc 1 756 0
 852 0014 9847     		blx	r3
 853              	.LVL77:
 854              	.L73:
 758:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 855              		.loc 1 758 0
 856 0016 0023     		movs	r3, #0
 857 0018 85F8A030 		strb	r3, [r5, #160]
 858              	.L72:
 760:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_stall_data();
 859              		.loc 1 760 0
 860 001c 2788     		ldrh	r7, [r4]
 861 001e 082F     		cmp	r7, #8
 862 0020 03D0     		beq	.L74
 863              	.LVL78:
 864              	.L75:
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 865              		.loc 1 787 0
 866 0022 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 867              		.cfi_remember_state
 868              		.cfi_restore 14
 869              		.cfi_restore 8
 870              		.cfi_restore 7
 871              		.cfi_restore 6
 872              		.cfi_restore 5
 873              		.cfi_restore 4
 874              		.cfi_def_cfa_offset 0
 761:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 875              		.loc 1 761 0
 876 0026 FFF7FEBF 		b	udd_ctrl_stall_data
 877              	.LVL79:
 878              	.L74:
 879              		.cfi_restore_state
 880              	.LBB90:
 881              	.LBB91:
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 882              		.loc 1 617 0
 883 002a 234C     		ldr	r4, .L87+8
 884              	.LVL80:
 885 002c 214E     		ldr	r6, .L87+4
 886 002e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 887 0030 3370     		strb	r3, [r6]
 618:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wValue        = ((uint16_t)(udd_ctrl_buffer[3]) << 8) + udd_ctrl_buffer[2];
 888              		.loc 1 618 0
 889 0032 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 890              		.loc 1 619 0
 891 0034 E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 618:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wValue        = ((uint16_t)(udd_ctrl_buffer[3]) << 8) + udd_ctrl_buffer[2];
 892              		.loc 1 618 0
 893 0036 7370     		strb	r3, [r6, #1]
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 894              		.loc 1 619 0
 895 0038 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 896 003a 03EB0223 		add	r3, r3, r2, lsl #8
 897 003e 7380     		strh	r3, [r6, #2]	@ movhi
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 898              		.loc 1 620 0
 899 0040 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
 900 0042 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 901 0044 03EB0223 		add	r3, r3, r2, lsl #8
 902 0048 B380     		strh	r3, [r6, #4]	@ movhi
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 903              		.loc 1 621 0
 904 004a E279     		ldrb	r2, [r4, #7]	@ zero_extendqisi2
 905 004c A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 906 004e 03EB0223 		add	r3, r3, r2, lsl #8
 907 0052 F380     		strh	r3, [r6, #6]	@ movhi
 908              	.LBE91:
 909              	.LBE90:
 765:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_stall_data();
 910              		.loc 1 765 0
 911 0054 FFF7FEFF 		bl	udc_process_setup
 912              	.LVL81:
 913 0058 0028     		cmp	r0, #0
 914 005a E2D0     		beq	.L75
 768:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_prev_payload_nb_trans = 0;
 915              		.loc 1 768 0
 916 005c 96F90030 		ldrsb	r3, [r6]
 917 0060 002B     		cmp	r3, #0
 918 0062 10DA     		bge	.L76
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 919              		.loc 1 771 0
 920 0064 0223     		movs	r3, #2
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 921              		.loc 1 769 0
 922 0066 0021     		movs	r1, #0
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 923              		.loc 1 771 0
 924 0068 85F8A030 		strb	r3, [r5, #160]
 772:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_in_sent();
 925              		.loc 1 772 0
 926 006c 2246     		mov	r2, r4
 927 006e 3B46     		mov	r3, r7
 928 0070 1248     		ldr	r0, .L87+12
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 929              		.loc 1 769 0
 930 0072 A5F8A410 		strh	r1, [r5, #164]	@ movhi
 770:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state           = UDD_EPCTRL_DATA_IN;
 931              		.loc 1 770 0
 932 0076 A5F8A210 		strh	r1, [r5, #162]	@ movhi
 772:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_in_sent();
 933              		.loc 1 772 0
 934 007a FFF7FEFF 		bl	usb_device_endpoint_read_buffer_job
 935              	.LVL82:
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 936              		.loc 1 787 0
 937 007e BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 938              		.cfi_remember_state
 939              		.cfi_restore 14
 940              		.cfi_restore 8
 941              		.cfi_restore 7
 942              		.cfi_restore 6
 943              		.cfi_restore 5
 944              		.cfi_restore 4
 945              		.cfi_def_cfa_offset 0
 773:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 946              		.loc 1 773 0
 947 0082 FFF7FEBF 		b	udd_ctrl_in_sent
 948              	.LVL83:
 949              	.L76:
 950              		.cfi_restore_state
 775:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_send_zlp_in();
 951              		.loc 1 775 0
 952 0086 F388     		ldrh	r3, [r6, #6]
 953 0088 1BB9     		cbnz	r3, .L77
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 954              		.loc 1 787 0
 955 008a BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 956              		.cfi_remember_state
 957              		.cfi_restore 14
 958              		.cfi_restore 8
 959              		.cfi_restore 7
 960              		.cfi_restore 6
 961              		.cfi_restore 5
 962              		.cfi_restore 4
 963              		.cfi_def_cfa_offset 0
 776:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 964              		.loc 1 776 0
 965 008e FFF7FEBF 		b	udd_ctrl_send_zlp_in
 966              	.LVL84:
 967              	.L77:
 968              		.cfi_restore_state
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 969              		.loc 1 779 0
 970 0092 0021     		movs	r1, #0
 781:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Initialize buffer size and enable OUT bank */
 971              		.loc 1 781 0
 972 0094 0123     		movs	r3, #1
 973 0096 85F8A030 		strb	r3, [r5, #160]
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 974              		.loc 1 779 0
 975 009a A5F8A410 		strh	r1, [r5, #164]	@ movhi
 780:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state           = UDD_EPCTRL_DATA_OUT;
 976              		.loc 1 780 0
 977 009e A5F8A210 		strh	r1, [r5, #162]	@ movhi
 783:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 978              		.loc 1 783 0
 979 00a2 3B46     		mov	r3, r7
 980 00a4 2246     		mov	r2, r4
 981 00a6 0548     		ldr	r0, .L87+12
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 982              		.loc 1 787 0
 983 00a8 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 984              		.cfi_restore 14
 985              		.cfi_restore 8
 986              		.cfi_restore 7
 987              		.cfi_restore 6
 988              		.cfi_restore 5
 989              		.cfi_restore 4
 990              		.cfi_def_cfa_offset 0
 783:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 991              		.loc 1 783 0
 992 00ac FFF7FEBF 		b	usb_device_endpoint_read_buffer_job
 993              	.LVL85:
 994              	.L88:
 995              		.align	2
 996              	.L87:
 997 00b0 00000000 		.word	.LANCHOR0
 998 00b4 00000000 		.word	udd_g_ctrlreq
 999 00b8 00000000 		.word	udd_ctrl_buffer
 1000 00bc 00000000 		.word	usb_device
 1001              		.cfi_endproc
 1002              	.LFE168:
 1004              		.section	.text._usb_on_sof_notify,"ax",%progbits
 1005              		.align	1
 1006              		.syntax unified
 1007              		.thumb
 1008              		.thumb_func
 1009              		.fpu fpv4-sp-d16
 1011              	_usb_on_sof_notify:
 1012              	.LFB175:
 933:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_sof_notify();
 1013              		.loc 1 933 0
 1014              		.cfi_startproc
 1015              		@ args = 0, pretend = 0, frame = 0
 1016              		@ frame_needed = 0, uses_anonymous_args = 0
 1017              	.LVL86:
 1018 0000 08B5     		push	{r3, lr}
 1019              		.cfi_def_cfa_offset 8
 1020              		.cfi_offset 3, -8
 1021              		.cfi_offset 14, -4
 934:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SOF_EVENT
 1022              		.loc 1 934 0
 1023 0002 FFF7FEFF 		bl	udc_sof_notify
 1024              	.LVL87:
 938:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1025              		.loc 1 938 0
 1026 0006 BDE80840 		pop	{r3, lr}
 1027              		.cfi_restore 14
 1028              		.cfi_restore 3
 1029              		.cfi_def_cfa_offset 0
 936:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 1030              		.loc 1 936 0
 1031 000a FFF7FEBF 		b	main_sof_action
 1032              	.LVL88:
 1033              		.cfi_endproc
 1034              	.LFE175:
 1036              		.section	.text._usb_on_suspend,"ax",%progbits
 1037              		.align	1
 1038              		.syntax unified
 1039              		.thumb
 1040              		.thumb_func
 1041              		.fpu fpv4-sp-d16
 1043              	_usb_on_suspend:
 1044              	.LFB174:
 895:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 1045              		.loc 1 895 0
 1046              		.cfi_startproc
 1047              		@ args = 0, pretend = 0, frame = 0
 1048              		@ frame_needed = 0, uses_anonymous_args = 0
 1049              	.LVL89:
 1050 0000 10B5     		push	{r4, lr}
 1051              		.cfi_def_cfa_offset 8
 1052              		.cfi_offset 4, -8
 1053              		.cfi_offset 14, -4
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 1054              		.loc 1 896 0
 1055 0002 064C     		ldr	r4, .L91
 1056 0004 0421     		movs	r1, #4
 1057              	.LVL90:
 1058 0006 2046     		mov	r0, r4
 1059              	.LVL91:
 1060 0008 FFF7FEFF 		bl	usb_device_disable_callback
 1061              	.LVL92:
 897:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 1062              		.loc 1 897 0
 1063 000c 2046     		mov	r0, r4
 1064 000e 0221     		movs	r1, #2
 1065 0010 FFF7FEFF 		bl	usb_device_enable_callback
 1066              	.LVL93:
 902:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1067              		.loc 1 902 0
 1068 0014 BDE81040 		pop	{r4, lr}
 1069              		.cfi_restore 14
 1070              		.cfi_restore 4
 1071              		.cfi_def_cfa_offset 0
 900:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 1072              		.loc 1 900 0
 1073 0018 FFF7FEBF 		b	main_suspend_action
 1074              	.LVL94:
 1075              	.L92:
 1076              		.align	2
 1077              	.L91:
 1078 001c 00000000 		.word	usb_device
 1079              		.cfi_endproc
 1080              	.LFE174:
 1082              		.section	.text.udd_ep_abort,"ax",%progbits
 1083              		.align	1
 1084              		.global	udd_ep_abort
 1085              		.syntax unified
 1086              		.thumb
 1087              		.thumb_func
 1088              		.fpu fpv4-sp-d16
 1090              	udd_ep_abort:
 1091              	.LFB148:
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1092              		.loc 1 349 0
 1093              		.cfi_startproc
 1094              		@ args = 0, pretend = 0, frame = 0
 1095              		@ frame_needed = 0, uses_anonymous_args = 0
 1096              	.LVL95:
 1097 0000 10B5     		push	{r4, lr}
 1098              		.cfi_def_cfa_offset 8
 1099              		.cfi_offset 4, -8
 1100              		.cfi_offset 14, -4
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1101              		.loc 1 352 0
 1102 0002 0146     		mov	r1, r0
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1103              		.loc 1 349 0
 1104 0004 0446     		mov	r4, r0
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1105              		.loc 1 352 0
 1106 0006 0A48     		ldr	r0, .L100
 1107              	.LVL96:
 1108 0008 FFF7FEFF 		bl	usb_device_endpoint_abort_job
 1109              	.LVL97:
 355:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!ptr_job->busy) {
 1110              		.loc 1 355 0
 1111 000c 2046     		mov	r0, r4
 1112 000e FFF7FEFF 		bl	udd_ep_get_job
 1113              	.LVL98:
 356:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1114              		.loc 1 356 0
 1115 0012 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 1116 0014 DA07     		lsls	r2, r3, #31
 1117 0016 0AD5     		bpl	.L93
 359:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 1118              		.loc 1 359 0
 1119 0018 6FF30003 		bfc	r3, #0, #1
 1120 001c 8374     		strb	r3, [r0, #18]
 360:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* It can be a Transfer or stall callback */
 1121              		.loc 1 360 0
 1122 001e 0368     		ldr	r3, [r0]
 1123 0020 2BB1     		cbz	r3, .L93
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1124              		.loc 1 362 0
 1125 0022 2246     		mov	r2, r4
 1126 0024 C168     		ldr	r1, [r0, #12]
 364:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1127              		.loc 1 364 0
 1128 0026 BDE81040 		pop	{r4, lr}
 1129              		.cfi_remember_state
 1130              		.cfi_restore 14
 1131              		.cfi_restore 4
 1132              		.cfi_def_cfa_offset 0
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1133              		.loc 1 362 0
 1134 002a 0120     		movs	r0, #1
 1135              	.LVL99:
 1136 002c 1847     		bx	r3	@ indirect register sibling call
 1137              	.LVL100:
 1138              	.L93:
 1139              		.cfi_restore_state
 364:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1140              		.loc 1 364 0
 1141 002e 10BD     		pop	{r4, pc}
 1142              	.L101:
 1143              		.align	2
 1144              	.L100:
 1145 0030 00000000 		.word	usb_device
 1146              		.cfi_endproc
 1147              	.LFE148:
 1149              		.section	.text.udd_is_high_speed,"ax",%progbits
 1150              		.align	1
 1151              		.global	udd_is_high_speed
 1152              		.syntax unified
 1153              		.thumb
 1154              		.thumb_func
 1155              		.fpu fpv4-sp-d16
 1157              	udd_is_high_speed:
 1158              	.LFB149:
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1159              		.loc 1 366 0
 1160              		.cfi_startproc
 1161              		@ args = 0, pretend = 0, frame = 0
 1162              		@ frame_needed = 0, uses_anonymous_args = 0
 1163              		@ link register save eliminated.
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1164              		.loc 1 366 0
 1165 0000 0020     		movs	r0, #0
 1166 0002 7047     		bx	lr
 1167              		.cfi_endproc
 1168              	.LFE149:
 1170              		.section	.text.udd_get_frame_number,"ax",%progbits
 1171              		.align	1
 1172              		.global	udd_get_frame_number
 1173              		.syntax unified
 1174              		.thumb
 1175              		.thumb_func
 1176              		.fpu fpv4-sp-d16
 1178              	udd_get_frame_number:
 1179              	.LFB150:
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1180              		.loc 1 368 0
 1181              		.cfi_startproc
 1182              		@ args = 0, pretend = 0, frame = 0
 1183              		@ frame_needed = 0, uses_anonymous_args = 0
 1184              		@ link register save eliminated.
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1185              		.loc 1 368 0
 1186 0000 024B     		ldr	r3, .L104
 1187 0002 1B68     		ldr	r3, [r3]
 1188              	.LVL101:
 1189              	.LBB92:
 1190              	.LBB93:
 360:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 361:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 362:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the frame number of USB device
 363:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 364:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 365:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB device frame number value.
 366:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 367:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint16_t usb_device_get_frame_number(struct usb_module *module_inst) { return ((uint1
 1191              		.loc 2 367 0
 1192 0004 188A     		ldrh	r0, [r3, #16]
 1193              	.LBE93:
 1194              	.LBE92:
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1195              		.loc 1 368 0
 1196 0006 C0F3CA00 		ubfx	r0, r0, #3, #11
 1197 000a 7047     		bx	lr
 1198              	.L105:
 1199              		.align	2
 1200              	.L104:
 1201 000c 00000000 		.word	usb_device
 1202              		.cfi_endproc
 1203              	.LFE150:
 1205              		.section	.text.udd_get_micro_frame_number,"ax",%progbits
 1206              		.align	1
 1207              		.global	udd_get_micro_frame_number
 1208              		.syntax unified
 1209              		.thumb
 1210              		.thumb_func
 1211              		.fpu fpv4-sp-d16
 1213              	udd_get_micro_frame_number:
 1214              	.LFB151:
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1215              		.loc 1 370 0
 1216              		.cfi_startproc
 1217              		@ args = 0, pretend = 0, frame = 0
 1218              		@ frame_needed = 0, uses_anonymous_args = 0
 1219              		@ link register save eliminated.
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1220              		.loc 1 370 0
 1221 0000 014B     		ldr	r3, .L107
 1222 0002 1B68     		ldr	r3, [r3]
 1223              	.LVL102:
 1224              	.LBB94:
 1225              	.LBB95:
 368:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 369:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 370:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the micro-frame number of USB device
 371:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 372:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 373:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB device micro-frame number value.
 374:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 375:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint16_t usb_device_get_micro_frame_number(struct usb_module *module_inst) { return (
 1226              		.loc 2 375 0
 1227 0004 188A     		ldrh	r0, [r3, #16]
 1228              	.LBE95:
 1229              	.LBE94:
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1230              		.loc 1 370 0
 1231 0006 7047     		bx	lr
 1232              	.L108:
 1233              		.align	2
 1234              	.L107:
 1235 0008 00000000 		.word	usb_device
 1236              		.cfi_endproc
 1237              	.LFE151:
 1239              		.section	.text.udd_ep_free,"ax",%progbits
 1240              		.align	1
 1241              		.global	udd_ep_free
 1242              		.syntax unified
 1243              		.thumb
 1244              		.thumb_func
 1245              		.fpu fpv4-sp-d16
 1247              	udd_ep_free:
 1248              	.LFB152:
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1249              		.loc 1 372 0
 1250              		.cfi_startproc
 1251              		@ args = 0, pretend = 0, frame = 8
 1252              		@ frame_needed = 0, uses_anonymous_args = 0
 1253              	.LVL103:
 1254 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1255              		.cfi_def_cfa_offset 24
 1256              		.cfi_offset 4, -16
 1257              		.cfi_offset 5, -12
 1258              		.cfi_offset 6, -8
 1259              		.cfi_offset 14, -4
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1260              		.loc 1 372 0
 1261 0002 0446     		mov	r4, r0
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 1262              		.loc 1 381 0
 1263 0004 0E4D     		ldr	r5, .L110
 374:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1264              		.loc 1 374 0
 1265 0006 01A8     		add	r0, sp, #4
 1266              	.LVL104:
 1267 0008 FFF7FEFF 		bl	usb_device_endpoint_get_config_defaults
 1268              	.LVL105:
 377:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1269              		.loc 1 377 0
 1270 000c 2046     		mov	r0, r4
 1271 000e FFF7FEFF 		bl	udd_ep_abort
 1272              	.LVL106:
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 1273              		.loc 1 380 0
 1274 0012 0026     		movs	r6, #0
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 1275              		.loc 1 381 0
 1276 0014 01A9     		add	r1, sp, #4
 1277 0016 2846     		mov	r0, r5
 379:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_type    = USB_DEVICE_ENDPOINT_TYPE_DISABLE;
 1278              		.loc 1 379 0
 1279 0018 8DF80440 		strb	r4, [sp, #4]
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 1280              		.loc 1 380 0
 1281 001c 8DF80760 		strb	r6, [sp, #7]
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 1282              		.loc 1 381 0
 1283 0020 FFF7FEFF 		bl	usb_device_endpoint_set_config
 1284              	.LVL107:
 382:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_disable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 1285              		.loc 1 382 0
 1286 0024 3246     		mov	r2, r6
 1287 0026 04F00F01 		and	r1, r4, #15
 1288 002a 2846     		mov	r0, r5
 1289 002c FFF7FEFF 		bl	usb_device_endpoint_unregister_callback
 1290              	.LVL108:
 383:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1291              		.loc 1 383 0
 1292 0030 3246     		mov	r2, r6
 1293 0032 2146     		mov	r1, r4
 1294 0034 2846     		mov	r0, r5
 1295 0036 FFF7FEFF 		bl	usb_device_endpoint_disable_callback
 1296              	.LVL109:
 384:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1297              		.loc 1 384 0
 1298 003a 02B0     		add	sp, sp, #8
 1299              		.cfi_def_cfa_offset 16
 1300              		@ sp needed
 1301 003c 70BD     		pop	{r4, r5, r6, pc}
 1302              	.LVL110:
 1303              	.L111:
 1304 003e 00BF     		.align	2
 1305              	.L110:
 1306 0040 00000000 		.word	usb_device
 1307              		.cfi_endproc
 1308              	.LFE152:
 1310              		.section	.text.udd_ep_alloc,"ax",%progbits
 1311              		.align	1
 1312              		.global	udd_ep_alloc
 1313              		.syntax unified
 1314              		.thumb
 1315              		.thumb_func
 1316              		.fpu fpv4-sp-d16
 1318              	udd_ep_alloc:
 1319              	.LFB153:
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1320              		.loc 1 386 0
 1321              		.cfi_startproc
 1322              		@ args = 0, pretend = 0, frame = 8
 1323              		@ frame_needed = 0, uses_anonymous_args = 0
 1324              	.LVL111:
 1325 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1326              		.cfi_def_cfa_offset 24
 1327              		.cfi_offset 4, -16
 1328              		.cfi_offset 5, -12
 1329              		.cfi_offset 6, -8
 1330              		.cfi_offset 14, -4
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1331              		.loc 1 386 0
 1332 0002 0546     		mov	r5, r0
 1333 0004 1446     		mov	r4, r2
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1334              		.loc 1 388 0
 1335 0006 01A8     		add	r0, sp, #4
 1336              	.LVL112:
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1337              		.loc 1 386 0
 1338 0008 0E46     		mov	r6, r1
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1339              		.loc 1 388 0
 1340 000a FFF7FEFF 		bl	usb_device_endpoint_get_config_defaults
 1341              	.LVL113:
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 1342              		.loc 1 392 0
 1343 000e 082C     		cmp	r4, #8
 390:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1344              		.loc 1 390 0
 1345 0010 8DF80450 		strb	r5, [sp, #4]
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 1346              		.loc 1 392 0
 1347 0014 26D8     		bhi	.L113
 393:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 16) {
 1348              		.loc 1 393 0
 1349 0016 0023     		movs	r3, #0
 1350              	.L127:
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 1351              		.loc 1 411 0
 1352 0018 2846     		mov	r0, r5
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1353              		.loc 1 407 0
 1354 001a 8DF80530 		strb	r3, [sp, #5]
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 1355              		.loc 1 411 0
 1356 001e FFF7FEFF 		bl	udd_ep_get_job
 1357              	.LVL114:
 414:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1358              		.loc 1 414 0
 1359 0022 06F00301 		and	r1, r6, #3
 1360              	.LVL115:
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 1361              		.loc 1 417 0
 1362 0026 0129     		cmp	r1, #1
 412:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1363              		.loc 1 412 0
 1364 0028 0482     		strh	r4, [r0, #16]	@ movhi
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 1365              		.loc 1 417 0
 1366 002a 3DD1     		bne	.L123
 418:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_BULK == bmAttributes) {
 1367              		.loc 1 418 0
 1368 002c 0223     		movs	r3, #2
 1369              	.L128:
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1370              		.loc 1 429 0
 1371 002e 01A9     		add	r1, sp, #4
 1372              	.LVL116:
 1373 0030 2148     		ldr	r0, .L129
 1374              	.LVL117:
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1375              		.loc 1 422 0
 1376 0032 8DF80730 		strb	r3, [sp, #7]
 1377              	.LVL118:
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1378              		.loc 1 429 0
 1379 0036 FFF7FEFF 		bl	usb_device_endpoint_set_config
 1380              	.LVL119:
 1381 003a 0446     		mov	r4, r0
 1382 003c 78BB     		cbnz	r0, .L126
 432:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 1383              		.loc 1 432 0
 1384 003e 1F4B     		ldr	r3, .L129+4
 1385 0040 0246     		mov	r2, r0
 1386 0042 05F00F01 		and	r1, r5, #15
 1387 0046 1C48     		ldr	r0, .L129
 1388 0048 FFF7FEFF 		bl	usb_device_endpoint_register_callback
 1389              	.LVL120:
 433:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 1390              		.loc 1 433 0
 1391 004c 2246     		mov	r2, r4
 1392 004e 2946     		mov	r1, r5
 1393 0050 1948     		ldr	r0, .L129
 1394 0052 FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 1395              	.LVL121:
 434:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1396              		.loc 1 434 0
 1397 0056 0122     		movs	r2, #1
 1398 0058 2946     		mov	r1, r5
 1399 005a 1748     		ldr	r0, .L129
 1400 005c FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 1401              	.LVL122:
 436:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1402              		.loc 1 436 0
 1403 0060 0120     		movs	r0, #1
 1404 0062 1DE0     		b	.L122
 1405              	.LVL123:
 1406              	.L113:
 394:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_16_BYTE;
 1407              		.loc 1 394 0
 1408 0064 102C     		cmp	r4, #16
 1409 0066 01D8     		bhi	.L115
 395:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 32) {
 1410              		.loc 1 395 0
 1411 0068 0123     		movs	r3, #1
 1412 006a D5E7     		b	.L127
 1413              	.L115:
 396:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_32_BYTE;
 1414              		.loc 1 396 0
 1415 006c 202C     		cmp	r4, #32
 1416 006e 01D8     		bhi	.L116
 397:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 64) {
 1417              		.loc 1 397 0
 1418 0070 0223     		movs	r3, #2
 1419 0072 D1E7     		b	.L127
 1420              	.L116:
 398:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_64_BYTE;
 1421              		.loc 1 398 0
 1422 0074 402C     		cmp	r4, #64
 1423 0076 01D8     		bhi	.L117
 399:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 128) {
 1424              		.loc 1 399 0
 1425 0078 0323     		movs	r3, #3
 1426 007a CDE7     		b	.L127
 1427              	.L117:
 400:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_128_BYTE;
 1428              		.loc 1 400 0
 1429 007c 802C     		cmp	r4, #128
 1430 007e 01D8     		bhi	.L118
 401:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 256) {
 1431              		.loc 1 401 0
 1432 0080 0423     		movs	r3, #4
 1433 0082 C9E7     		b	.L127
 1434              	.L118:
 402:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_256_BYTE;
 1435              		.loc 1 402 0
 1436 0084 B4F5807F 		cmp	r4, #256
 1437 0088 01D8     		bhi	.L119
 403:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 512) {
 1438              		.loc 1 403 0
 1439 008a 0523     		movs	r3, #5
 1440 008c C4E7     		b	.L127
 1441              	.L119:
 404:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_512_BYTE;
 1442              		.loc 1 404 0
 1443 008e B4F5007F 		cmp	r4, #512
 1444 0092 01D8     		bhi	.L120
 405:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 1023) {
 1445              		.loc 1 405 0
 1446 0094 0623     		movs	r3, #6
 1447 0096 BFE7     		b	.L127
 1448              	.L120:
 406:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_1023_BYTE;
 1449              		.loc 1 406 0
 1450 0098 B4F5806F 		cmp	r4, #1024
 1451 009c 02D3     		bcc	.L121
 1452              	.LVL124:
 1453              	.L126:
 409:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1454              		.loc 1 409 0
 1455 009e 0020     		movs	r0, #0
 1456              	.L122:
 437:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1457              		.loc 1 437 0
 1458 00a0 02B0     		add	sp, sp, #8
 1459              		.cfi_remember_state
 1460              		.cfi_def_cfa_offset 16
 1461              		@ sp needed
 1462 00a2 70BD     		pop	{r4, r5, r6, pc}
 1463              	.LVL125:
 1464              	.L121:
 1465              		.cfi_restore_state
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1466              		.loc 1 407 0
 1467 00a4 0723     		movs	r3, #7
 1468 00a6 B7E7     		b	.L127
 1469              	.LVL126:
 1470              	.L123:
 419:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_BULK;
 1471              		.loc 1 419 0
 1472 00a8 0229     		cmp	r1, #2
 1473 00aa 01D1     		bne	.L125
 420:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_INTERRUPT == bmAttributes) {
 1474              		.loc 1 420 0
 1475 00ac 0323     		movs	r3, #3
 1476 00ae BEE7     		b	.L128
 1477              	.L125:
 421:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_INTERRUPT;
 1478              		.loc 1 421 0
 1479 00b0 0329     		cmp	r1, #3
 1480 00b2 F4D1     		bne	.L126
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1481              		.loc 1 422 0
 1482 00b4 0423     		movs	r3, #4
 1483 00b6 BAE7     		b	.L128
 1484              	.L130:
 1485              		.align	2
 1486              	.L129:
 1487 00b8 00000000 		.word	usb_device
 1488 00bc 00000000 		.word	udd_ep_transfer_process
 1489              		.cfi_endproc
 1490              	.LFE153:
 1492              		.section	.text.udd_ep_is_halted,"ax",%progbits
 1493              		.align	1
 1494              		.global	udd_ep_is_halted
 1495              		.syntax unified
 1496              		.thumb
 1497              		.thumb_func
 1498              		.fpu fpv4-sp-d16
 1500              	udd_ep_is_halted:
 1501              	.LFB154:
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1502              		.loc 1 439 0
 1503              		.cfi_startproc
 1504              		@ args = 0, pretend = 0, frame = 0
 1505              		@ frame_needed = 0, uses_anonymous_args = 0
 1506              		@ link register save eliminated.
 1507              	.LVL127:
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1508              		.loc 1 439 0
 1509 0000 0146     		mov	r1, r0
 1510 0002 0148     		ldr	r0, .L132
 1511              	.LVL128:
 1512 0004 FFF7FEBF 		b	usb_device_endpoint_is_halted
 1513              	.LVL129:
 1514              	.L133:
 1515              		.align	2
 1516              	.L132:
 1517 0008 00000000 		.word	usb_device
 1518              		.cfi_endproc
 1519              	.LFE154:
 1521              		.section	.text.udd_ep_set_halt,"ax",%progbits
 1522              		.align	1
 1523              		.global	udd_ep_set_halt
 1524              		.syntax unified
 1525              		.thumb
 1526              		.thumb_func
 1527              		.fpu fpv4-sp-d16
 1529              	udd_ep_set_halt:
 1530              	.LFB155:
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 1531              		.loc 1 441 0
 1532              		.cfi_startproc
 1533              		@ args = 0, pretend = 0, frame = 0
 1534              		@ frame_needed = 0, uses_anonymous_args = 0
 1535              	.LVL130:
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1536              		.loc 1 444 0
 1537 0000 00F00F03 		and	r3, r0, #15
 1538 0004 042B     		cmp	r3, #4
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 1539              		.loc 1 441 0
 1540 0006 10B5     		push	{r4, lr}
 1541              		.cfi_def_cfa_offset 8
 1542              		.cfi_offset 4, -8
 1543              		.cfi_offset 14, -4
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 1544              		.loc 1 441 0
 1545 0008 0446     		mov	r4, r0
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1546              		.loc 1 444 0
 1547 000a 08D8     		bhi	.L136
 448:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1548              		.loc 1 448 0
 1549 000c 0146     		mov	r1, r0
 1550 000e 0548     		ldr	r0, .L137
 1551              	.LVL131:
 1552 0010 FFF7FEFF 		bl	usb_device_endpoint_set_halt
 1553              	.LVL132:
 450:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 1554              		.loc 1 450 0
 1555 0014 2046     		mov	r0, r4
 1556 0016 FFF7FEFF 		bl	udd_ep_abort
 1557              	.LVL133:
 451:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1558              		.loc 1 451 0
 1559 001a 0120     		movs	r0, #1
 1560              	.L135:
 452:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1561              		.loc 1 452 0
 1562 001c 10BD     		pop	{r4, pc}
 1563              	.LVL134:
 1564              	.L136:
 445:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1565              		.loc 1 445 0
 1566 001e 0020     		movs	r0, #0
 1567              	.LVL135:
 1568 0020 FCE7     		b	.L135
 1569              	.L138:
 1570 0022 00BF     		.align	2
 1571              	.L137:
 1572 0024 00000000 		.word	usb_device
 1573              		.cfi_endproc
 1574              	.LFE155:
 1576              		.section	.text._usb_ep0_on_tansfer_ok,"ax",%progbits
 1577              		.align	1
 1578              		.syntax unified
 1579              		.thumb
 1580              		.thumb_func
 1581              		.fpu fpv4-sp-d16
 1583              	_usb_ep0_on_tansfer_ok:
 1584              	.LFB172:
 847:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) { /* handshake Out for status stage */
 1585              		.loc 1 847 0
 1586              		.cfi_startproc
 1587              		@ args = 0, pretend = 0, frame = 0
 1588              		@ frame_needed = 0, uses_anonymous_args = 0
 1589              	.LVL136:
 1590 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1591              		.cfi_def_cfa_offset 24
 1592              		.cfi_offset 4, -24
 1593              		.cfi_offset 5, -20
 1594              		.cfi_offset 6, -16
 1595              		.cfi_offset 7, -12
 1596              		.cfi_offset 8, -8
 1597              		.cfi_offset 14, -4
 848:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_out_received(pointer);
 1598              		.loc 1 848 0
 1599 0004 2D4C     		ldr	r4, .L161
 1600 0006 94F8A030 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 1601 000a 012B     		cmp	r3, #1
 1602 000c 47D1     		bne	.L140
 1603              	.LVL137:
 1604              	.LBB98:
 1605              	.LBB99:
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1606              		.loc 1 687 0
 1607 000e 2C4E     		ldr	r6, .L161+4
 685:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1608              		.loc 1 685 0
 1609 0010 0F88     		ldrh	r7, [r1]
 1610              	.LVL138:
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1611              		.loc 1 687 0
 1612 0012 B4F8A250 		ldrh	r5, [r4, #162]
 1613 0016 B389     		ldrh	r3, [r6, #12]
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1614              		.loc 1 692 0
 1615 0018 B068     		ldr	r0, [r6, #8]
 1616              	.LVL139:
 1617 001a 2A49     		ldr	r1, .L161+8
 1618              	.LVL140:
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1619              		.loc 1 687 0
 1620 001c EA19     		adds	r2, r5, r7
 1621 001e 9342     		cmp	r3, r2
 689:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1622              		.loc 1 689 0
 1623 0020 BCBF     		itt	lt
 1624 0022 5F1B     		sublt	r7, r3, r5
 1625              	.LVL141:
 1626 0024 BFB2     		uxthlt	r7, r7
 1627              	.LVL142:
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1628              		.loc 1 692 0
 1629 0026 2844     		add	r0, r0, r5
 1630 0028 3A46     		mov	r2, r7
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1631              		.loc 1 693 0
 1632 002a 3D44     		add	r5, r5, r7
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1633              		.loc 1 692 0
 1634 002c FFF7FEFF 		bl	memcpy
 1635              	.LVL143:
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1636              		.loc 1 693 0
 1637 0030 ADB2     		uxth	r5, r5
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1638              		.loc 1 695 0
 1639 0032 082F     		cmp	r7, #8
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1640              		.loc 1 693 0
 1641 0034 A4F8A250 		strh	r5, [r4, #162]	@ movhi
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1642              		.loc 1 695 0
 1643 0038 05D1     		bne	.L142
 1644 003a B4F8A430 		ldrh	r3, [r4, #164]
 1645 003e F288     		ldrh	r2, [r6, #6]
 1646 0040 2B44     		add	r3, r3, r5
 1647 0042 9A42     		cmp	r2, r3
 1648 0044 10DC     		bgt	.L143
 1649              	.L142:
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 1650              		.loc 1 702 0
 1651 0046 7369     		ldr	r3, [r6, #20]
 701:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.over_under_run) {
 1652              		.loc 1 701 0
 1653 0048 B581     		strh	r5, [r6, #12]	@ movhi
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 1654              		.loc 1 702 0
 1655 004a 4BB1     		cbz	r3, .L144
 703:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall ZLP */
 1656              		.loc 1 703 0
 1657 004c 9847     		blx	r3
 1658              	.LVL144:
 1659 004e 38B9     		cbnz	r0, .L144
 1660              	.L146:
 705:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall all packets on IN & OUT control endpoint */
 1661              		.loc 1 705 0
 1662 0050 0523     		movs	r3, #5
 1663 0052 84F8A030 		strb	r3, [r4, #160]
 707:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Ack reception of OUT to replace NAK by a STALL */
 1664              		.loc 1 707 0
 1665 0056 0020     		movs	r0, #0
 1666              	.LBE99:
 1667              	.LBE98:
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1668              		.loc 1 858 0
 1669 0058 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1670              		.cfi_remember_state
 1671              		.cfi_restore 14
 1672              		.cfi_restore 8
 1673              		.cfi_restore 7
 1674              		.cfi_restore 6
 1675              		.cfi_restore 5
 1676              		.cfi_restore 4
 1677              		.cfi_def_cfa_offset 0
 1678              	.LVL145:
 1679              	.LBB103:
 1680              	.LBB100:
 707:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Ack reception of OUT to replace NAK by a STALL */
 1681              		.loc 1 707 0
 1682 005c FFF7FEBF 		b	udd_ep_set_halt
 1683              	.LVL146:
 1684              	.L144:
 1685              		.cfi_restore_state
 1686              	.LBE100:
 1687              	.LBE103:
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1688              		.loc 1 858 0
 1689 0060 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1690              		.cfi_remember_state
 1691              		.cfi_restore 14
 1692              		.cfi_restore 8
 1693              		.cfi_restore 7
 1694              		.cfi_restore 6
 1695              		.cfi_restore 5
 1696              		.cfi_restore 4
 1697              		.cfi_def_cfa_offset 0
 1698              	.LVL147:
 1699              	.LBB104:
 1700              	.LBB101:
 713:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1701              		.loc 1 713 0
 1702 0064 FFF7FEBF 		b	udd_ctrl_send_zlp_in
 1703              	.LVL148:
 1704              	.L143:
 1705              		.cfi_restore_state
 717:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Overrun then request a new payload buffer */
 1706              		.loc 1 717 0
 1707 0068 B389     		ldrh	r3, [r6, #12]
 1708 006a AB42     		cmp	r3, r5
 1709 006c 0FD1     		bne	.L145
 719:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No callback available to request a new payload buffer
 1710              		.loc 1 719 0
 1711 006e 7369     		ldr	r3, [r6, #20]
 1712 0070 002B     		cmp	r3, #0
 1713 0072 EDD0     		beq	.L146
 727:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No new payload buffer delivered
 1714              		.loc 1 727 0
 1715 0074 9847     		blx	r3
 1716              	.LVL149:
 1717 0076 0028     		cmp	r0, #0
 1718 0078 EAD0     		beq	.L146
 737:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1719              		.loc 1 737 0
 1720 007a B4F8A430 		ldrh	r3, [r4, #164]
 1721 007e B4F8A220 		ldrh	r2, [r4, #162]
 1722 0082 1344     		add	r3, r3, r2
 1723 0084 A4F8A430 		strh	r3, [r4, #164]	@ movhi
 740:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1724              		.loc 1 740 0
 1725 0088 0023     		movs	r3, #0
 1726 008a A4F8A230 		strh	r3, [r4, #162]	@ movhi
 1727              	.L145:
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1728              		.loc 1 742 0
 1729 008e 0823     		movs	r3, #8
 1730 0090 0C4A     		ldr	r2, .L161+8
 1731 0092 0D48     		ldr	r0, .L161+12
 1732 0094 0021     		movs	r1, #0
 1733              	.LBE101:
 1734              	.LBE104:
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1735              		.loc 1 858 0
 1736 0096 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1737              		.cfi_remember_state
 1738              		.cfi_restore 14
 1739              		.cfi_restore 8
 1740              		.cfi_restore 7
 1741              		.cfi_restore 6
 1742              		.cfi_restore 5
 1743              		.cfi_restore 4
 1744              		.cfi_def_cfa_offset 0
 1745              	.LVL150:
 1746              	.LBB105:
 1747              	.LBB102:
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1748              		.loc 1 742 0
 1749 009a FFF7FEBF 		b	usb_device_endpoint_read_buffer_job
 1750              	.LVL151:
 1751              	.L140:
 1752              		.cfi_restore_state
 1753              	.LBE102:
 1754              	.LBE105:
 850:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_in_sent();
 1755              		.loc 1 850 0
 1756 009e 022B     		cmp	r3, #2
 1757 00a0 03D1     		bne	.L147
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1758              		.loc 1 858 0
 1759 00a2 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1760              		.cfi_remember_state
 1761              		.cfi_restore 14
 1762              		.cfi_restore 8
 1763              		.cfi_restore 7
 1764              		.cfi_restore 6
 1765              		.cfi_restore 5
 1766              		.cfi_restore 4
 1767              		.cfi_def_cfa_offset 0
 851:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1768              		.loc 1 851 0
 1769 00a6 FFF7FEBF 		b	udd_ctrl_in_sent
 1770              	.LVL152:
 1771              	.L147:
 1772              		.cfi_restore_state
 853:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 1773              		.loc 1 853 0
 1774 00aa 054B     		ldr	r3, .L161+4
 1775 00ac 1B69     		ldr	r3, [r3, #16]
 1776 00ae 03B1     		cbz	r3, .L148
 854:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 1777              		.loc 1 854 0
 1778 00b0 9847     		blx	r3
 1779              	.LVL153:
 1780              	.L148:
 856:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1781              		.loc 1 856 0
 1782 00b2 0023     		movs	r3, #0
 1783 00b4 84F8A030 		strb	r3, [r4, #160]
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1784              		.loc 1 858 0
 1785 00b8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1786              	.L162:
 1787              		.align	2
 1788              	.L161:
 1789 00bc 00000000 		.word	.LANCHOR0
 1790 00c0 00000000 		.word	udd_g_ctrlreq
 1791 00c4 00000000 		.word	udd_ctrl_buffer
 1792 00c8 00000000 		.word	usb_device
 1793              		.cfi_endproc
 1794              	.LFE172:
 1796              		.section	.text.udd_ep_clear_halt,"ax",%progbits
 1797              		.align	1
 1798              		.global	udd_ep_clear_halt
 1799              		.syntax unified
 1800              		.thumb
 1801              		.thumb_func
 1802              		.fpu fpv4-sp-d16
 1804              	udd_ep_clear_halt:
 1805              	.LFB156:
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1806              		.loc 1 454 0
 1807              		.cfi_startproc
 1808              		@ args = 0, pretend = 0, frame = 0
 1809              		@ frame_needed = 0, uses_anonymous_args = 0
 1810              	.LVL154:
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1811              		.loc 1 458 0
 1812 0000 00F00F03 		and	r3, r0, #15
 1813 0004 042B     		cmp	r3, #4
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1814              		.loc 1 454 0
 1815 0006 10B5     		push	{r4, lr}
 1816              		.cfi_def_cfa_offset 8
 1817              		.cfi_offset 4, -8
 1818              		.cfi_offset 14, -4
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1819              		.loc 1 454 0
 1820 0008 0146     		mov	r1, r0
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1821              		.loc 1 458 0
 1822 000a 0FD8     		bhi	.L165
 461:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1823              		.loc 1 461 0
 1824 000c FFF7FEFF 		bl	udd_ep_get_job
 1825              	.LVL155:
 1826 0010 0446     		mov	r4, r0
 1827              	.LVL156:
 463:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1828              		.loc 1 463 0
 1829 0012 0748     		ldr	r0, .L167
 1830              	.LVL157:
 1831 0014 FFF7FEFF 		bl	usb_device_endpoint_clear_halt
 1832              	.LVL158:
 466:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy = false;
 1833              		.loc 1 466 0
 1834 0018 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 1835 001a DA07     		lsls	r2, r3, #31
 1836 001c 04D5     		bpl	.L166
 467:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt();
 1837              		.loc 1 467 0
 1838 001e 6FF30003 		bfc	r3, #0, #1
 1839 0022 A374     		strb	r3, [r4, #18]
 468:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1840              		.loc 1 468 0
 1841 0024 2368     		ldr	r3, [r4]
 1842 0026 9847     		blx	r3
 1843              	.LVL159:
 1844              	.L166:
 471:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1845              		.loc 1 471 0
 1846 0028 0120     		movs	r0, #1
 1847 002a 00E0     		b	.L164
 1848              	.LVL160:
 1849              	.L165:
 459:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1850              		.loc 1 459 0
 1851 002c 0020     		movs	r0, #0
 1852              	.LVL161:
 1853              	.L164:
 472:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1854              		.loc 1 472 0
 1855 002e 10BD     		pop	{r4, pc}
 1856              	.L168:
 1857              		.align	2
 1858              	.L167:
 1859 0030 00000000 		.word	usb_device
 1860              		.cfi_endproc
 1861              	.LFE156:
 1863              		.section	.text.udd_ep_wait_stall_clear,"ax",%progbits
 1864              		.align	1
 1865              		.global	udd_ep_wait_stall_clear
 1866              		.syntax unified
 1867              		.thumb
 1868              		.thumb_func
 1869              		.fpu fpv4-sp-d16
 1871              	udd_ep_wait_stall_clear:
 1872              	.LFB157:
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 1873              		.loc 1 474 0
 1874              		.cfi_startproc
 1875              		@ args = 0, pretend = 0, frame = 0
 1876              		@ frame_needed = 0, uses_anonymous_args = 0
 1877              	.LVL162:
 1878 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1879              		.cfi_def_cfa_offset 24
 1880              		.cfi_offset 3, -24
 1881              		.cfi_offset 4, -20
 1882              		.cfi_offset 5, -16
 1883              		.cfi_offset 6, -12
 1884              		.cfi_offset 7, -8
 1885              		.cfi_offset 14, -4
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1886              		.loc 1 479 0
 1887 0002 00F00F03 		and	r3, r0, #15
 1888 0006 042B     		cmp	r3, #4
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 1889              		.loc 1 474 0
 1890 0008 0646     		mov	r6, r0
 1891 000a 0F46     		mov	r7, r1
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1892              		.loc 1 479 0
 1893 000c 02D9     		bls	.L170
 1894              	.LVL163:
 1895              	.L172:
 480:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1896              		.loc 1 480 0
 1897 000e 0024     		movs	r4, #0
 1898              	.L171:
 500:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1899              		.loc 1 500 0
 1900 0010 2046     		mov	r0, r4
 1901 0012 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1902              	.LVL164:
 1903              	.L170:
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 1904              		.loc 1 483 0
 1905 0014 FFF7FEFF 		bl	udd_ep_get_job
 1906              	.LVL165:
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 1907              		.loc 1 484 0
 1908 0018 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 1909 001a DB07     		lsls	r3, r3, #31
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 1910              		.loc 1 483 0
 1911 001c 0546     		mov	r5, r0
 1912              	.LVL166:
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 1913              		.loc 1 484 0
 1914 001e F6D4     		bmi	.L172
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 1915              		.loc 1 489 0
 1916 0020 3146     		mov	r1, r6
 1917              	.LVL167:
 1918 0022 0A48     		ldr	r0, .L177
 1919              	.LVL168:
 1920 0024 FFF7FEFF 		bl	usb_device_endpoint_is_halted
 1921              	.LVL169:
 1922 0028 0446     		mov	r4, r0
 1923 002a 28B1     		cbz	r0, .L173
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 1924              		.loc 1 491 0
 1925 002c AB7C     		ldrb	r3, [r5, #18]	@ zero_extendqisi2
 492:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 1926              		.loc 1 492 0
 1927 002e 2F60     		str	r7, [r5]
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 1928              		.loc 1 491 0
 1929 0030 43F00103 		orr	r3, r3, #1
 1930 0034 AB74     		strb	r3, [r5, #18]
 493:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (usb_device_endpoint_is_configured(&usb_device, ep)) {
 1931              		.loc 1 493 0
 1932 0036 EBE7     		b	.L171
 1933              	.L173:
 494:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         callback(); /* Endpoint not halted then call directly callback */
 1934              		.loc 1 494 0
 1935 0038 3146     		mov	r1, r6
 1936 003a 0448     		ldr	r0, .L177
 1937 003c FFF7FEFF 		bl	usb_device_endpoint_is_configured
 1938              	.LVL170:
 1939 0040 0446     		mov	r4, r0
 1940 0042 0028     		cmp	r0, #0
 1941 0044 E3D0     		beq	.L172
 495:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 1942              		.loc 1 495 0
 1943 0046 B847     		blx	r7
 1944              	.LVL171:
 496:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1945              		.loc 1 496 0
 1946 0048 E2E7     		b	.L171
 1947              	.L178:
 1948 004a 00BF     		.align	2
 1949              	.L177:
 1950 004c 00000000 		.word	usb_device
 1951              		.cfi_endproc
 1952              	.LFE157:
 1954              		.section	.text.udd_ep_run,"ax",%progbits
 1955              		.align	1
 1956              		.global	udd_ep_run
 1957              		.syntax unified
 1958              		.thumb
 1959              		.thumb_func
 1960              		.fpu fpv4-sp-d16
 1962              	udd_ep_run:
 1963              	.LFB159:
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 1964              		.loc 1 512 0
 1965              		.cfi_startproc
 1966              		@ args = 4, pretend = 0, frame = 0
 1967              		@ frame_needed = 0, uses_anonymous_args = 0
 1968              	.LVL172:
 1969 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1970              		.cfi_def_cfa_offset 32
 1971              		.cfi_offset 4, -32
 1972              		.cfi_offset 5, -28
 1973              		.cfi_offset 6, -24
 1974              		.cfi_offset 7, -20
 1975              		.cfi_offset 8, -16
 1976              		.cfi_offset 9, -12
 1977              		.cfi_offset 10, -8
 1978              		.cfi_offset 14, -4
 517:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1979              		.loc 1 517 0
 1980 0004 00F00F06 		and	r6, r0, #15
 1981              	.LVL173:
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1982              		.loc 1 519 0
 1983 0008 042E     		cmp	r6, #4
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 1984              		.loc 1 512 0
 1985 000a 8146     		mov	r9, r0
 1986 000c 8A46     		mov	r10, r1
 1987 000e 1746     		mov	r7, r2
 1988 0010 1C46     		mov	r4, r3
 1989 0012 DDF82080 		ldr	r8, [sp, #32]
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1990              		.loc 1 519 0
 1991 0016 03D9     		bls	.L180
 1992              	.LVL174:
 1993              	.L182:
 520:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1994              		.loc 1 520 0
 1995 0018 0025     		movs	r5, #0
 1996              	.LVL175:
 1997              	.L181:
 592:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1998              		.loc 1 592 0
 1999 001a 2846     		mov	r0, r5
 2000 001c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2001              	.LVL176:
 2002              	.L180:
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2003              		.loc 1 519 0 discriminator 1
 2004 0020 FFF7FEFF 		bl	udd_ep_is_halted
 2005              	.LVL177:
 2006 0024 0546     		mov	r5, r0
 2007 0026 0028     		cmp	r0, #0
 2008 0028 F6D1     		bne	.L182
 523:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2009              		.loc 1 523 0
 2010 002a 4846     		mov	r0, r9
 2011 002c FFF7FEFF 		bl	udd_ep_get_job
 2012              	.LVL178:
 2013              	.LBB106:
 2014              	.LBB107:
 2015              		.file 3 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h"
   1:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.1
   5:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @date     02. February 2017
   6:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /*
   8:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  10:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  12:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  16:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  18:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  24:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  25:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  28:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  34:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  35:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  36:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                     __asm
  37:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  38:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  39:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                  inline
  40:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  41:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  42:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE           static inline
  43:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  44:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  45:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN               __attribute__((noreturn))
  46:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  47:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  48:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __USED                    __attribute__((used))
  49:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  50:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  51:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                    __attribute__((weak))
  52:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  53:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32
  54:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  55:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wpacked"
  56:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wattributes"
  57:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  58:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic pop
  59:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
  60:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  61:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
  62:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)              __attribute__((aligned(x)))
  63:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  64:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  65:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                  __attribute__((packed, aligned(1)))
  66:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  67:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  68:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT           struct __attribute__((packed, aligned(1)))
  69:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  70:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  71:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  72:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  73:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  74:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  75:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   @{
  76:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  77:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  78:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
  79:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  80:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  81:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  82:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  83:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
  84:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
  85:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  86:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
  87:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  88:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  89:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
  90:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  91:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  92:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  93:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  94:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
  95:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
  96:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  97:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
  98:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  99:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 100:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 101:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 102:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 103:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 104:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 105:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 106:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 107:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 109:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 110:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 112:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 113:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 114:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 115:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 116:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 117:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 118:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 119:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 120:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 121:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 122:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 123:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 124:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 125:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 126:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 127:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 128:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 129:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 130:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 131:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 132:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 133:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 134:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 135:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 136:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 137:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 138:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 139:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 140:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 141:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 142:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 143:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 144:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 145:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 146:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 147:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 148:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 149:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 150:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 151:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 152:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 153:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 154:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 155:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 156:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 157:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 158:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 159:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 160:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 161:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 162:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 163:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 164:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 165:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 166:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 167:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 168:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 169:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 170:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 171:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 172:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 173:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 174:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 175:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 176:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 177:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 178:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 180:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 181:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 182:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 183:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 184:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 185:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 186:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 187:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 188:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 189:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 190:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 191:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 192:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 193:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 194:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 195:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 196:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 197:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 198:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 199:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 200:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 201:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 202:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 203:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 204:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 205:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 206:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 207:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 208:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 209:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 210:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 211:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 212:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 213:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 214:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 215:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 216:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 217:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 218:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 219:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 220:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 221:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 222:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 223:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 224:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 225:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 226:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 227:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 228:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 229:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 230:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 231:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 232:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 233:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 234:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 235:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 236:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 237:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 238:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 239:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 240:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 241:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 242:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 243:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 244:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 245:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 246:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 247:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 248:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 249:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 250:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 251:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 252:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 253:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 254:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 255:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 256:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 257:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 258:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 259:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 260:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 261:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 262:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 263:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 264:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 265:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 266:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 267:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 268:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 269:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 270:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 271:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 272:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 273:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 274:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 275:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 276:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 277:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 278:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 279:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 280:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 281:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 282:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 283:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 284:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 285:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 286:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 287:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 288:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 289:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 290:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 291:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 292:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 293:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 294:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 295:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 296:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 297:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 298:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 299:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 300:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 301:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 302:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 303:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 304:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 305:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 306:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 307:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 308:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 309:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 310:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 311:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 312:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 313:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 2016              		.loc 3 313 0
 2017              		.syntax unified
 2018              	@ 313 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2019 0030 EFF31081 		MRS r1, primask
 2020              	@ 0 "" 2
 2021              		.thumb
 2022              		.syntax unified
 2023              	.LBE107:
 2024              	.LBE106:
 2025              	.LBB108:
 2026              	.LBB109:
  96:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2027              		.loc 3 96 0
 2028              		.syntax unified
 2029              	@ 96 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2030 0034 72B6     		cpsid i
 2031              	@ 0 "" 2
 2032              		.thumb
 2033              		.syntax unified
 2034              	.LBE109:
 2035              	.LBE108:
 2036              	.LBB110:
 2037              	.LBB111:
 314:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 315:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 316:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 317:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 318:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 319:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 320:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 321:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 322:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 323:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 324:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 325:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 326:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 327:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 328:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 329:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 330:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 331:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 332:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 333:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 334:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 335:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 336:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 337:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 338:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 339:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 340:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 342:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 343:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 344:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 345:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 346:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 347:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 348:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 349:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 350:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 351:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 352:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 353:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 354:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 355:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 356:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 357:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 358:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 359:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 360:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 361:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 362:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 363:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 364:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 365:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 366:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 367:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 368:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 369:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 370:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 371:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 372:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 373:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 374:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 375:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 376:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 377:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 378:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 379:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 380:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 381:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 382:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 383:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 384:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 385:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 386:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 387:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 388:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 389:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 390:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 391:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 392:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 393:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 394:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 395:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 396:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 397:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 398:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 399:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 400:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 401:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 402:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 403:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 404:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 405:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 406:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 407:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 408:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 409:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 410:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 411:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 412:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 413:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 414:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 415:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 416:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 417:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 418:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 419:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 420:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 421:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 422:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 423:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 424:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 425:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 426:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 427:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 428:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 429:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 430:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 431:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 432:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 433:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 434:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 435:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 436:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 437:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 438:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 439:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 440:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 441:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 442:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 443:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 444:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 445:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 446:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 447:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 448:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 449:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 450:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 451:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 452:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 453:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 454:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 455:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 456:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 457:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 458:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 459:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 460:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 461:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 462:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 463:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 464:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 465:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 466:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 467:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 468:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 469:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 470:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 471:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 472:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 473:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 474:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 475:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 476:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 477:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 478:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 479:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 480:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 481:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 482:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 483:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 484:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 485:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 486:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 487:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 488:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 489:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 490:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 491:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 492:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 493:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 494:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 495:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 496:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 497:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 498:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 499:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 500:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 501:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 502:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 503:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 504:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 505:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 506:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 507:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 508:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 509:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 510:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 511:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 512:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 513:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 514:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 515:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 516:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 517:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 518:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 519:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 520:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 521:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 522:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 523:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 524:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 525:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 526:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 527:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 528:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 529:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 530:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 531:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 532:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 533:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 534:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 535:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 536:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 537:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 538:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 539:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 540:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 541:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 542:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 543:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 544:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 545:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 546:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 547:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 548:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 549:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 550:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 551:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 552:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 553:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 554:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 555:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 556:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 557:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 558:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 559:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 560:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 561:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 562:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 563:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 564:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 565:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 566:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 567:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 568:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 569:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 570:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 571:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 572:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 573:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 574:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 575:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 576:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 577:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 578:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 579:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 580:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 581:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 582:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 583:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 584:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 585:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 586:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 587:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 588:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 589:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 590:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 591:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 592:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 593:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 594:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 595:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 596:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 597:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 598:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 599:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 600:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 601:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 602:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 603:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 604:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 605:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 606:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 607:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 608:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 609:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 610:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 611:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 612:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 613:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 614:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 615:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 616:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 617:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 618:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 619:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 620:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 621:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 622:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 623:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 624:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 625:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 626:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 627:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 628:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 629:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 630:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 631:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 632:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 633:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 634:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 635:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 636:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 637:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 638:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 639:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 640:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 641:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 642:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #else
 643:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****    return(0U);
 644:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 645:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 646:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 647:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 648:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 649:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 650:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 651:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 652:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 653:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 654:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 655:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 656:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 657:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 658:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #else
 659:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 660:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 661:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 662:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 663:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 664:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 665:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 666:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 667:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 668:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 669:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 670:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 671:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 672:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 673:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 674:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   @{
 675:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** */
 676:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 677:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 678:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 679:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 680:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 681:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 682:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 683:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 684:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #else
 685:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 686:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 687:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 688:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 689:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 690:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 691:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 692:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 693:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 694:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 695:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 696:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("nop");
 697:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 698:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 699:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 700:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 701:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 702:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 703:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 704:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 705:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 706:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 707:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 708:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 709:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 710:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 711:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 712:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 713:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 714:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 715:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 716:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 717:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 718:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 719:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 720:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 721:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 722:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 723:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 724:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 725:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 726:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 727:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 728:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 729:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("sev");
 730:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 731:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 732:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 733:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 734:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 735:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 736:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 737:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 738:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 739:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 740:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 741:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 742:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 743:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 744:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 745:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 746:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 747:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 748:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 749:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 750:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 751:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 752:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 753:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 754:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 755:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 756:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 757:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 758:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 759:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 760:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 761:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 762:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
 763:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 764:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 2038              		.loc 3 764 0
 2039              		.syntax unified
 2040              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2041 0036 BFF35F8F 		dmb 0xF
 2042              	@ 0 "" 2
 2043              		.thumb
 2044              		.syntax unified
 2045              	.LBE111:
 2046              	.LBE110:
 529:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __DMB();
 2047              		.loc 1 529 0
 2048 003a 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 2049 003c 13F00102 		ands	r2, r3, #1
 2050 0040 04D0     		beq	.L183
 2051              	.LBB112:
 2052              	.LBB113:
 2053              		.loc 3 764 0
 2054              		.syntax unified
 2055              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2056 0042 BFF35F8F 		dmb 0xF
 2057              	@ 0 "" 2
 2058              	.LVL179:
 2059              		.thumb
 2060              		.syntax unified
 2061              	.LBE113:
 2062              	.LBE112:
 2063              	.LBB114:
 2064              	.LBB115:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2065              		.loc 3 341 0
 2066              		.syntax unified
 2067              	@ 341 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2068 0046 81F31088 		MSR primask, r1
 2069              	@ 0 "" 2
 2070              	.LVL180:
 2071              		.thumb
 2072              		.syntax unified
 2073              	.LBE115:
 2074              	.LBE114:
 532:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2075              		.loc 1 532 0
 2076 004a E6E7     		b	.L181
 2077              	.L183:
 535:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 2078              		.loc 1 535 0
 2079 004c 43F00103 		orr	r3, r3, #1
 2080 0050 8374     		strb	r3, [r0, #18]
 2081              	.LBB116:
 2082              	.LBB117:
 2083              		.loc 3 764 0
 2084              		.syntax unified
 2085              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2086 0052 BFF35F8F 		dmb 0xF
 2087              	@ 0 "" 2
 2088              	.LVL181:
 2089              		.thumb
 2090              		.syntax unified
 2091              	.LBE117:
 2092              	.LBE116:
 2093              	.LBB118:
 2094              	.LBB119:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2095              		.loc 3 341 0
 2096              		.syntax unified
 2097              	@ 341 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2098 0056 81F31088 		MSR primask, r1
 2099              	@ 0 "" 2
 2100              	.LVL182:
 2101              		.thumb
 2102              		.syntax unified
 2103              	.LBE119:
 2104              	.LBE118:
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 2105              		.loc 1 544 0
 2106 005a 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 542:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->call_trans             = callback;
 2107              		.loc 1 542 0
 2108 005c C260     		str	r2, [r0, #12]
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 2109              		.loc 1 544 0
 2110 005e 6AF34103 		bfi	r3, r10, #1, #1
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2111              		.loc 1 545 0
 2112 0062 62F38203 		bfi	r3, r2, #2, #1
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 2113              		.loc 1 550 0
 2114 0066 19F0800F 		tst	r9, #128
 541:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans               = 0;
 2115              		.loc 1 541 0
 2116 006a C0E90174 		strd	r7, r4, [r0, #4]
 543:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_shortpacket          = b_shortpacket;
 2117              		.loc 1 543 0
 2118 006e C0F80080 		str	r8, [r0]
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2119              		.loc 1 545 0
 2120 0072 8374     		strb	r3, [r0, #18]
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 2121              		.loc 1 550 0
 2122 0074 3AD0     		beq	.L184
 2123 0076 DBB2     		uxtb	r3, r3
 2124 0078 03F00205 		and	r5, r3, #2
 551:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 2125              		.loc 1 551 0
 2126 007c 1CB3     		cbz	r4, .L185
 552:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 2127              		.loc 1 552 0
 2128 007e A3B2     		uxth	r3, r4
 2129              	.LVL183:
 553:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 2130              		.loc 1 553 0
 2131 0080 B3F5005F 		cmp	r3, #8192
 2132 0084 08D3     		bcc	.L186
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2133              		.loc 1 554 0
 2134 0086 028A     		ldrh	r2, [r0, #16]
 2135 0088 41F6FF73 		movw	r3, #8191
 2136              	.LVL184:
 2137 008c 93FBF2F4 		sdiv	r4, r3, r2
 2138              	.LVL185:
 2139 0090 02FB1434 		mls	r4, r2, r4, r3
 2140 0094 1B1B     		subs	r3, r3, r4
 2141 0096 9BB2     		uxth	r3, r3
 2142              	.LVL186:
 2143              	.L186:
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2144              		.loc 1 556 0
 2145 0098 45B1     		cbz	r5, .L187
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2146              		.loc 1 556 0 is_stmt 0 discriminator 1
 2147 009a 028A     		ldrh	r2, [r0, #16]
 2148 009c B3FBF2F5 		udiv	r5, r3, r2
 2149 00a0 02FB1535 		mls	r5, r2, r5, r3
 2150 00a4 ADB2     		uxth	r5, r5
 2151 00a6 B5FA85F5 		clz	r5, r5
 2152 00aa 6D09     		lsrs	r5, r5, #5
 2153              	.L187:
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2154              		.loc 1 556 0 discriminator 6
 2155 00ac 827C     		ldrb	r2, [r0, #18]	@ zero_extendqisi2
 2156 00ae 65F34102 		bfi	r2, r5, #1, #1
 2157 00b2 8274     		strb	r2, [r0, #18]
 2158              	.LVL187:
 2159              	.L188:
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2160              		.loc 1 567 0 is_stmt 1
 2161 00b4 3A46     		mov	r2, r7
 2162 00b6 3146     		mov	r1, r6
 2163 00b8 2048     		ldr	r0, .L203
 2164              	.LVL188:
 2165 00ba FFF7FEFF 		bl	usb_device_endpoint_write_buffer_job
 2166              	.LVL189:
 2167              	.L201:
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2168              		.loc 1 582 0
 2169 00be B0FA80F5 		clz	r5, r0
 2170 00c2 6D09     		lsrs	r5, r5, #5
 2171 00c4 A9E7     		b	.L181
 2172              	.LVL190:
 2173              	.L185:
 557:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = false; /* avoid to send zero length packet again */
 2174              		.loc 1 557 0
 2175 00c6 25B1     		cbz	r5, .L189
 558:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans             = 0;
 2176              		.loc 1 558 0
 2177 00c8 64F34103 		bfi	r3, r4, #1, #1
 2178 00cc 8374     		strb	r3, [r0, #18]
 2179              	.LVL191:
 559:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 2180              		.loc 1 559 0
 2181 00ce 2346     		mov	r3, r4
 2182 00d0 F0E7     		b	.L188
 2183              	.LVL192:
 2184              	.L189:
 561:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 2185              		.loc 1 561 0
 2186 00d2 65F30003 		bfi	r3, r5, #0, #1
 2187              	.L198:
 2188 00d6 8374     		strb	r3, [r0, #18]
 562:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 2189              		.loc 1 562 0
 2190 00d8 B8F1000F 		cmp	r8, #0
 2191 00dc 01D1     		bne	.L190
 2192              	.LVL193:
 2193              	.L200:
 565:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 2194              		.loc 1 565 0
 2195 00de 0125     		movs	r5, #1
 2196 00e0 9BE7     		b	.L181
 2197              	.LVL194:
 2198              	.L190:
 563:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2199              		.loc 1 563 0
 2200 00e2 0021     		movs	r1, #0
 2201 00e4 4A46     		mov	r2, r9
 2202 00e6 0846     		mov	r0, r1
 2203              	.LVL195:
 2204 00e8 C047     		blx	r8
 2205              	.LVL196:
 2206 00ea F8E7     		b	.L200
 2207              	.LVL197:
 2208              	.L184:
 569:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 2209              		.loc 1 569 0
 2210 00ec 0CB3     		cbz	r4, .L191
 570:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 2211              		.loc 1 570 0
 2212 00ee A4B2     		uxth	r4, r4
 2213              	.LVL198:
 2214 00f0 038A     		ldrh	r3, [r0, #16]
 571:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* The USB hardware support a maximum transfer size
 2215              		.loc 1 571 0
 2216 00f2 B4F5005F 		cmp	r4, #8192
 574:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2217              		.loc 1 574 0
 2218 00f6 2ABF     		itet	cs
 2219 00f8 41F6FF74 		movwcs	r4, #8191
 2220              	.LVL199:
 576:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2221              		.loc 1 576 0
 2222 00fc B4FBF3F2 		udivcc	r2, r4, r3
 574:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2223              		.loc 1 574 0
 2224 0100 94FBF3F2 		sdivcs	r2, r4, r3
 576:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2225              		.loc 1 576 0
 2226 0104 03FB1242 		mls	r2, r3, r2, r4
 2227 0108 A41A     		subs	r4, r4, r2
 2228 010a A4B2     		uxth	r4, r4
 2229              	.LVL200:
 578:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->b_use_out_cache_buffer = true;
 2230              		.loc 1 578 0
 2231 010c 9C42     		cmp	r4, r3
 579:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_e
 2232              		.loc 1 579 0
 2233 010e 3FBF     		itttt	cc
 2234 0110 827C     		ldrbcc	r2, [r0, #18]	@ zero_extendqisi2
 2235 0112 42F00402 		orrcc	r2, r2, #4
 2236 0116 8274     		strbcc	r2, [r0, #18]
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2237              		.loc 1 580 0
 2238 0118 094A     		ldrcc	r2, .L203+4
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2239              		.loc 1 582 0
 2240 011a 0848     		ldr	r0, .L203
 2241              	.LVL201:
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2242              		.loc 1 580 0
 2243 011c 39BF     		ittee	cc
 2244 011e 06F1FF31 		addcc	r1, r6, #-1
 2245 0122 02EB8112 		addcc	r2, r2, r1, lsl #6
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2246              		.loc 1 582 0
 2247 0126 2346     		movcs	r3, r4
 2248 0128 3A46     		movcs	r2, r7
 2249 012a 3146     		mov	r1, r6
 2250 012c FFF7FEFF 		bl	usb_device_endpoint_read_buffer_job
 2251              	.LVL202:
 2252 0130 C5E7     		b	.L201
 2253              	.LVL203:
 2254              	.L191:
 585:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 2255              		.loc 1 585 0
 2256 0132 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 2257 0134 64F30003 		bfi	r3, r4, #0, #1
 2258 0138 CDE7     		b	.L198
 2259              	.L204:
 2260 013a 00BF     		.align	2
 2261              	.L203:
 2262 013c 00000000 		.word	usb_device
 2263 0140 00000000 		.word	udd_ep_out_cache_buffer
 2264              		.cfi_endproc
 2265              	.LFE159:
 2267              		.section	.text.udd_set_address,"ax",%progbits
 2268              		.align	1
 2269              		.global	udd_set_address
 2270              		.syntax unified
 2271              		.thumb
 2272              		.thumb_func
 2273              		.fpu fpv4-sp-d16
 2275              	udd_set_address:
 2276              	.LFB160:
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2277              		.loc 1 594 0
 2278              		.cfi_startproc
 2279              		@ args = 0, pretend = 0, frame = 0
 2280              		@ frame_needed = 0, uses_anonymous_args = 0
 2281              		@ link register save eliminated.
 2282              	.LVL204:
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2283              		.loc 1 594 0
 2284 0000 024B     		ldr	r3, .L206
 2285 0002 1B68     		ldr	r3, [r3]
 2286              	.LVL205:
 2287              	.LBB120:
 2288              	.LBB121:
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2289              		.loc 2 359 0
 2290 0004 40F08000 		orr	r0, r0, #128
 2291              	.LVL206:
 2292 0008 9872     		strb	r0, [r3, #10]
 2293              	.LVL207:
 2294              	.LBE121:
 2295              	.LBE120:
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2296              		.loc 1 594 0
 2297 000a 7047     		bx	lr
 2298              	.L207:
 2299              		.align	2
 2300              	.L206:
 2301 000c 00000000 		.word	usb_device
 2302              		.cfi_endproc
 2303              	.LFE160:
 2305              		.section	.text.udd_getaddress,"ax",%progbits
 2306              		.align	1
 2307              		.global	udd_getaddress
 2308              		.syntax unified
 2309              		.thumb
 2310              		.thumb_func
 2311              		.fpu fpv4-sp-d16
 2313              	udd_getaddress:
 2314              	.LFB161:
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2315              		.loc 1 596 0
 2316              		.cfi_startproc
 2317              		@ args = 0, pretend = 0, frame = 0
 2318              		@ frame_needed = 0, uses_anonymous_args = 0
 2319              		@ link register save eliminated.
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2320              		.loc 1 596 0
 2321 0000 024B     		ldr	r3, .L209
 2322 0002 1B68     		ldr	r3, [r3]
 2323              	.LVL208:
 2324              	.LBB122:
 2325              	.LBB123:
 351:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2326              		.loc 2 351 0
 2327 0004 987A     		ldrb	r0, [r3, #10]	@ zero_extendqisi2
 2328              	.LBE123:
 2329              	.LBE122:
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2330              		.loc 1 596 0
 2331 0006 00F07F00 		and	r0, r0, #127
 2332 000a 7047     		bx	lr
 2333              	.L210:
 2334              		.align	2
 2335              	.L209:
 2336 000c 00000000 		.word	usb_device
 2337              		.cfi_endproc
 2338              	.LFE161:
 2340              		.section	.text.udd_send_remotewakeup,"ax",%progbits
 2341              		.align	1
 2342              		.global	udd_send_remotewakeup
 2343              		.syntax unified
 2344              		.thumb
 2345              		.thumb_func
 2346              		.fpu fpv4-sp-d16
 2348              	udd_send_remotewakeup:
 2349              	.LFB162:
 598:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t try
 2350              		.loc 1 598 0
 2351              		.cfi_startproc
 2352              		@ args = 0, pretend = 0, frame = 0
 2353              		@ frame_needed = 0, uses_anonymous_args = 0
 2354              		@ link register save eliminated.
 2355              	.LVL209:
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2356              		.loc 1 603 0
 2357 0000 064B     		ldr	r3, .L218
 2358 0002 1A68     		ldr	r2, [r3]
 2359 0004 0623     		movs	r3, #6
 2360              	.LVL210:
 2361              	.L212:
 2362              	.LBB124:
 2363              	.LBB125:
 311:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 2364              		.loc 2 311 0
 2365 0006 517B     		ldrb	r1, [r2, #13]	@ zero_extendqisi2
 2366              	.LBE125:
 2367              	.LBE124:
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2368              		.loc 1 603 0
 2369 0008 0229     		cmp	r1, #2
 2370 000a 01D0     		beq	.L211
 2371              	.LVL211:
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2372              		.loc 1 603 0 is_stmt 0 discriminator 1
 2373 000c 013B     		subs	r3, r3, #1
 2374              	.LVL212:
 2375 000e 00D1     		bne	.L214
 2376              	.LVL213:
 2377              	.L211:
 606:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2378              		.loc 1 606 0 is_stmt 1
 2379 0010 7047     		bx	lr
 2380              	.LVL214:
 2381              	.L214:
 2382              	.LBB126:
 2383              	.LBB127:
 376:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 377:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 378:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief USB device send the resume wakeup
 379:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 380:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 381:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 382:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_send_remote_wake_up(struct usb_module *module_inst) { module_inst->hw
 2384              		.loc 2 382 0
 2385 0012 1189     		ldrh	r1, [r2, #8]
 2386 0014 41F00201 		orr	r1, r1, #2
 2387 0018 1181     		strh	r1, [r2, #8]	@ movhi
 2388 001a F4E7     		b	.L212
 2389              	.L219:
 2390              		.align	2
 2391              	.L218:
 2392 001c 00000000 		.word	usb_device
 2393              	.LBE127:
 2394              	.LBE126:
 2395              		.cfi_endproc
 2396              	.LFE162:
 2398              		.section	.text.udd_set_setup_payload,"ax",%progbits
 2399              		.align	1
 2400              		.global	udd_set_setup_payload
 2401              		.syntax unified
 2402              		.thumb
 2403              		.thumb_func
 2404              		.fpu fpv4-sp-d16
 2406              	udd_set_setup_payload:
 2407              	.LFB163:
 608:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload      = payload;
 2408              		.loc 1 608 0
 2409              		.cfi_startproc
 2410              		@ args = 0, pretend = 0, frame = 0
 2411              		@ frame_needed = 0, uses_anonymous_args = 0
 2412              		@ link register save eliminated.
 2413              	.LVL215:
 609:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload_size = payload_size;
 2414              		.loc 1 609 0
 2415 0000 014B     		ldr	r3, .L221
 2416 0002 9860     		str	r0, [r3, #8]
 610:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2417              		.loc 1 610 0
 2418 0004 9981     		strh	r1, [r3, #12]	@ movhi
 611:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2419              		.loc 1 611 0
 2420 0006 7047     		bx	lr
 2421              	.L222:
 2422              		.align	2
 2423              	.L221:
 2424 0008 00000000 		.word	udd_g_ctrlreq
 2425              		.cfi_endproc
 2426              	.LFE163:
 2428              		.section	.text.udd_detach,"ax",%progbits
 2429              		.align	1
 2430              		.global	udd_detach
 2431              		.syntax unified
 2432              		.thumb
 2433              		.thumb_func
 2434              		.fpu fpv4-sp-d16
 2436              	udd_detach:
 2437              	.LFB178:
 973:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 974:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_detach(void) {
 2438              		.loc 1 974 0
 2439              		.cfi_startproc
 2440              		@ args = 0, pretend = 0, frame = 0
 2441              		@ frame_needed = 0, uses_anonymous_args = 0
 2442              		@ link register save eliminated.
 975:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_detach(&usb_device);
 2443              		.loc 1 975 0
 2444 0000 034B     		ldr	r3, .L224
 2445 0002 1A68     		ldr	r2, [r3]
 2446              	.LVL216:
 2447              	.LBB128:
 2448              	.LBB129:
 329:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2449              		.loc 2 329 0
 2450 0004 1389     		ldrh	r3, [r2, #8]
 2451 0006 43F00103 		orr	r3, r3, #1
 2452 000a 1381     		strh	r3, [r2, #8]	@ movhi
 2453              	.LBE129:
 2454              	.LBE128:
 976:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 977:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2455              		.loc 1 977 0
 2456 000c 7047     		bx	lr
 2457              	.L225:
 2458 000e 00BF     		.align	2
 2459              	.L224:
 2460 0010 00000000 		.word	usb_device
 2461              		.cfi_endproc
 2462              	.LFE178:
 2464              		.section	.text.udd_attach,"ax",%progbits
 2465              		.align	1
 2466              		.global	udd_attach
 2467              		.syntax unified
 2468              		.thumb
 2469              		.thumb_func
 2470              		.fpu fpv4-sp-d16
 2472              	udd_attach:
 2473              	.LFB179:
 978:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 979:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_attach(void) {
 2474              		.loc 1 979 0
 2475              		.cfi_startproc
 2476              		@ args = 0, pretend = 0, frame = 0
 2477              		@ frame_needed = 0, uses_anonymous_args = 0
 2478 0000 10B5     		push	{r4, lr}
 2479              		.cfi_def_cfa_offset 8
 2480              		.cfi_offset 4, -8
 2481              		.cfi_offset 14, -4
 980:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 981:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_attach(&usb_device);
 2482              		.loc 1 981 0
 2483 0002 174C     		ldr	r4, .L227
 2484 0004 2268     		ldr	r2, [r4]
 2485              	.LVL217:
 2486              	.LBB130:
 2487              	.LBB131:
 322:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2488              		.loc 2 322 0
 2489 0006 1389     		ldrh	r3, [r2, #8]
 2490 0008 23F00103 		bic	r3, r3, #1
 2491 000c 1B04     		lsls	r3, r3, #16
 2492 000e 1B0C     		lsrs	r3, r3, #16
 2493 0010 1381     		strh	r3, [r2, #8]	@ movhi
 2494              	.LBE131:
 2495              	.LBE130:
 982:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 983:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND, _usb_on_suspend);
 2496              		.loc 1 983 0
 2497 0012 0421     		movs	r1, #4
 2498 0014 134A     		ldr	r2, .L227+4
 2499 0016 2046     		mov	r0, r4
 2500 0018 FFF7FEFF 		bl	usb_device_register_callback
 2501              	.LVL218:
 984:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_SOF, _usb_on_sof_notify);
 2502              		.loc 1 984 0
 2503 001c 124A     		ldr	r2, .L227+8
 2504 001e 0021     		movs	r1, #0
 2505 0020 2046     		mov	r0, r4
 2506 0022 FFF7FEFF 		bl	usb_device_register_callback
 2507              	.LVL219:
 985:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_RESET, _usb_on_bus_reset);
 2508              		.loc 1 985 0
 2509 0026 114A     		ldr	r2, .L227+12
 2510 0028 0121     		movs	r1, #1
 2511 002a 2046     		mov	r0, r4
 2512 002c FFF7FEFF 		bl	usb_device_register_callback
 2513              	.LVL220:
 986:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP, _usb_on_wakeup);
 2514              		.loc 1 986 0
 2515 0030 0F4A     		ldr	r2, .L227+16
 2516 0032 0221     		movs	r1, #2
 2517 0034 2046     		mov	r0, r4
 2518 0036 FFF7FEFF 		bl	usb_device_register_callback
 2519              	.LVL221:
 987:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 988:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 2520              		.loc 1 988 0
 2521 003a 0421     		movs	r1, #4
 2522 003c 2046     		mov	r0, r4
 2523 003e FFF7FEFF 		bl	usb_device_enable_callback
 2524              	.LVL222:
 989:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SOF);
 2525              		.loc 1 989 0
 2526 0042 0021     		movs	r1, #0
 2527 0044 2046     		mov	r0, r4
 2528 0046 FFF7FEFF 		bl	usb_device_enable_callback
 2529              	.LVL223:
 990:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_RESET);
 2530              		.loc 1 990 0
 2531 004a 0121     		movs	r1, #1
 2532 004c 2046     		mov	r0, r4
 2533 004e FFF7FEFF 		bl	usb_device_enable_callback
 2534              	.LVL224:
 991:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 2535              		.loc 1 991 0
 2536 0052 2046     		mov	r0, r4
 2537 0054 0221     		movs	r1, #2
 992:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 993:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP, _usb_device_lpm_suspend)
 994:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
 995:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 996:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2538              		.loc 1 996 0
 2539 0056 BDE81040 		pop	{r4, lr}
 2540              		.cfi_restore 14
 2541              		.cfi_restore 4
 2542              		.cfi_def_cfa_offset 0
 991:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 2543              		.loc 1 991 0
 2544 005a FFF7FEBF 		b	usb_device_enable_callback
 2545              	.LVL225:
 2546              	.L228:
 2547 005e 00BF     		.align	2
 2548              	.L227:
 2549 0060 00000000 		.word	usb_device
 2550 0064 00000000 		.word	_usb_on_suspend
 2551 0068 00000000 		.word	_usb_on_sof_notify
 2552 006c 00000000 		.word	_usb_on_bus_reset
 2553 0070 00000000 		.word	_usb_on_wakeup
 2554              		.cfi_endproc
 2555              	.LFE179:
 2557              		.section	.text.udd_enable,"ax",%progbits
 2558              		.align	1
 2559              		.global	udd_enable
 2560              		.syntax unified
 2561              		.thumb
 2562              		.thumb_func
 2563              		.fpu fpv4-sp-d16
 2565              	udd_enable:
 2566              	.LFB180:
 997:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 998:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_enable(void) {
 2567              		.loc 1 998 0
 2568              		.cfi_startproc
 2569              		@ args = 0, pretend = 0, frame = 8
 2570              		@ frame_needed = 0, uses_anonymous_args = 0
 2571 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 2572              		.cfi_def_cfa_offset 24
 2573              		.cfi_offset 4, -12
 2574              		.cfi_offset 5, -8
 2575              		.cfi_offset 14, -4
 2576              	.LBB132:
 2577              	.LBB133:
 313:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 2578              		.loc 3 313 0
 2579              		.syntax unified
 2580              	@ 313 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2581 0002 EFF31085 		MRS r5, primask
 2582              	@ 0 "" 2
 2583              		.thumb
 2584              		.syntax unified
 2585              	.LBE133:
 2586              	.LBE132:
 2587              	.LBB134:
 2588              	.LBB135:
  96:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2589              		.loc 3 96 0
 2590              		.syntax unified
 2591              	@ 96 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2592 0006 72B6     		cpsid i
 2593              	@ 0 "" 2
 2594              		.thumb
 2595              		.syntax unified
 2596              	.LBE135:
 2597              	.LBE134:
 2598              	.LBB136:
 2599              	.LBB137:
 2600              		.loc 3 764 0
 2601              		.syntax unified
 2602              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2603 0008 BFF35F8F 		dmb 0xF
 2604              	@ 0 "" 2
 2605              		.thumb
 2606              		.syntax unified
 2607              	.LBE137:
 2608              	.LBE136:
 999:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t irqflags;
1000:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1001:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* To avoid USB interrupt before end of initialization */
1002:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     irqflags = __get_PRIMASK();
1003:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __disable_irq();
1004:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
1005:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1006:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_config config_usb;
1007:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1008:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Module configuration */
1009:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_get_config_defaults(&config_usb);
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
1011:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_init(&usb_device, USB, &config_usb);
 2609              		.loc 1 1011 0
 2610 000c 0B4C     		ldr	r4, .L230
1009:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
 2611              		.loc 1 1009 0
 2612 000e 01A8     		add	r0, sp, #4
 2613 0010 FFF7FEFF 		bl	usb_get_config_defaults
 2614              	.LVL226:
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_init(&usb_device, USB, &config_usb);
 2615              		.loc 1 1010 0
 2616 0014 0023     		movs	r3, #0
 2617              		.loc 1 1011 0
 2618 0016 01AA     		add	r2, sp, #4
 2619 0018 4FF08241 		mov	r1, #1090519040
 2620 001c 2046     		mov	r0, r4
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_init(&usb_device, USB, &config_usb);
 2621              		.loc 1 1010 0
 2622 001e 8DF80630 		strb	r3, [sp, #6]
 2623              		.loc 1 1011 0
 2624 0022 FFF7FEFF 		bl	usb_init
 2625              	.LVL227:
1012:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1013:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Module Enable */
1014:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_enable(&usb_device);
 2626              		.loc 1 1014 0
 2627 0026 2046     		mov	r0, r4
 2628 0028 FFF7FEFF 		bl	usb_enable
 2629              	.LVL228:
1015:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1016:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Check clock after enable module, request the clock */
1017:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
1018:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1019:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
1020:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1021:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // No VBus detect, assume always high
1022:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
1023:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_attach();
 2630              		.loc 1 1023 0
 2631 002c FFF7FEFF 		bl	udd_attach
 2632              	.LVL229:
 2633              	.LBB138:
 2634              	.LBB139:
 2635              		.loc 3 764 0
 2636              		.syntax unified
 2637              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2638 0030 BFF35F8F 		dmb 0xF
 2639              	@ 0 "" 2
 2640              		.thumb
 2641              		.syntax unified
 2642              	.LBE139:
 2643              	.LBE138:
 2644              	.LBB140:
 2645              	.LBB141:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2646              		.loc 3 341 0
 2647              		.syntax unified
 2648              	@ 341 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2649 0034 85F31088 		MSR primask, r5
 2650              	@ 0 "" 2
 2651              		.thumb
 2652              		.syntax unified
 2653              	.LBE141:
 2654              	.LBE140:
1024:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
1025:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1026:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
1027:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __set_PRIMASK(irqflags);
1028:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2655              		.loc 1 1028 0
 2656 0038 03B0     		add	sp, sp, #12
 2657              		.cfi_def_cfa_offset 12
 2658              		@ sp needed
 2659 003a 30BD     		pop	{r4, r5, pc}
 2660              	.L231:
 2661              		.align	2
 2662              	.L230:
 2663 003c 00000000 		.word	usb_device
 2664              		.cfi_endproc
 2665              	.LFE180:
 2667              		.section	.text.udd_disable,"ax",%progbits
 2668              		.align	1
 2669              		.global	udd_disable
 2670              		.syntax unified
 2671              		.thumb
 2672              		.thumb_func
 2673              		.fpu fpv4-sp-d16
 2675              	udd_disable:
 2676              	.LFB181:
1029:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1030:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_disable(void) {
 2677              		.loc 1 1030 0
 2678              		.cfi_startproc
 2679              		@ args = 0, pretend = 0, frame = 0
 2680              		@ frame_needed = 0, uses_anonymous_args = 0
 2681              		@ link register save eliminated.
1031:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_detach();
 2682              		.loc 1 1031 0
 2683 0000 FFF7FEBF 		b	udd_detach
 2684              	.LVL230:
 2685              		.cfi_endproc
 2686              	.LFE181:
 2688              		.comm	udd_ep_out_cache_buffer,256,4
 2689              		.comm	udd_g_ctrlreq,24,4
 2690              		.comm	udd_ctrl_buffer,8,4
 2691              		.comm	usb_device,180,4
 2692              		.bss
 2693              		.align	2
 2694              		.set	.LANCHOR0,. + 0
 2697              	udd_ep_job:
 2698 0000 00000000 		.space	160
 2698      00000000 
 2698      00000000 
 2698      00000000 
 2698      00000000 
 2701              	udd_ep_control_state:
 2702 00a0 00       		.space	1
 2703 00a1 00       		.space	1
 2706              	udd_ctrl_payload_nb_trans:
 2707 00a2 0000     		.space	2
 2710              	udd_ctrl_prev_payload_nb_trans:
 2711 00a4 0000     		.space	2
 2714              	b_shortpacket.19032:
 2715 00a6 00       		.space	1
 2716              		.text
 2717              	.Letext0:
 2718              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 2719              		.file 5 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 2720              		.file 6 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/samd51j18a.h"
 2721              		.file 7 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/core_cm4.h"
 2722              		.file 8 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/system_samd51.h"
 2723              		.file 9 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/component/usb.h"
 2724              		.file 10 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 2725              		.file 11 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 2726              		.file 12 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.
 2727              		.file 13 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 2728              		.file 14 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 2729              		.file 15 "tmk_core/protocol/arm_atsam/usb/compiler.h"
 2730              		.file 16 "tmk_core/protocol/arm_atsam/usb/usb_protocol.h"
 2731              		.file 17 "tmk_core/protocol/arm_atsam/usb/udi_device_conf.h"
 2732              		.file 18 "tmk_core/protocol/arm_atsam/usb/udi.h"
 2733              		.file 19 "tmk_core/protocol/arm_atsam/usb/udc_desc.h"
 2734              		.file 20 "tmk_core/protocol/arm_atsam/usb/udi_hid_kbd.h"
 2735              		.file 21 "tmk_core/protocol/arm_atsam/usb/usb_main.h"
 2736              		.file 22 "tmk_core/protocol/arm_atsam/usb/udd.h"
 2737              		.file 23 "tmk_core/protocol/arm_atsam/usb/status_codes.h"
 2738              		.file 24 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_device_udd.c
/var/tmp//cchdQXAB.s:18     .text.udd_ep_get_job:0000000000000000 $t
/var/tmp//cchdQXAB.s:24     .text.udd_ep_get_job:0000000000000000 udd_ep_get_job
/var/tmp//cchdQXAB.s:53     .text.udd_ep_get_job:0000000000000020 $d
/var/tmp//cchdQXAB.s:58     .text.udd_ep_transfer_process:0000000000000000 $t
/var/tmp//cchdQXAB.s:64     .text.udd_ep_transfer_process:0000000000000000 udd_ep_transfer_process
/var/tmp//cchdQXAB.s:344    .text.udd_ep_transfer_process:0000000000000138 $d
                            *COM*:00000000000000b4 usb_device
                            *COM*:0000000000000100 udd_ep_out_cache_buffer
/var/tmp//cchdQXAB.s:350    .text.udd_ctrl_stall_data:0000000000000000 $t
/var/tmp//cchdQXAB.s:356    .text.udd_ctrl_stall_data:0000000000000000 udd_ctrl_stall_data
/var/tmp//cchdQXAB.s:395    .text.udd_ctrl_stall_data:0000000000000020 $d
/var/tmp//cchdQXAB.s:401    .text._usb_on_wakeup:0000000000000000 $t
/var/tmp//cchdQXAB.s:407    .text._usb_on_wakeup:0000000000000000 _usb_on_wakeup
/var/tmp//cchdQXAB.s:442    .text._usb_on_wakeup:000000000000001c $d
/var/tmp//cchdQXAB.s:447    .text._usb_on_bus_reset:0000000000000000 $t
/var/tmp//cchdQXAB.s:453    .text._usb_on_bus_reset:0000000000000000 _usb_on_bus_reset
/var/tmp//cchdQXAB.s:558    .text._usb_on_bus_reset:0000000000000078 $d
                            *COM*:0000000000000008 udd_ctrl_buffer
/var/tmp//cchdQXAB.s:824    .text._usb_ep0_on_setup:0000000000000000 _usb_ep0_on_setup
/var/tmp//cchdQXAB.s:1583   .text._usb_ep0_on_tansfer_ok:0000000000000000 _usb_ep0_on_tansfer_ok
/var/tmp//cchdQXAB.s:629    .text._usb_ep0_on_tansfer_fail:0000000000000000 _usb_ep0_on_tansfer_fail
/var/tmp//cchdQXAB.s:567    .text.udd_ctrl_send_zlp_in:0000000000000000 $t
/var/tmp//cchdQXAB.s:573    .text.udd_ctrl_send_zlp_in:0000000000000000 udd_ctrl_send_zlp_in
/var/tmp//cchdQXAB.s:615    .text.udd_ctrl_send_zlp_in:0000000000000028 $d
                            *COM*:0000000000000018 udd_g_ctrlreq
/var/tmp//cchdQXAB.s:623    .text._usb_ep0_on_tansfer_fail:0000000000000000 $t
/var/tmp//cchdQXAB.s:690    .text._usb_ep0_on_tansfer_fail:0000000000000030 $d
/var/tmp//cchdQXAB.s:696    .text.udd_ctrl_in_sent:0000000000000000 $t
/var/tmp//cchdQXAB.s:702    .text.udd_ctrl_in_sent:0000000000000000 udd_ctrl_in_sent
/var/tmp//cchdQXAB.s:810    .text.udd_ctrl_in_sent:000000000000007c $d
/var/tmp//cchdQXAB.s:818    .text._usb_ep0_on_setup:0000000000000000 $t
/var/tmp//cchdQXAB.s:997    .text._usb_ep0_on_setup:00000000000000b0 $d
/var/tmp//cchdQXAB.s:1005   .text._usb_on_sof_notify:0000000000000000 $t
/var/tmp//cchdQXAB.s:1011   .text._usb_on_sof_notify:0000000000000000 _usb_on_sof_notify
/var/tmp//cchdQXAB.s:1037   .text._usb_on_suspend:0000000000000000 $t
/var/tmp//cchdQXAB.s:1043   .text._usb_on_suspend:0000000000000000 _usb_on_suspend
/var/tmp//cchdQXAB.s:1078   .text._usb_on_suspend:000000000000001c $d
/var/tmp//cchdQXAB.s:1083   .text.udd_ep_abort:0000000000000000 $t
/var/tmp//cchdQXAB.s:1090   .text.udd_ep_abort:0000000000000000 udd_ep_abort
/var/tmp//cchdQXAB.s:1145   .text.udd_ep_abort:0000000000000030 $d
/var/tmp//cchdQXAB.s:1150   .text.udd_is_high_speed:0000000000000000 $t
/var/tmp//cchdQXAB.s:1157   .text.udd_is_high_speed:0000000000000000 udd_is_high_speed
/var/tmp//cchdQXAB.s:1171   .text.udd_get_frame_number:0000000000000000 $t
/var/tmp//cchdQXAB.s:1178   .text.udd_get_frame_number:0000000000000000 udd_get_frame_number
/var/tmp//cchdQXAB.s:1201   .text.udd_get_frame_number:000000000000000c $d
/var/tmp//cchdQXAB.s:1206   .text.udd_get_micro_frame_number:0000000000000000 $t
/var/tmp//cchdQXAB.s:1213   .text.udd_get_micro_frame_number:0000000000000000 udd_get_micro_frame_number
/var/tmp//cchdQXAB.s:1235   .text.udd_get_micro_frame_number:0000000000000008 $d
/var/tmp//cchdQXAB.s:1240   .text.udd_ep_free:0000000000000000 $t
/var/tmp//cchdQXAB.s:1247   .text.udd_ep_free:0000000000000000 udd_ep_free
/var/tmp//cchdQXAB.s:1306   .text.udd_ep_free:0000000000000040 $d
/var/tmp//cchdQXAB.s:1311   .text.udd_ep_alloc:0000000000000000 $t
/var/tmp//cchdQXAB.s:1318   .text.udd_ep_alloc:0000000000000000 udd_ep_alloc
/var/tmp//cchdQXAB.s:1487   .text.udd_ep_alloc:00000000000000b8 $d
/var/tmp//cchdQXAB.s:1493   .text.udd_ep_is_halted:0000000000000000 $t
/var/tmp//cchdQXAB.s:1500   .text.udd_ep_is_halted:0000000000000000 udd_ep_is_halted
/var/tmp//cchdQXAB.s:1517   .text.udd_ep_is_halted:0000000000000008 $d
/var/tmp//cchdQXAB.s:1522   .text.udd_ep_set_halt:0000000000000000 $t
/var/tmp//cchdQXAB.s:1529   .text.udd_ep_set_halt:0000000000000000 udd_ep_set_halt
/var/tmp//cchdQXAB.s:1572   .text.udd_ep_set_halt:0000000000000024 $d
/var/tmp//cchdQXAB.s:1577   .text._usb_ep0_on_tansfer_ok:0000000000000000 $t
/var/tmp//cchdQXAB.s:1789   .text._usb_ep0_on_tansfer_ok:00000000000000bc $d
/var/tmp//cchdQXAB.s:1797   .text.udd_ep_clear_halt:0000000000000000 $t
/var/tmp//cchdQXAB.s:1804   .text.udd_ep_clear_halt:0000000000000000 udd_ep_clear_halt
/var/tmp//cchdQXAB.s:1859   .text.udd_ep_clear_halt:0000000000000030 $d
/var/tmp//cchdQXAB.s:1864   .text.udd_ep_wait_stall_clear:0000000000000000 $t
/var/tmp//cchdQXAB.s:1871   .text.udd_ep_wait_stall_clear:0000000000000000 udd_ep_wait_stall_clear
/var/tmp//cchdQXAB.s:1950   .text.udd_ep_wait_stall_clear:000000000000004c $d
/var/tmp//cchdQXAB.s:1955   .text.udd_ep_run:0000000000000000 $t
/var/tmp//cchdQXAB.s:1962   .text.udd_ep_run:0000000000000000 udd_ep_run
/var/tmp//cchdQXAB.s:2262   .text.udd_ep_run:000000000000013c $d
/var/tmp//cchdQXAB.s:2268   .text.udd_set_address:0000000000000000 $t
/var/tmp//cchdQXAB.s:2275   .text.udd_set_address:0000000000000000 udd_set_address
/var/tmp//cchdQXAB.s:2301   .text.udd_set_address:000000000000000c $d
/var/tmp//cchdQXAB.s:2306   .text.udd_getaddress:0000000000000000 $t
/var/tmp//cchdQXAB.s:2313   .text.udd_getaddress:0000000000000000 udd_getaddress
/var/tmp//cchdQXAB.s:2336   .text.udd_getaddress:000000000000000c $d
/var/tmp//cchdQXAB.s:2341   .text.udd_send_remotewakeup:0000000000000000 $t
/var/tmp//cchdQXAB.s:2348   .text.udd_send_remotewakeup:0000000000000000 udd_send_remotewakeup
/var/tmp//cchdQXAB.s:2392   .text.udd_send_remotewakeup:000000000000001c $d
/var/tmp//cchdQXAB.s:2399   .text.udd_set_setup_payload:0000000000000000 $t
/var/tmp//cchdQXAB.s:2406   .text.udd_set_setup_payload:0000000000000000 udd_set_setup_payload
/var/tmp//cchdQXAB.s:2424   .text.udd_set_setup_payload:0000000000000008 $d
/var/tmp//cchdQXAB.s:2429   .text.udd_detach:0000000000000000 $t
/var/tmp//cchdQXAB.s:2436   .text.udd_detach:0000000000000000 udd_detach
/var/tmp//cchdQXAB.s:2460   .text.udd_detach:0000000000000010 $d
/var/tmp//cchdQXAB.s:2465   .text.udd_attach:0000000000000000 $t
/var/tmp//cchdQXAB.s:2472   .text.udd_attach:0000000000000000 udd_attach
/var/tmp//cchdQXAB.s:2549   .text.udd_attach:0000000000000060 $d
/var/tmp//cchdQXAB.s:2558   .text.udd_enable:0000000000000000 $t
/var/tmp//cchdQXAB.s:2565   .text.udd_enable:0000000000000000 udd_enable
/var/tmp//cchdQXAB.s:2663   .text.udd_enable:000000000000003c $d
/var/tmp//cchdQXAB.s:2668   .text.udd_disable:0000000000000000 $t
/var/tmp//cchdQXAB.s:2675   .text.udd_disable:0000000000000000 udd_disable
/var/tmp//cchdQXAB.s:2693   .bss:0000000000000000 $d
/var/tmp//cchdQXAB.s:2697   .bss:0000000000000000 udd_ep_job
/var/tmp//cchdQXAB.s:2701   .bss:00000000000000a0 udd_ep_control_state
/var/tmp//cchdQXAB.s:2706   .bss:00000000000000a2 udd_ctrl_payload_nb_trans
/var/tmp//cchdQXAB.s:2710   .bss:00000000000000a4 udd_ctrl_prev_payload_nb_trans
/var/tmp//cchdQXAB.s:2714   .bss:00000000000000a6 b_shortpacket.19032

UNDEFINED SYMBOLS
usb_device_endpoint_write_buffer_job
memcpy
usb_device_endpoint_read_buffer_job
usb_device_endpoint_set_halt
usb_device_endpoint_clear_halt
usb_device_disable_callback
usb_device_enable_callback
main_resume_action
udc_reset
usb_device_endpoint_get_config_defaults
usb_device_endpoint_set_config
usb_device_endpoint_setup_buffer_job
usb_device_endpoint_register_callback
usb_device_endpoint_enable_callback
udc_process_setup
udc_sof_notify
main_sof_action
main_suspend_action
usb_device_endpoint_abort_job
usb_device_endpoint_unregister_callback
usb_device_endpoint_disable_callback
usb_device_endpoint_is_halted
usb_device_endpoint_is_configured
usb_device_register_callback
usb_get_config_defaults
usb_init
usb_enable

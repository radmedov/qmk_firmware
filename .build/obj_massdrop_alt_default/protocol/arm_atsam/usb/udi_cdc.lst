   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"udi_cdc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.CDC_send,"ax",%progbits
  18              		.align	1
  19              		.global	CDC_send
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	CDC_send:
  26              	.LFB137:
  27              		.file 1 "tmk_core/protocol/arm_atsam/usb/udi_cdc.c"
   1:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
   2:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \file
   3:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
   4:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief USB Device Communication Device Class (CDC) interface.
   5:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
   6:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
   7:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
   8:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \asf_license_start
   9:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  10:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \page License
  11:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  12:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Redistribution and use in source and binary forms, with or without
  13:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * modification, are permitted provided that the following conditions are met:
  14:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  15:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *    this list of conditions and the following disclaimer.
  17:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  18:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *    and/or other materials provided with the distribution.
  21:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  22:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *    from this software without specific prior written permission.
  24:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  25:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * 4. This software may only be redistributed and used in connection with an
  26:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *    Atmel microcontroller product.
  27:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  28:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * POSSIBILITY OF SUCH DAMAGE.
  39:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  40:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \asf_license_stop
  41:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  42:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
  43:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /*
  44:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
  45:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
  46:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
  47:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "samd51j18a.h"
  48:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "conf_usb.h"
  49:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "usb_protocol.h"
  50:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "usb_protocol_cdc.h"
  51:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "udd.h"
  52:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "udc.h"
  53:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "udi_cdc.h"
  54:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include <string.h>
  55:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "udi_cdc_conf.h"
  56:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "udi_device_conf.h"
  57:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "stdarg.h"
  58:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #include "tmk_core/protocol/arm_atsam/clks.h"
  59:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
  60:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #ifdef CDC
  61:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
  62:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    ifdef UDI_CDC_LOW_RATE
  63:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        ifdef USB_DEVICE_HS_SUPPORT
  64:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_TX_BUFFERS (UDI_CDC_DATA_EPS_HS_SIZE)
  65:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_RX_BUFFERS (UDI_CDC_DATA_EPS_HS_SIZE)
  66:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        else
  67:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_TX_BUFFERS (UDI_CDC_DATA_EPS_FS_SIZE)
  68:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_RX_BUFFERS (UDI_CDC_DATA_EPS_FS_SIZE)
  69:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        endif
  70:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    else
  71:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        ifdef USB_DEVICE_HS_SUPPORT
  72:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_TX_BUFFERS (UDI_CDC_DATA_EPS_HS_SIZE)
  73:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_RX_BUFFERS (UDI_CDC_DATA_EPS_HS_SIZE)
  74:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        else
  75:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_TX_BUFFERS (5 * UDI_CDC_DATA_EPS_FS_SIZE)
  76:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #            define UDI_CDC_RX_BUFFERS (5 * UDI_CDC_DATA_EPS_FS_SIZE)
  77:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        endif
  78:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    endif
  79:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
  80:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    ifndef UDI_CDC_TX_EMPTY_NOTIFY
  81:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #        define UDI_CDC_TX_EMPTY_NOTIFY(port)
  82:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    endif
  83:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
  84:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
  85:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \ingroup udi_cdc_group
  86:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \defgroup udi_cdc_group_udc Interface with USB Device Core (UDC)
  87:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  88:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Structures and functions required by UDC.
  89:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
  90:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * @{
  91:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
  92:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool             udi_cdc_comm_enable(void);
  93:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void             udi_cdc_comm_disable(void);
  94:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool             udi_cdc_comm_setup(void);
  95:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool             udi_cdc_data_enable(void);
  96:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void             udi_cdc_data_disable(void);
  97:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool             udi_cdc_data_setup(void);
  98:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint8_t          udi_cdc_getsetting(void);
  99:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void             udi_cdc_data_sof_notify(void);
 100:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** UDC_DESC_STORAGE udi_api_t udi_api_cdc_comm = {.enable = udi_cdc_comm_enable, .disable = udi_cdc_co
 101:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** UDC_DESC_STORAGE udi_api_t udi_api_cdc_data = {
 102:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     .enable     = udi_cdc_data_enable,
 103:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     .disable    = udi_cdc_data_disable,
 104:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     .setup      = udi_cdc_data_setup,
 105:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     .getsetting = udi_cdc_getsetting,
 106:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     .sof_notify = udi_cdc_data_sof_notify,
 107:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** };
 108:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@}
 109:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 110:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 111:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \ingroup udi_cdc_group
 112:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \defgroup udi_cdc_group_internal Implementation of UDI CDC
 113:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 114:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Class internal implementation
 115:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * @{
 116:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 117:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 118:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 119:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \name Internal routines
 120:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 121:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@{
 122:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 123:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 124:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \name Routines to control serial line
 125:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 126:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@{
 127:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 128:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 129:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Returns the port number corresponding at current setup request
 130:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 131:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \return port number
 132:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 133:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static uint8_t udi_cdc_setup_to_port(void);
 134:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 135:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 136:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Sends line coding to application
 137:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 138:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Called after SETUP request when line coding data is received.
 139:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 140:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_line_coding_received(void);
 141:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 142:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 143:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Records new state
 144:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 145:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param port       Communication port number to manage
 146:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param b_set      State is enabled if true, else disabled
 147:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param bit_mask   Field to process (see CDC_SERIAL_STATE_ defines)
 148:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 149:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_ctrl_state_change(uint8_t port, bool b_set, le16_t bit_mask);
 150:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 151:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 152:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Check and eventually notify the USB host of new state
 153:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 154:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param port       Communication port number to manage
 155:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param ep         Port communication endpoint
 156:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 157:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_ctrl_state_notify(uint8_t port, udd_ep_id_t ep);
 158:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 159:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 160:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Ack sent of serial state message
 161:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Callback called after serial state message sent
 162:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 163:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param status     UDD_EP_TRANSFER_OK, if transfer finished
 164:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
 165:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param n          number of data transfered
 166:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 167:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_serial_state_msg_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep);
 168:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 169:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@}
 170:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 171:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 172:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \name Routines to process data transfer
 173:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 174:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@{
 175:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 176:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 177:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Enable the reception of data from the USB host
 178:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 179:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * The value udi_cdc_rx_trans_sel indicate the RX buffer to fill.
 180:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 181:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param port       Communication port number to manage
 182:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 183:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \return \c 1 if function was successfully done, otherwise \c 0.
 184:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 185:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static bool udi_cdc_rx_start(uint8_t port);
 186:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 187:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 188:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Update rx buffer management with a new data
 189:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Callback called after data reception on USB line
 190:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 191:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param status     UDD_EP_TRANSFER_OK, if transfer finish
 192:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
 193:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param n          number of data received
 194:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 195:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep);
 196:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 197:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 198:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Ack sent of tx buffer
 199:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Callback called after data transfer on USB line
 200:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 201:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param status     UDD_EP_TRANSFER_OK, if transfer finished
 202:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param status     UDD_EP_TRANSFER_ABORT, if transfer aborted
 203:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param n          number of data transfered
 204:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 205:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep);
 206:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 207:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 208:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \brief Send buffer on line or wait a SOF event
 209:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  *
 210:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \param port       Communication port number to manage
 211:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 212:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_tx_send(uint8_t port);
 213:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 214:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@}
 215:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 216:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@}
 217:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 218:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 219:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \name Information about configuration of communication line
 220:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 221:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@{
 222:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** COMPILER_WORD_ALIGNED
 223:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static usb_cdc_line_coding_t                               udi_cdc_line_coding[UDI_CDC_PORT_NB];
 224:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static bool                                                udi_cdc_serial_state_msg_ongoing[UDI_CDC
 225:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile le16_t                                     udi_cdc_state[UDI_CDC_PORT_NB];
 226:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** COMPILER_WORD_ALIGNED static usb_cdc_notify_serial_state_t uid_cdc_state_msg[UDI_CDC_PORT_NB];
 227:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 228:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Status of CDC COMM interfaces
 229:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile uint8_t udi_cdc_nb_comm_enabled = 0;
 230:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@}
 231:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 232:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** /**
 233:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * \name Variables to manage RX/TX transfer requests
 234:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  * Two buffers for each sense are used to optimize the speed.
 235:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****  */
 236:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@{
 237:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 238:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Status of CDC DATA interfaces
 239:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile uint8_t udi_cdc_nb_data_enabled = 0;
 240:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile bool    udi_cdc_data_running    = false;
 241:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Buffer to receive data
 242:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** COMPILER_WORD_ALIGNED static uint8_t udi_cdc_rx_buf[UDI_CDC_PORT_NB][2][UDI_CDC_RX_BUFFERS];
 243:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Data available in RX buffers
 244:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile uint16_t udi_cdc_rx_buf_nb[UDI_CDC_PORT_NB][2];
 245:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Give the current RX buffer used (rx0 if 0, rx1 if 1)
 246:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile uint8_t udi_cdc_rx_buf_sel[UDI_CDC_PORT_NB];
 247:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Read position in current RX buffer
 248:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile uint16_t udi_cdc_rx_pos[UDI_CDC_PORT_NB];
 249:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Signal a transfer on-going
 250:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile bool udi_cdc_rx_trans_ongoing[UDI_CDC_PORT_NB];
 251:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 252:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Define a transfer halted
 253:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    define UDI_CDC_TRANS_HALTED 2
 254:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 255:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Buffer to send data
 256:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** COMPILER_WORD_ALIGNED static uint8_t udi_cdc_tx_buf[UDI_CDC_PORT_NB][2][UDI_CDC_TX_BUFFERS];
 257:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Data available in TX buffers
 258:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static uint16_t udi_cdc_tx_buf_nb[UDI_CDC_PORT_NB][2];
 259:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Give current TX buffer used (tx0 if 0, tx1 if 1)
 260:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile uint8_t udi_cdc_tx_buf_sel[UDI_CDC_PORT_NB];
 261:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Value of SOF during last TX transfer
 262:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static uint16_t udi_cdc_tx_sof_num[UDI_CDC_PORT_NB];
 263:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Signal a transfer on-going
 264:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile bool udi_cdc_tx_trans_ongoing[UDI_CDC_PORT_NB];
 265:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //! Signal that both buffer content data to send
 266:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];
 267:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 268:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //@}
 269:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 270:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_comm_enable(void) {
 271:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port;
 272:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t iface_comm_num;
 273:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 274:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 275:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port                    = 0;
 276:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_nb_comm_enabled = 0;
 277:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#else
 278:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //    if (udi_cdc_nb_comm_enabled > UDI_CDC_PORT_NB) {
 279:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //        udi_cdc_nb_comm_enabled = 0;
 280:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //    }
 281:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //    port = udi_cdc_nb_comm_enabled;
 282:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 283:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 284:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Initialize control signal management
 285:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_state[port] = CPU_TO_LE16(0);
 286:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 287:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].header.bmRequestType = USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS | USB_REQ_RE
 288:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
 289:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].header.wValue        = LE16(0);
 290:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 291:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 292:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (port) {
 293:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     #define UDI_CDC_PORT_TO_IFACE_COMM(index, unused) \
 294:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         case index: \
 295:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_##index; \
 296:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             break;
 297:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_IFACE_COMM, ~)
 298:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     #undef UDI_CDC_PORT_TO_IFACE_COMM
 299:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         default:
 300:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
 301:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             break;
 302:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 303:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 304:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
 305:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 306:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].header.wIndex  = LE16(iface_comm_num);
 307:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].header.wLength = LE16(2);
 308:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].value          = CPU_TO_LE16(0);
 309:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 310:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_line_coding[port].dwDTERate   = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
 311:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
 312:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
 313:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_line_coding[port].bDataBits   = UDI_CDC_DEFAULT_DATABITS;
 314:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Call application callback
 315:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // to initialize memories or indicate that interface is enabled
 316:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    if 0
 317:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
 318:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!UDI_CDC_ENABLE_EXT(port)) {
 319:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return false;
 320:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 321:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    endif
 322:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_nb_comm_enabled++;
 323:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return true;
 324:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 325:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 326:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_data_enable(void) {
 327:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port;
 328:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 329:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 330:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port                    = 0;
 331:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_nb_data_enabled = 0;
 332:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#else
 333:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //    if (udi_cdc_nb_data_enabled > UDI_CDC_PORT_NB) {
 334:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //        udi_cdc_nb_data_enabled = 0;
 335:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //    }
 336:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //    port = udi_cdc_nb_data_enabled;
 337:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 338:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 339:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Initialize TX management
 340:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_trans_ongoing[port]    = false;
 341:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_both_buf_to_send[port] = false;
 342:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_buf_sel[port]          = 0;
 343:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_buf_nb[port][0]        = 0;
 344:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_buf_nb[port][1]        = 0;
 345:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_sof_num[port]          = 0;
 346:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_send(port);
 347:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 348:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Initialize RX management
 349:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_trans_ongoing[port] = false;
 350:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_buf_sel[port]       = 0;
 351:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_buf_nb[port][0]     = 0;
 352:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_buf_nb[port][1]     = 0;
 353:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_pos[port]           = 0;
 354:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!udi_cdc_rx_start(port)) {
 355:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return false;
 356:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 357:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_nb_data_enabled++;
 358:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
 359:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_data_running = true;
 360:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 361:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return true;
 362:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 363:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 364:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_comm_disable(void) {
 365:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     Assert(udi_cdc_nb_comm_enabled != 0);
 366:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_nb_comm_enabled--;
 367:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 368:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 369:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_data_disable(void) {
 370:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //  uint8_t port;
 371:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 372:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     Assert(udi_cdc_nb_data_enabled != 0);
 373:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_nb_data_enabled--;
 374:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //  port = udi_cdc_nb_data_enabled;
 375:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //  UDI_CDC_DISABLE_EXT(port);
 376:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_data_running = false;
 377:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 378:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 379:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_comm_setup(void) {
 380:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port = udi_cdc_setup_to_port();
 381:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 382:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (Udd_setup_is_in()) {
 383:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // GET Interface Requests
 384:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
 385:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             // Requests Class Interface Get
 386:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             switch (udd_g_ctrlreq.req.bRequest) {
 387:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 case USB_REQ_CDC_GET_LINE_CODING:
 388:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     // Get configuration of CDC line
 389:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     if (sizeof(usb_cdc_line_coding_t) != udd_g_ctrlreq.req.wLength) return false;  
 390:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     udd_g_ctrlreq.payload      = (uint8_t *)&udi_cdc_line_coding[port];
 391:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     udd_g_ctrlreq.payload_size = sizeof(usb_cdc_line_coding_t);
 392:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     return true;
 393:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             }
 394:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 395:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 396:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (Udd_setup_is_out()) {
 397:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // SET Interface Requests
 398:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
 399:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             // Requests Class Interface Set
 400:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             switch (udd_g_ctrlreq.req.bRequest) {
 401:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 case USB_REQ_CDC_SET_LINE_CODING:
 402:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     // Change configuration of CDC line
 403:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     if (sizeof(usb_cdc_line_coding_t) != udd_g_ctrlreq.req.wLength) return false;  
 404:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     udd_g_ctrlreq.callback     = udi_cdc_line_coding_received;
 405:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     udd_g_ctrlreq.payload      = (uint8_t *)&udi_cdc_line_coding[port];
 406:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     udd_g_ctrlreq.payload_size = sizeof(usb_cdc_line_coding_t);
 407:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     return true;
 408:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 case USB_REQ_CDC_SET_CONTROL_LINE_STATE:
 409:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     // According cdc spec 1.1 chapter 6.2.14
 410:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     //              UDI_CDC_SET_DTR_EXT(port, (0 !=
 411:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     //                      (udd_g_ctrlreq.req.wValue
 412:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     //                       & CDC_CTRL_SIGNAL_DTE_PRESENT)));
 413:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     //              UDI_CDC_SET_RTS_EXT(port, (0 !=
 414:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     //                      (udd_g_ctrlreq.req.wValue
 415:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     //                       & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
 416:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     return true;
 417:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             }
 418:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 419:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 420:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return false;  // request Not supported
 421:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 422:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 423:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_data_setup(void) {
 424:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return false;  // request Not supported
 425:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 426:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 427:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint8_t udi_cdc_getsetting(void) {
 428:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return 0;  // CDC don't have multiple alternate setting
 429:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 430:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 431:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_data_sof_notify(void) {
 432:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     static uint8_t port_notify = 0;
 433:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 434:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // A call of udi_cdc_data_sof_notify() is done for each port
 435:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_send(port_notify);
 436:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 437:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #if UDI_CDC_PORT_NB != 1 // To optimize code
 438:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port_notify++;
 439:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (port_notify >= UDI_CDC_PORT_NB) {
 440:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port_notify = 0;
 441:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 442:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #endif
 443:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 444:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 445:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 446:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //-------------------------------------------------
 447:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //------- Internal routines to control serial line
 448:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 449:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static uint8_t udi_cdc_setup_to_port(void) {
 450:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port;
 451:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 452:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 453:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (udd_g_ctrlreq.req.wIndex & 0xFF) {
 454:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \
 455:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case UDI_CDC_COMM_IFACE_NUMBER_##iface: \
 456:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = iface; \
 457:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 458:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)
 459:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_IFACE_COMM_TO_PORT
 460:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 461:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = 0;
 462:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 463:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 464:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 465:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 466:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 467:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return port;
 468:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 469:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 470:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_line_coding_received(void) {
 471:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port = udi_cdc_setup_to_port();
 472:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     UNUSED(port);
 473:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 474:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //  UDI_CDC_SET_CODING_EXT(port, (&udi_cdc_line_coding[port]));
 475:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 476:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 477:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_ctrl_state_change(uint8_t port, bool b_set, le16_t bit_mask) {
 478:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udd_ep_id_t ep_comm;
 479:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
 480:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 481:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 482:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 483:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 484:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 485:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Update state
 486:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 487:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 488:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 489:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (b_set) {
 490:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_state[port] |= bit_mask;
 491:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     } else {
 492:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_state[port] &= ~(unsigned)bit_mask;
 493:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 494:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 495:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 496:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 497:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 498:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Send it if possible and state changed
 499:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (port) {
 500:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_PORT_TO_COMM_EP(index, unused) \
 501:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case index: \
 502:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ep_comm = UDI_CDC_COMM_EP_##index; \
 503:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 504:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_COMM_EP, ~)
 505:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_PORT_TO_COMM_EP
 506:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 507:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ep_comm = UDI_CDC_COMM_EP_0;
 508:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 509:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 510:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 511:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     ep_comm = UDI_CDC_COMM_EP_0;
 512:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 513:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_ctrl_state_notify(port, ep_comm);
 514:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 515:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 516:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_ctrl_state_notify(uint8_t port, udd_ep_id_t ep) {
 517:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    if UDI_CDC_PORT_NB == 1  // To optimize code
 518:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 519:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    endif
 520:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 521:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Send it if possible and state changed
 522:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if ((!udi_cdc_serial_state_msg_ongoing[port]) && (udi_cdc_state[port] != uid_cdc_state_msg[port
 523:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Fill notification message
 524:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         uid_cdc_state_msg[port].value = udi_cdc_state[port];
 525:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Send notification message
 526:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_serial_state_msg_ongoing[port] = udd_ep_run(ep, false, (uint8_t *)&uid_cdc_state_ms
 527:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 528:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 529:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 530:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_serial_state_msg_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep) {
 531:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port;
 532:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     UNUSED(n);
 533:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     UNUSED(status);
 534:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 535:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 536:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (ep) {
 537:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_GET_PORT_FROM_COMM_EP(iface, unused) \
 538:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case UDI_CDC_COMM_EP_##iface: \
 539:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = iface; \
 540:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 541:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_GET_PORT_FROM_COMM_EP, ~)
 542:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_GET_PORT_FROM_COMM_EP
 543:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 544:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = 0;
 545:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 546:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 547:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 548:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 549:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 550:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_serial_state_msg_ongoing[port] = false;
 551:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 552:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // For the irregular signals like break, the incoming ring signal,
 553:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // or the overrun error state, this will reset their values to zero
 554:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // and again will not send another notification until their state changes.
 555:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_state[port] &= ~(CDC_SERIAL_STATE_BREAK | CDC_SERIAL_STATE_RING | CDC_SERIAL_STATE_FRAM
 556:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uid_cdc_state_msg[port].value &= ~(CDC_SERIAL_STATE_BREAK | CDC_SERIAL_STATE_RING | CDC_SERIAL_
 557:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Send it if possible and state changed
 558:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_ctrl_state_notify(port, ep);
 559:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 560:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 561:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //-------------------------------------------------
 562:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //------- Internal routines to process data transfer
 563:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 564:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static bool udi_cdc_rx_start(uint8_t port) {
 565:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
 566:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t     buf_sel_trans;
 567:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udd_ep_id_t ep;
 568:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 569:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 570:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 571:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 572:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 573:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 574:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 575:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 576:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel_trans = udi_cdc_rx_buf_sel[port];
 577:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (udi_cdc_rx_trans_ongoing[port] || (udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_t
 578:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Transfer already on-going or current buffer no empty
 579:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         __DMB();
 580:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         __set_PRIMASK(irqflags);
 581:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return false;
 582:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 583:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 584:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Change current buffer
 585:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_pos[port]     = 0;
 586:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_buf_sel[port] = (buf_sel_trans == 0) ? 1 : 0;
 587:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 588:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Start transfer on RX
 589:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_trans_ongoing[port] = true;
 590:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 591:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 592:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 593:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (udi_cdc_multi_is_rx_ready(port)) {
 594:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         //      UDI_CDC_RX_NOTIFY(port);
 595:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 596:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 597:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 598:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Send the buffer with enable of short packet
 599:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (port) {
 600:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_PORT_TO_DATA_EP_OUT(index, unused) \
 601:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case index: \
 602:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ep = UDI_CDC_DATA_EP_OUT_##index; \
 603:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 604:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_OUT, ~)
 605:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_PORT_TO_DATA_EP_OUT
 606:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 607:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ep = UDI_CDC_DATA_EP_OUT_0;
 608:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 609:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 610:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 611:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     ep = UDI_CDC_DATA_EP_OUT_0;
 612:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 613:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return udd_ep_run(ep, true, udi_cdc_rx_buf[port][buf_sel_trans], UDI_CDC_RX_BUFFERS, udi_cdc_da
 614:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 615:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 616:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep) {
 617:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t buf_sel_trans;
 618:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port;
 619:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 620:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 621:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (ep) {
 622:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_DATA_EP_OUT_TO_PORT(index, unused) \
 623:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case UDI_CDC_DATA_EP_OUT_##index: \
 624:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = index; \
 625:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 626:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_OUT_TO_PORT, ~)
 627:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_DATA_EP_OUT_TO_PORT
 628:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 629:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = 0;
 630:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 631:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 632:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 633:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 634:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 635:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (UDD_EP_TRANSFER_OK != status) {
 636:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Abort reception
 637:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return;
 638:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 639:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 640:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel_trans = (udi_cdc_rx_buf_sel[port] == 0) ? 1 : 0;
 641:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 642:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!n) {
 643:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udd_ep_run(ep, true, udi_cdc_rx_buf[port][buf_sel_trans], UDI_CDC_RX_BUFFERS, udi_cdc_data_
 644:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return;
 645:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 646:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 647:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
 648:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_trans_ongoing[port]         = false;
 649:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_start(port);
 650:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 651:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 652:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep) {
 653:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t port;
 654:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     UNUSED(n);
 655:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 656:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 657:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (ep) {
 658:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_DATA_EP_IN_TO_PORT(index, unused) \
 659:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case UDI_CDC_DATA_EP_IN_##index: \
 660:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = index; \
 661:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 662:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_IN_TO_PORT, ~)
 663:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_DATA_EP_IN_TO_PORT
 664:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 665:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         port = 0;
 666:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 667:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 668:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 669:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 670:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 671:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (UDD_EP_TRANSFER_OK != status) {
 672:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Abort transfer
 673:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return;
 674:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 675:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 676:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port] == 0) ? 1 : 0] = 0;
 677:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_both_buf_to_send[port]                                = false;
 678:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_trans_ongoing[port]                                   = false;
 679:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 680:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (n != 0) {
 681:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         UDI_CDC_TX_EMPTY_NOTIFY(port);
 682:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 683:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 684:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_send(port);
 685:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 686:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 687:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static void udi_cdc_tx_send(uint8_t port) {
 688:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t        irqflags;  // irqflags_t
 689:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t         buf_sel_trans;
 690:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     bool            b_short_packet;
 691:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udd_ep_id_t     ep;
 692:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     static uint16_t sof_zlp_counter = 0;
 693:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 694:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 695:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 696:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 697:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 698:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (udi_cdc_tx_trans_ongoing[port]) {
 699:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return;  // Already on going or wait next SOF to send next data
 700:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 701:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (udd_is_high_speed()) {
 702:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
 703:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return;  // Wait next SOF to send next data
 704:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 705:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     } else {
 706:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
 707:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return;  // Wait next SOF to send next data
 708:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 709:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 710:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 711:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 712:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 713:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 714:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel_trans = udi_cdc_tx_buf_sel[port];
 715:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
 716:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         sof_zlp_counter++;
 717:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (((!udd_is_high_speed()) && (sof_zlp_counter < 100)) || (udd_is_high_speed() && (sof_zlp
 718:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             __DMB();
 719:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             __set_PRIMASK(irqflags);
 720:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return;
 721:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 722:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 723:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     sof_zlp_counter = 0;
 724:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 725:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!udi_cdc_tx_both_buf_to_send[port]) {
 726:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Send current Buffer
 727:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // and switch the current buffer
 728:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_tx_buf_sel[port] = (buf_sel_trans == 0) ? 1 : 0;
 729:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     } else {
 730:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Send the other Buffer
 731:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // and no switch the current buffer
 732:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         buf_sel_trans = (buf_sel_trans == 0) ? 1 : 0;
 733:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 734:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_trans_ongoing[port] = true;
 735:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 736:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 737:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 738:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
 739:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (b_short_packet) {
 740:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (udd_is_high_speed()) {
 741:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
 742:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         } else {
 743:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             udi_cdc_tx_sof_num[port] = udd_get_frame_number();
 744:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 745:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     } else {
 746:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_tx_sof_num[port] = 0;  // Force next transfer without wait SOF
 747:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 748:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 749:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     /*
 750:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Send the buffer with enable of short packet
 751:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     switch (port) {
 752:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #define UDI_CDC_PORT_TO_DATA_EP_IN(index, unused) \
 753:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     case index: \
 754:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ep = UDI_CDC_DATA_EP_IN_##index; \
 755:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 756:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_IN, ~)
 757:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #undef UDI_CDC_PORT_TO_DATA_EP_IN
 758:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     default:
 759:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ep = UDI_CDC_DATA_EP_IN_0;
 760:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         break;
 761:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 762:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     */
 763:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     ep = UDI_CDC_DATA_EP_IN_0;
 764:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 765:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udd_ep_run(ep, b_short_packet, udi_cdc_tx_buf[port][buf_sel_trans], udi_cdc_tx_buf_nb[port][buf
 766:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 767:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 768:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //---------------------------------------------
 769:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** //------- Application interface
 770:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 771:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_ctrl_signal_dcd(bool b_set) { udi_cdc_ctrl_state_change(0, b_set, CDC_SERIAL_STATE_DCD
 772:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 773:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_ctrl_signal_dsr(bool b_set) { udi_cdc_ctrl_state_change(0, b_set, CDC_SERIAL_STATE_DSR
 774:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 775:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_signal_framing_error(void) { udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_FRAMI
 776:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 777:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_signal_parity_error(void) { udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_PARITY
 778:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 779:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_signal_overrun(void) { udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_OVERRUN); }
 780:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 781:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_multi_ctrl_signal_dcd(uint8_t port, bool b_set) { udi_cdc_ctrl_state_change(port, b_se
 782:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 783:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_multi_ctrl_signal_dsr(uint8_t port, bool b_set) { udi_cdc_ctrl_state_change(port, b_se
 784:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 785:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_multi_signal_framing_error(uint8_t port) { udi_cdc_ctrl_state_change(port, true, CDC_S
 786:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 787:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_multi_signal_parity_error(uint8_t port) { udi_cdc_ctrl_state_change(port, true, CDC_SE
 788:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 789:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void udi_cdc_multi_signal_overrun(uint8_t port) { udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_
 790:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 791:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port) {
 792:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
 793:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint16_t    pos;
 794:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     iram_size_t nb_received;
 795:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 796:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 797:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 798:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 799:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 800:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 801:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 802:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 803:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     pos         = udi_cdc_rx_pos[port];
 804:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
 805:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 806:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 807:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return nb_received;
 808:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 809:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 810:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_get_nb_received_data(void) { return udi_cdc_multi_get_nb_received_data(0); }
 811:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 812:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_multi_is_rx_ready(uint8_t port) { return (udi_cdc_multi_get_nb_received_data(port) > 0
 813:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 814:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_is_rx_ready(void) { return udi_cdc_multi_is_rx_ready(0); }
 815:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 816:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** int udi_cdc_multi_getc(uint8_t port) {
 817:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t irqflags;  // irqflags_t
 818:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     int      rx_data = 0;
 819:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     bool     b_databit_9;
 820:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint16_t pos;
 821:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t  buf_sel;
 822:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     bool     again;
 823:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 824:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 825:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 826:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 827:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 828:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
 829:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 830:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** udi_cdc_getc_process_one_byte:
 831:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Check available data
 832:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 833:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 834:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 835:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     pos     = udi_cdc_rx_pos[port];
 836:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel = udi_cdc_rx_buf_sel[port];
 837:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     again   = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
 838:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 839:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 840:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     while (again) {
 841:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (!udi_cdc_data_running) {
 842:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return 0;
 843:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 844:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_getc_process_one_byte;
 845:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 846:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 847:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Read data
 848:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     rx_data |= udi_cdc_rx_buf[port][buf_sel][pos];
 849:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_pos[port] = pos + 1;
 850:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 851:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_start(port);
 852:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 853:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (b_databit_9) {
 854:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Receive MSB
 855:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         b_databit_9 = false;
 856:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         rx_data     = rx_data << 8;
 857:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_getc_process_one_byte;
 858:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 859:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return rx_data;
 860:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 861:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 862:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** int udi_cdc_getc(void) { return udi_cdc_multi_getc(0); }
 863:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 864:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_multi_read_buf(uint8_t port, void *buf, iram_size_t size) {
 865:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
 866:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t *   ptr_buf = (uint8_t *)buf;
 867:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     iram_size_t copy_nb;
 868:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint16_t    pos;
 869:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t     buf_sel;
 870:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     bool        again;
 871:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 872:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 873:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 874:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 875:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 876:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** udi_cdc_read_buf_loop_wait:
 877:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Check available data
 878:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 879:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 880:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 881:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     pos     = udi_cdc_rx_pos[port];
 882:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel = udi_cdc_rx_buf_sel[port];
 883:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     again   = pos >= udi_cdc_rx_buf_nb[port][buf_sel];
 884:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 885:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 886:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     while (again) {
 887:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (!udi_cdc_data_running) {
 888:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return size;
 889:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 890:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_read_buf_loop_wait;
 891:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 892:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 893:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Read data
 894:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     copy_nb = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
 895:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (copy_nb > size) {
 896:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         copy_nb = size;
 897:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 898:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], copy_nb);
 899:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_pos[port] += copy_nb;
 900:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     ptr_buf += copy_nb;
 901:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     size -= copy_nb;
 902:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_rx_start(port);
 903:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 904:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (size) {
 905:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_read_buf_loop_wait;
 906:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 907:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return 0;
 908:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 909:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 910:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** static iram_size_t udi_cdc_multi_read_no_polling(uint8_t port, void *buf, iram_size_t size) {
 911:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t *   ptr_buf = (uint8_t *)buf;
 912:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     iram_size_t nb_avail_data;
 913:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint16_t    pos;
 914:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t     buf_sel;
 915:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
 916:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 917:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 918:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 919:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 920:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 921:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Data interface not started... exit
 922:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!udi_cdc_data_running) {
 923:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         return 0;
 924:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 925:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 926:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Get number of available data
 927:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Check available data
 928:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 929:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 930:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 931:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     pos           = udi_cdc_rx_pos[port];
 932:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel       = udi_cdc_rx_buf_sel[port];
 933:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     nb_avail_data = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
 934:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 935:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 936:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // If the buffer contains less than the requested number of data,
 937:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // adjust read size
 938:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (nb_avail_data < size) {
 939:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         size = nb_avail_data;
 940:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 941:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (size > 0) {
 942:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], size);
 943:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         irqflags = __get_PRIMASK();
 944:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         __disable_irq();
 945:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         __DMB();
 946:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_rx_pos[port] += size;
 947:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         __DMB();
 948:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         __set_PRIMASK(irqflags);
 949:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ptr_buf += size;
 950:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_rx_start(port);
 951:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 952:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return (nb_avail_data);
 953:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 954:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 955:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_read_no_polling(void *buf, iram_size_t size) { return udi_cdc_multi_read_no_pol
 956:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 957:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_read_buf(void *buf, iram_size_t size) { return udi_cdc_multi_read_buf(0, buf, s
 958:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 959:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_multi_get_free_tx_buffer(uint8_t port) {
 960:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
 961:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     iram_size_t buf_sel_nb, retval;
 962:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t     buf_sel;
 963:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 964:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
 965:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
 966:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
 967:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 968:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
 969:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
 970:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 971:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel    = udi_cdc_tx_buf_sel[port];
 972:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
 973:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
 974:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if ((!udi_cdc_tx_trans_ongoing[port]) && (!udi_cdc_tx_both_buf_to_send[port])) {
 975:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             /* One buffer is full, but the other buffer is not used.
 976:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****              * (not used = transfer on-going)
 977:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****              * then move to the other buffer to store data */
 978:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             udi_cdc_tx_both_buf_to_send[port] = true;
 979:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             udi_cdc_tx_buf_sel[port]          = (buf_sel == 0) ? 1 : 0;
 980:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             buf_sel_nb                        = 0;
 981:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
 982:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
 983:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     retval = UDI_CDC_TX_BUFFERS - buf_sel_nb;
 984:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
 985:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
 986:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return retval;
 987:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 988:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 989:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_get_free_tx_buffer(void) { return udi_cdc_multi_get_free_tx_buffer(0); }
 990:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 991:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_multi_is_tx_ready(uint8_t port) { return (udi_cdc_multi_get_free_tx_buffer(port) != 0)
 992:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 993:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** bool udi_cdc_is_tx_ready(void) { return udi_cdc_multi_is_tx_ready(0); }
 994:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
 995:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** int udi_cdc_multi_putc(uint8_t port, int value) {
 996:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t irqflags;  // irqflags_t
 997:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     bool     b_databit_9;
 998:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t  buf_sel;
 999:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1000:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
1001:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
1002:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
1003:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1004:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
1005:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1006:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** udi_cdc_putc_process_one_byte:
1007:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Check available space
1008:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!udi_cdc_multi_is_tx_ready(port)) {
1009:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (!udi_cdc_data_running) {
1010:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return false;
1011:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
1012:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_putc_process_one_byte;
1013:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1014:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1015:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Write value
1016:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
1017:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
1018:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
1019:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel                                                           = udi_cdc_tx_buf_sel[port];
1020:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
1021:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
1022:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
1023:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1024:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (b_databit_9) {
1025:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         // Send MSB
1026:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         b_databit_9 = false;
1027:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         value       = value >> 8;
1028:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_putc_process_one_byte;
1029:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1030:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return true;
1031:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1032:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1033:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** int udi_cdc_putc(int value) { return udi_cdc_multi_putc(0, value); }
1034:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1035:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_multi_write_buf(uint8_t port, const void *buf, iram_size_t size) {
1036:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t    irqflags;  // irqflags_t
1037:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t     buf_sel;
1038:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint16_t    buf_nb;
1039:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     iram_size_t copy_nb;
1040:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint8_t *   ptr_buf = (uint8_t *)buf;
1041:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1042:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#if UDI_CDC_PORT_NB == 1 // To optimize code
1043:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     port = 0;
1044:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     //#endif
1045:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1046:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (9 == udi_cdc_line_coding[port].bDataBits) {
1047:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         size *= 2;
1048:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1049:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1050:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** udi_cdc_write_buf_loop_wait:
1051:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1052:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Check available space
1053:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!udi_cdc_multi_is_tx_ready(port)) {
1054:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (!udi_cdc_data_running) {
1055:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             return size;
1056:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
1057:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_write_buf_loop_wait;
1058:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1059:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1060:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Write values
1061:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     irqflags = __get_PRIMASK();
1062:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __disable_irq();
1063:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
1064:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_sel = udi_cdc_tx_buf_sel[port];
1065:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     buf_nb  = udi_cdc_tx_buf_nb[port][buf_sel];
1066:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     copy_nb = UDI_CDC_TX_BUFFERS - buf_nb;
1067:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (copy_nb > size) {
1068:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         copy_nb = size;
1069:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1070:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     memcpy(&udi_cdc_tx_buf[port][buf_sel][buf_nb], ptr_buf, copy_nb);
1071:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_buf_nb[port][buf_sel] = buf_nb + copy_nb;
1072:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __DMB();
1073:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     __set_PRIMASK(irqflags);
1074:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1075:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     // Update buffer pointer
1076:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     ptr_buf = ptr_buf + copy_nb;
1077:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     size -= copy_nb;
1078:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1079:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (size) {
1080:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         goto udi_cdc_write_buf_loop_wait;
1081:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1082:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1083:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return 0;
1084:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1085:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1086:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** iram_size_t udi_cdc_write_buf(const void *buf, iram_size_t size) { return udi_cdc_multi_write_buf(0
1087:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1088:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    define MAX_PRINT 256
1089:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #    define CDC_SEND_INTERVAL 2
1090:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint32_t cdc_tx_send_time_next;
1091:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1092:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void CDC_send(void) {
1093:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     while (timer_read64() < cdc_tx_send_time_next)
1094:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         ;
1095:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_tx_send(0);
1096:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     cdc_tx_send_time_next = timer_read64() + CDC_SEND_INTERVAL;
1097:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1098:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1099:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint32_t CDC_print(char *printbuf) {
1100:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     uint32_t count = 0;
1101:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     char *   buf   = printbuf;
1102:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     char     c;
1103:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1104:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (timer_read64() < 5000) return 0;
1105:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1106:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     while ((c = *buf++) != 0 && !(count >= MAX_PRINT)) {
1107:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         count++;
1108:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (!udi_cdc_is_tx_ready()) return 0;
1109:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         udi_cdc_putc(c);
1110:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         if (count >= UDI_CDC_TX_BUFFERS) {
1111:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             count = 0;
1112:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             CDC_send();
1113:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
1114:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1115:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (count) {
1116:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         CDC_send();
1117:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1118:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return 1;
1119:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1120:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1121:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** char printbuf[CDC_PRINTBUF_SIZE];
1122:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1123:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** int CDC_printf(const char *_Format, ...) {
1124:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     va_list va;  // Variable argument list variable
1125:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     int     result;
1126:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1127:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     va_start(va, _Format);  // Initialize the variable argument list
1128:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     result = vsnprintf(printbuf, CDC_PRINTBUF_SIZE, _Format, va);
1129:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     va_end(va);
1130:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1131:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     CDC_print(printbuf);
1132:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1133:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return result;
1134:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1135:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1136:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** // global "inbuf" if desired
1137:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** inbuf_t inbuf;
1138:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1139:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint32_t CDC_input_buf(inbuf_t inbuf, uint32_t inbuf_size) {
1140:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     int RXChar;
1141:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     int entered = 0;
1142:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1143:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (!udi_cdc_is_rx_ready()) return 0;
1144:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     udi_cdc_get_nb_received_data();
1145:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     RXChar = udi_cdc_getc();
1146:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1147:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     if (RXChar) {
1148:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         switch (RXChar) {
1149:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             case '\t':  // tab - repeat last
1150:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 inbuf.count                = inbuf.lastcount;
1151:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 inbuf.buf[inbuf.count + 1] = 0;
1152:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 CDC_print(inbuf.buf);
1153:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 break;
1154:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             case '\r':  // enter
1155:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 inbuf.buf[inbuf.count] = 0;
1156:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 inbuf.lastcount        = inbuf.count;
1157:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 inbuf.count            = 0;
1158:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 entered                = 1;
1159:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 break;
1160:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             case '\b':  // backspace
1161:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 if (inbuf.count > 0) {
1162:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     inbuf.count -= 1;
1163:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     CDC_print("\b \b\0");
1164:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 } else
1165:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     CDC_print("\a\0");
1166:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 break;
1167:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****             default:
1168:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 if ((RXChar >= 32) && (RXChar <= 126)) {
1169:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     if (inbuf.count < inbuf_size - 1) {
1170:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                         inbuf.buf[inbuf.count]     = RXChar;
1171:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                         inbuf.buf[inbuf.count + 1] = 0;
1172:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                         CDC_print(&inbuf.buf[inbuf.count]);
1173:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                         inbuf.count += 1;
1174:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                     } else
1175:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                         CDC_print("\a\0");
1176:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 }
1177:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****                 break;
1178:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         }
1179:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****         RXChar = 0;
1180:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     }
1181:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     return entered;
1182:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1183:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1184:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint32_t CDC_input() { return CDC_input_buf(inbuf, CDC_INBUF_SIZE); }
1185:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1186:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void CDC_init(void) {
1187:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     inbuf.count           = 0;
1188:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     inbuf.lastcount       = 0;
1189:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     printbuf[0]           = 0;
1190:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     cdc_tx_send_time_next = timer_read64() + CDC_SEND_INTERVAL;
1191:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
1192:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1193:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** #else  // CDC line 62
1194:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1195:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** char printbuf[CDC_PRINTBUF_SIZE];
1196:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1197:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void CDC_send(void) { return; }
  28              		.loc 1 1197 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              		.loc 1 1197 0
  34 0000 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE137:
  38              		.section	.text.CDC_print,"ax",%progbits
  39              		.align	1
  40              		.global	CDC_print
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu fpv4-sp-d16
  46              	CDC_print:
  47              	.LFB138:
1198:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1199:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint32_t CDC_print(char *printbuf) { return 0; }
  48              		.loc 1 1199 0
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 0
  51              		@ frame_needed = 0, uses_anonymous_args = 0
  52              		@ link register save eliminated.
  53              	.LVL0:
  54              		.loc 1 1199 0
  55 0000 0020     		movs	r0, #0
  56              	.LVL1:
  57 0002 7047     		bx	lr
  58              		.cfi_endproc
  59              	.LFE138:
  61              		.section	.text.CDC_printf,"ax",%progbits
  62              		.align	1
  63              		.global	CDC_printf
  64              		.syntax unified
  65              		.thumb
  66              		.thumb_func
  67              		.fpu fpv4-sp-d16
  69              	CDC_printf:
  70              	.LFB139:
1200:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1201:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** int CDC_printf(const char *_Format, ...) { return 0; }
  71              		.loc 1 1201 0
  72              		.cfi_startproc
  73              		@ args = 4, pretend = 16, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 1
  75              		@ link register save eliminated.
  76              	.LVL2:
  77 0000 0FB4     		push	{r0, r1, r2, r3}
  78              		.cfi_def_cfa_offset 16
  79              		.cfi_offset 0, -16
  80              		.cfi_offset 1, -12
  81              		.cfi_offset 2, -8
  82              		.cfi_offset 3, -4
  83              		.loc 1 1201 0
  84 0002 0020     		movs	r0, #0
  85 0004 04B0     		add	sp, sp, #16
  86              		.cfi_restore 3
  87              		.cfi_restore 2
  88              		.cfi_restore 1
  89              		.cfi_restore 0
  90              		.cfi_def_cfa_offset 0
  91 0006 7047     		bx	lr
  92              		.cfi_endproc
  93              	.LFE139:
  95              		.section	.text.CDC_input,"ax",%progbits
  96              		.align	1
  97              		.global	CDC_input
  98              		.syntax unified
  99              		.thumb
 100              		.thumb_func
 101              		.fpu fpv4-sp-d16
 103              	CDC_input:
 104              	.LFB140:
1202:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1203:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** inbuf_t inbuf;
1204:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1205:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** uint32_t CDC_input(void) { return 0; }
 105              		.loc 1 1205 0
 106              		.cfi_startproc
 107              		@ args = 0, pretend = 0, frame = 0
 108              		@ frame_needed = 0, uses_anonymous_args = 0
 109              		@ link register save eliminated.
 110              		.loc 1 1205 0
 111 0000 0020     		movs	r0, #0
 112 0002 7047     		bx	lr
 113              		.cfi_endproc
 114              	.LFE140:
 116              		.section	.text.CDC_init,"ax",%progbits
 117              		.align	1
 118              		.global	CDC_init
 119              		.syntax unified
 120              		.thumb
 121              		.thumb_func
 122              		.fpu fpv4-sp-d16
 124              	CDC_init:
 125              	.LFB141:
1206:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** 
1207:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** void CDC_init(void) {
 126              		.loc 1 1207 0
 127              		.cfi_startproc
 128              		@ args = 0, pretend = 0, frame = 0
 129              		@ frame_needed = 0, uses_anonymous_args = 0
 130              		@ link register save eliminated.
1208:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     inbuf.count     = 0;
 131              		.loc 1 1208 0
 132 0000 034A     		ldr	r2, .L6
 133 0002 0023     		movs	r3, #0
1209:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     inbuf.lastcount = 0;
 134              		.loc 1 1209 0
 135 0004 C2E90033 		strd	r3, r3, [r2]
1210:tmk_core/protocol/arm_atsam/usb/udi_cdc.c ****     printbuf[0]     = 0;
 136              		.loc 1 1210 0
 137 0008 024A     		ldr	r2, .L6+4
 138 000a 1370     		strb	r3, [r2]
1211:tmk_core/protocol/arm_atsam/usb/udi_cdc.c **** }
 139              		.loc 1 1211 0
 140 000c 7047     		bx	lr
 141              	.L7:
 142 000e 00BF     		.align	2
 143              	.L6:
 144 0010 00000000 		.word	inbuf
 145 0014 00000000 		.word	printbuf
 146              		.cfi_endproc
 147              	.LFE141:
 149              		.comm	inbuf,12,4
 150              		.comm	printbuf,1,1
 151              		.text
 152              	.Letext0:
 153              		.file 2 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 154              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 155              		.file 4 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/core_cm4.h"
 156              		.file 5 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/system_samd51.h"
 157              		.file 6 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 158              		.file 7 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 159              		.file 8 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
 160              		.file 9 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 161              		.file 10 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 162              		.file 11 "tmk_core/protocol/arm_atsam/usb/compiler.h"
 163              		.file 12 "tmk_core/protocol/arm_atsam/usb/usb_protocol.h"
 164              		.file 13 "tmk_core/protocol/arm_atsam/usb/udi_device_conf.h"
 165              		.file 14 "tmk_core/protocol/arm_atsam/usb/udi.h"
 166              		.file 15 "tmk_core/protocol/arm_atsam/usb/udc_desc.h"
 167              		.file 16 "tmk_core/protocol/arm_atsam/usb/udi_hid_kbd.h"
 168              		.file 17 "tmk_core/protocol/arm_atsam/usb/usb_main.h"
 169              		.file 18 "tmk_core/protocol/arm_atsam/usb/udd.h"
 170              		.file 19 "tmk_core/protocol/arm_atsam/usb/udi_cdc.h"
 171              		.file 20 "./tmk_core/protocol/arm_atsam/clks.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 udi_cdc.c
/var/tmp//ccm1RlyJ.s:18     .text.CDC_send:0000000000000000 $t
/var/tmp//ccm1RlyJ.s:25     .text.CDC_send:0000000000000000 CDC_send
/var/tmp//ccm1RlyJ.s:39     .text.CDC_print:0000000000000000 $t
/var/tmp//ccm1RlyJ.s:46     .text.CDC_print:0000000000000000 CDC_print
/var/tmp//ccm1RlyJ.s:62     .text.CDC_printf:0000000000000000 $t
/var/tmp//ccm1RlyJ.s:69     .text.CDC_printf:0000000000000000 CDC_printf
/var/tmp//ccm1RlyJ.s:96     .text.CDC_input:0000000000000000 $t
/var/tmp//ccm1RlyJ.s:103    .text.CDC_input:0000000000000000 CDC_input
/var/tmp//ccm1RlyJ.s:117    .text.CDC_init:0000000000000000 $t
/var/tmp//ccm1RlyJ.s:124    .text.CDC_init:0000000000000000 CDC_init
/var/tmp//ccm1RlyJ.s:144    .text.CDC_init:0000000000000010 $d
                            *COM*:000000000000000c inbuf
                            *COM*:0000000000000001 printbuf

NO UNDEFINED SYMBOLS

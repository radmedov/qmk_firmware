   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #    include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #    include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #    include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  48:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  49:tmk_core/common/action.c **** #endif
  50:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  51:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** /** \brief Called to execute an action.
  54:tmk_core/common/action.c ****  *
  55:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  56:tmk_core/common/action.c ****  */
  57:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 57 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  58:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  59:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  60:tmk_core/common/action.c ****         dprint("EVENT: ");
  61:tmk_core/common/action.c ****         debug_event(event);
  62:tmk_core/common/action.c ****         dprintln();
  63:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  64:tmk_core/common/action.c ****         retro_tapping_counter++;
  65:tmk_core/common/action.c **** #endif
  66:tmk_core/common/action.c ****     }
  67:tmk_core/common/action.c **** 
  68:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  69:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  70:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  71:tmk_core/common/action.c ****     }
  72:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  73:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c ****     fauxclicky_check();
  76:tmk_core/common/action.c **** #endif
  77:tmk_core/common/action.c **** 
  78:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  79:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  80:tmk_core/common/action.c ****         process_hand_swap(&event);
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** #endif
  83:tmk_core/common/action.c **** 
  84:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  48               		.loc 1 84 0
  49 001e 1E82      		std Y+6,__zero_reg__
  50 0020 1D82      		std Y+5,__zero_reg__
  51 0022 85E0      		ldi r24,lo8(5)
  52 0024 FE01      		movw r30,r28
  53 0026 3796      		adiw r30,7
  54 0028 DE01      		movw r26,r28
  55 002a 1196      		adiw r26,1
  56               		0:
  57 002c 0190      		ld r0,Z+
  58 002e 0D92      		st X+,r0
  59 0030 8A95      		dec r24
  60 0032 01F4      		brne 0b
  85:tmk_core/common/action.c **** 
  86:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  87:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  88:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  91:tmk_core/common/action.c ****         clear_oneshot_mods();
  92:tmk_core/common/action.c ****     }
  93:tmk_core/common/action.c **** #endif
  94:tmk_core/common/action.c **** 
  95:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  96:tmk_core/common/action.c ****     action_tapping_process(record);
  61               		.loc 1 96 0
  62 0034 4981      		ldd r20,Y+1
  63               	.LVL1:
  64 0036 5A81      		ldd r21,Y+2
  65               	.LVL2:
  66 0038 6B81      		ldd r22,Y+3
  67 003a 7C81      		ldd r23,Y+4
  68 003c 8D81      		ldd r24,Y+5
  69 003e 9E81      		ldd r25,Y+6
  70               	/* epilogue start */
  97:tmk_core/common/action.c **** #else
  98:tmk_core/common/action.c ****     process_record(&record);
  99:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 100:tmk_core/common/action.c ****         dprint("processed: ");
 101:tmk_core/common/action.c ****         debug_record(record);
 102:tmk_core/common/action.c ****         dprintln();
 103:tmk_core/common/action.c ****     }
 104:tmk_core/common/action.c **** #endif
 105:tmk_core/common/action.c **** }
  71               		.loc 1 105 0
  72 0040 2B96      		adiw r28,11
  73 0042 0FB6      		in __tmp_reg__,__SREG__
  74 0044 F894      		cli
  75 0046 DEBF      		out __SP_H__,r29
  76 0048 0FBE      		out __SREG__,__tmp_reg__
  77 004a CDBF      		out __SP_L__,r28
  78 004c DF91      		pop r29
  79 004e CF91      		pop r28
  96:tmk_core/common/action.c **** #else
  80               		.loc 1 96 0
  81 0050 0C94 0000 		jmp action_tapping_process
  82               	.LVL3:
  83               		.cfi_endproc
  84               	.LFE13:
  86               		.section	.text.process_record_quantum,"ax",@progbits
  87               		.weak	process_record_quantum
  89               	process_record_quantum:
  90               	.LFB15:
 106:tmk_core/common/action.c **** 
 107:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 108:tmk_core/common/action.c **** bool swap_hands = false;
 109:tmk_core/common/action.c **** bool swap_held  = false;
 110:tmk_core/common/action.c **** 
 111:tmk_core/common/action.c **** /** \brief Process Hand Swap
 112:tmk_core/common/action.c ****  *
 113:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 114:tmk_core/common/action.c ****  */
 115:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 116:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 117:tmk_core/common/action.c **** 
 118:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 119:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 120:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 121:tmk_core/common/action.c **** 
 122:tmk_core/common/action.c ****     if (do_swap) {
 123:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 124:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 125:tmk_core/common/action.c ****     } else {
 126:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 127:tmk_core/common/action.c ****     }
 128:tmk_core/common/action.c **** }
 129:tmk_core/common/action.c **** #endif
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 132:tmk_core/common/action.c **** bool disable_action_cache = false;
 133:tmk_core/common/action.c **** 
 134:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 135:tmk_core/common/action.c ****     disable_action_cache = true;
 136:tmk_core/common/action.c ****     process_record(record);
 137:tmk_core/common/action.c ****     disable_action_cache = false;
 138:tmk_core/common/action.c **** }
 139:tmk_core/common/action.c **** #else
 140:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 141:tmk_core/common/action.c **** #endif
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  91               		.loc 1 143 0
  92               		.cfi_startproc
  93               	.LVL4:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  98               		.loc 1 143 0
  99 0000 81E0      		ldi r24,lo8(1)
 100               	.LVL5:
 101               	/* epilogue start */
 102 0002 0895      		ret
 103               		.cfi_endproc
 104               	.LFE15:
 106               		.section	.text.process_record_tap_hint,"ax",@progbits
 107               	.global	process_record_tap_hint
 109               	process_record_tap_hint:
 110               	.LFB16:
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 146:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 147:tmk_core/common/action.c ****  *
 148:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 149:tmk_core/common/action.c ****  */
 150:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 111               		.loc 1 150 0
 112               		.cfi_startproc
 113               	.LVL6:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
 151:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 118               		.loc 1 151 0
 119 0000 FC01      		movw r30,r24
 120 0002 8081      		ld r24,Z
 121 0004 9181      		ldd r25,Z+1
 122               	.LVL7:
 123 0006 0C94 0000 		jmp layer_switch_get_action
 124               	.LVL8:
 125               		.cfi_endproc
 126               	.LFE16:
 128               		.section	.text.register_code,"ax",@progbits
 129               	.global	register_code
 131               	register_code:
 132               	.LFB19:
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c ****     switch (action.kind.id) {
 154:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 155:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:tmk_core/common/action.c ****             switch (action.swap.code) {
 157:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:tmk_core/common/action.c ****                 default:
 159:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:tmk_core/common/action.c ****                     swap_held  = true;
 161:tmk_core/common/action.c ****             }
 162:tmk_core/common/action.c ****             break;
 163:tmk_core/common/action.c **** #    endif
 164:tmk_core/common/action.c ****     }
 165:tmk_core/common/action.c **** }
 166:tmk_core/common/action.c **** #endif
 167:tmk_core/common/action.c **** 
 168:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:tmk_core/common/action.c ****  *
 170:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:tmk_core/common/action.c ****  */
 172:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 173:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 174:tmk_core/common/action.c ****         return;
 175:tmk_core/common/action.c ****     }
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:tmk_core/common/action.c ****     dprint("ACTION: ");
 181:tmk_core/common/action.c ****     debug_action(action);
 182:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 183:tmk_core/common/action.c ****     dprint(" layer_state: ");
 184:tmk_core/common/action.c ****     layer_debug();
 185:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 186:tmk_core/common/action.c ****     default_layer_debug();
 187:tmk_core/common/action.c **** #endif
 188:tmk_core/common/action.c ****     dprintln();
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c ****     process_action(record, action);
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 194:tmk_core/common/action.c ****  *
 195:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 196:tmk_core/common/action.c ****  */
 197:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 198:tmk_core/common/action.c ****     keyevent_t event = record->event;
 199:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 200:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 201:tmk_core/common/action.c **** #endif
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (event.pressed) {
 204:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 205:tmk_core/common/action.c ****         clear_weak_mods();
 206:tmk_core/common/action.c ****     }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 209:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 210:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 211:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 212:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 213:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 214:tmk_core/common/action.c ****     }
 215:tmk_core/common/action.c **** #endif
 216:tmk_core/common/action.c **** 
 217:tmk_core/common/action.c ****     switch (action.kind.id) {
 218:tmk_core/common/action.c ****         /* Key and Mods */
 219:tmk_core/common/action.c ****         case ACT_LMODS:
 220:tmk_core/common/action.c ****         case ACT_RMODS: {
 221:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 222:tmk_core/common/action.c ****             if (event.pressed) {
 223:tmk_core/common/action.c ****                 if (mods) {
 224:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 226:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 227:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 228:tmk_core/common/action.c ****                         add_mods(mods);
 229:tmk_core/common/action.c ****                     } else {
 230:tmk_core/common/action.c ****                         add_weak_mods(mods);
 231:tmk_core/common/action.c ****                     }
 232:tmk_core/common/action.c ****                     send_keyboard_report();
 233:tmk_core/common/action.c ****                 }
 234:tmk_core/common/action.c ****                 register_code(action.key.code);
 235:tmk_core/common/action.c ****             } else {
 236:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 237:tmk_core/common/action.c ****                 if (mods) {
 238:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:tmk_core/common/action.c ****                         del_mods(mods);
 240:tmk_core/common/action.c ****                     } else {
 241:tmk_core/common/action.c ****                         del_weak_mods(mods);
 242:tmk_core/common/action.c ****                     }
 243:tmk_core/common/action.c ****                     send_keyboard_report();
 244:tmk_core/common/action.c ****                 }
 245:tmk_core/common/action.c ****             }
 246:tmk_core/common/action.c ****         } break;
 247:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 248:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 249:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 250:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 251:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 252:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 253:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 254:tmk_core/common/action.c ****                     // Oneshot modifier
 255:tmk_core/common/action.c ****                     if (event.pressed) {
 256:tmk_core/common/action.c ****                         if (tap_count == 0) {
 257:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 258:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 259:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 260:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 261:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 263:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 264:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 265:tmk_core/common/action.c ****                             clear_oneshot_mods();
 266:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 267:tmk_core/common/action.c ****                             register_mods(mods);
 268:tmk_core/common/action.c **** #        endif
 269:tmk_core/common/action.c ****                         } else {
 270:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 271:tmk_core/common/action.c ****                         }
 272:tmk_core/common/action.c ****                     } else {
 273:tmk_core/common/action.c ****                         if (tap_count == 0) {
 274:tmk_core/common/action.c ****                             clear_oneshot_mods();
 275:tmk_core/common/action.c ****                             unregister_mods(mods);
 276:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 277:tmk_core/common/action.c ****                             // Retain Oneshot mods
 278:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 279:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 280:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 281:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 282:tmk_core/common/action.c ****                                 unregister_mods(mods);
 283:tmk_core/common/action.c ****                             }
 284:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 285:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 286:tmk_core/common/action.c **** #        endif
 287:tmk_core/common/action.c ****                         } else {
 288:tmk_core/common/action.c ****                             clear_oneshot_mods();
 289:tmk_core/common/action.c ****                             unregister_mods(mods);
 290:tmk_core/common/action.c ****                         }
 291:tmk_core/common/action.c ****                     }
 292:tmk_core/common/action.c ****                     break;
 293:tmk_core/common/action.c **** #    endif
 294:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 295:tmk_core/common/action.c ****                     if (event.pressed) {
 296:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 297:tmk_core/common/action.c ****                             register_mods(mods);
 298:tmk_core/common/action.c ****                         }
 299:tmk_core/common/action.c ****                     } else {
 300:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 301:tmk_core/common/action.c ****                             unregister_mods(mods);
 302:tmk_core/common/action.c ****                         }
 303:tmk_core/common/action.c ****                     }
 304:tmk_core/common/action.c ****                     break;
 305:tmk_core/common/action.c ****                 default:
 306:tmk_core/common/action.c ****                     if (event.pressed) {
 307:tmk_core/common/action.c ****                         if (tap_count > 0) {
 308:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 309:tmk_core/common/action.c ****                             if (record->tap.interrupted) {
 310:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 311:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 312:tmk_core/common/action.c ****                                 record->tap.count = 0;
 313:tmk_core/common/action.c ****                                 register_mods(mods);
 314:tmk_core/common/action.c ****                             } else
 315:tmk_core/common/action.c **** #    endif
 316:tmk_core/common/action.c ****                             {
 317:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 318:tmk_core/common/action.c ****                                 register_code(action.key.code);
 319:tmk_core/common/action.c ****                             }
 320:tmk_core/common/action.c ****                         } else {
 321:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c ****                         }
 324:tmk_core/common/action.c ****                     } else {
 325:tmk_core/common/action.c ****                         if (tap_count > 0) {
 326:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 327:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 328:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 329:tmk_core/common/action.c ****                             }
 330:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 331:tmk_core/common/action.c ****                         } else {
 332:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 333:tmk_core/common/action.c ****                             unregister_mods(mods);
 334:tmk_core/common/action.c ****                         }
 335:tmk_core/common/action.c ****                     }
 336:tmk_core/common/action.c ****                     break;
 337:tmk_core/common/action.c ****             }
 338:tmk_core/common/action.c ****         } break;
 339:tmk_core/common/action.c **** #endif
 340:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 341:tmk_core/common/action.c ****         /* other HID usage */
 342:tmk_core/common/action.c ****         case ACT_USAGE:
 343:tmk_core/common/action.c ****             switch (action.usage.page) {
 344:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 345:tmk_core/common/action.c ****                     if (event.pressed) {
 346:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 347:tmk_core/common/action.c ****                     } else {
 348:tmk_core/common/action.c ****                         host_system_send(0);
 349:tmk_core/common/action.c ****                     }
 350:tmk_core/common/action.c ****                     break;
 351:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 352:tmk_core/common/action.c ****                     if (event.pressed) {
 353:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         host_consumer_send(0);
 356:tmk_core/common/action.c ****                     }
 357:tmk_core/common/action.c ****                     break;
 358:tmk_core/common/action.c ****             }
 359:tmk_core/common/action.c ****             break;
 360:tmk_core/common/action.c **** #endif
 361:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 362:tmk_core/common/action.c ****         /* Mouse key */
 363:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 364:tmk_core/common/action.c ****             if (event.pressed) {
 365:tmk_core/common/action.c ****                 switch (action.key.code) {
 366:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 367:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 368:tmk_core/common/action.c ****                         break;
 369:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 370:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 371:tmk_core/common/action.c ****                         break;
 372:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 373:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 374:tmk_core/common/action.c ****                         break;
 375:tmk_core/common/action.c ****                     default:
 376:tmk_core/common/action.c ****                         break;
 377:tmk_core/common/action.c ****                 }
 378:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 379:tmk_core/common/action.c ****                 mousekey_send();
 380:tmk_core/common/action.c ****             } else {
 381:tmk_core/common/action.c ****                 switch (action.key.code) {
 382:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 383:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 384:tmk_core/common/action.c ****                         break;
 385:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 386:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 389:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 390:tmk_core/common/action.c ****                         break;
 391:tmk_core/common/action.c ****                     default:
 392:tmk_core/common/action.c ****                         break;
 393:tmk_core/common/action.c ****                 }
 394:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 395:tmk_core/common/action.c ****                 mousekey_send();
 396:tmk_core/common/action.c ****             }
 397:tmk_core/common/action.c ****             break;
 398:tmk_core/common/action.c **** #endif
 399:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 400:tmk_core/common/action.c ****         case ACT_LAYER:
 401:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 403:tmk_core/common/action.c ****                 if (!event.pressed) {
 404:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 405:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 406:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 408:tmk_core/common/action.c ****                         case OP_BIT_AND:
 409:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 410:tmk_core/common/action.c ****                             break;
 411:tmk_core/common/action.c ****                         case OP_BIT_OR:
 412:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 413:tmk_core/common/action.c ****                             break;
 414:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 415:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 416:tmk_core/common/action.c ****                             break;
 417:tmk_core/common/action.c ****                         case OP_BIT_SET:
 418:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 419:tmk_core/common/action.c ****                             break;
 420:tmk_core/common/action.c ****                     }
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 424:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 425:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 426:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 427:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 428:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 429:tmk_core/common/action.c ****                         case OP_BIT_AND:
 430:tmk_core/common/action.c ****                             layer_and(bits | mask);
 431:tmk_core/common/action.c ****                             break;
 432:tmk_core/common/action.c ****                         case OP_BIT_OR:
 433:tmk_core/common/action.c ****                             layer_or(bits | mask);
 434:tmk_core/common/action.c ****                             break;
 435:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 436:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 437:tmk_core/common/action.c ****                             break;
 438:tmk_core/common/action.c ****                         case OP_BIT_SET:
 439:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 440:tmk_core/common/action.c ****                             break;
 441:tmk_core/common/action.c ****                     }
 442:tmk_core/common/action.c ****                 }
 443:tmk_core/common/action.c ****             }
 444:tmk_core/common/action.c ****             break;
 445:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 446:tmk_core/common/action.c ****             if (event.pressed) {
 447:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 448:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 449:tmk_core/common/action.c ****             } else {
 450:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 451:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 452:tmk_core/common/action.c ****             }
 453:tmk_core/common/action.c ****             break;
 454:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 455:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 456:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 457:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 458:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 459:tmk_core/common/action.c ****                     /* tap toggle */
 460:tmk_core/common/action.c ****                     if (event.pressed) {
 461:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 462:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 463:tmk_core/common/action.c ****                         }
 464:tmk_core/common/action.c ****                     } else {
 465:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 466:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 467:tmk_core/common/action.c ****                         }
 468:tmk_core/common/action.c ****                     }
 469:tmk_core/common/action.c ****                     break;
 470:tmk_core/common/action.c ****                 case OP_ON_OFF:
 471:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_OFF_ON:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 475:tmk_core/common/action.c ****                     break;
 476:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 477:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 478:tmk_core/common/action.c ****                     break;
 479:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 480:tmk_core/common/action.c ****                 case OP_ONESHOT:
 481:tmk_core/common/action.c ****                     // Oneshot modifier
 482:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 483:tmk_core/common/action.c ****                     do_release_oneshot = false;
 484:tmk_core/common/action.c ****                     if (event.pressed) {
 485:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 486:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 487:tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 489:tmk_core/common/action.c ****                             break;
 490:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 491:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 492:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 493:tmk_core/common/action.c ****                         }
 494:tmk_core/common/action.c ****                     } else {
 495:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 496:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 497:tmk_core/common/action.c ****                             reset_oneshot_layer();
 498:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 499:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 500:tmk_core/common/action.c ****                         } else {
 501:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 502:tmk_core/common/action.c ****                         }
 503:tmk_core/common/action.c ****                     }
 504:tmk_core/common/action.c **** #            else
 505:tmk_core/common/action.c ****                     if (event.pressed) {
 506:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 510:tmk_core/common/action.c ****                         if (tap_count > 1) {
 511:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 512:tmk_core/common/action.c ****                         }
 513:tmk_core/common/action.c ****                     }
 514:tmk_core/common/action.c **** #            endif
 515:tmk_core/common/action.c ****                     break;
 516:tmk_core/common/action.c **** #        endif
 517:tmk_core/common/action.c ****                 default:
 518:tmk_core/common/action.c ****                     /* tap key */
 519:tmk_core/common/action.c ****                     if (event.pressed) {
 520:tmk_core/common/action.c ****                         if (tap_count > 0) {
 521:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 522:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 523:tmk_core/common/action.c ****                         } else {
 524:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 525:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 526:tmk_core/common/action.c ****                         }
 527:tmk_core/common/action.c ****                     } else {
 528:tmk_core/common/action.c ****                         if (tap_count > 0) {
 529:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 530:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 531:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 532:tmk_core/common/action.c ****                             } else {
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 534:tmk_core/common/action.c ****                             }
 535:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 536:tmk_core/common/action.c ****                         } else {
 537:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 538:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 539:tmk_core/common/action.c ****                         }
 540:tmk_core/common/action.c ****                     }
 541:tmk_core/common/action.c ****                     break;
 542:tmk_core/common/action.c ****             }
 543:tmk_core/common/action.c ****             break;
 544:tmk_core/common/action.c **** #    endif
 545:tmk_core/common/action.c **** #endif
 546:tmk_core/common/action.c ****             /* Extentions */
 547:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 548:tmk_core/common/action.c ****         case ACT_MACRO:
 549:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 550:tmk_core/common/action.c ****             break;
 551:tmk_core/common/action.c **** #endif
 552:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 553:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 554:tmk_core/common/action.c ****             if (!event.pressed) {
 555:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 556:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 557:tmk_core/common/action.c ****                         backlight_increase();
 558:tmk_core/common/action.c ****                         break;
 559:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 560:tmk_core/common/action.c ****                         backlight_decrease();
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 563:tmk_core/common/action.c ****                         backlight_toggle();
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 566:tmk_core/common/action.c ****                         backlight_step();
 567:tmk_core/common/action.c ****                         break;
 568:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 569:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 570:tmk_core/common/action.c ****                         break;
 571:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 572:tmk_core/common/action.c ****                         backlight_level(0);
 573:tmk_core/common/action.c ****                         break;
 574:tmk_core/common/action.c ****                 }
 575:tmk_core/common/action.c ****             }
 576:tmk_core/common/action.c ****             break;
 577:tmk_core/common/action.c **** #endif
 578:tmk_core/common/action.c ****         case ACT_COMMAND:
 579:tmk_core/common/action.c ****             break;
 580:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 581:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 582:tmk_core/common/action.c ****             switch (action.swap.code) {
 583:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 584:tmk_core/common/action.c ****                     if (event.pressed) {
 585:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 586:tmk_core/common/action.c ****                     }
 587:tmk_core/common/action.c ****                     break;
 588:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 589:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 592:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_ON:
 595:tmk_core/common/action.c ****                     if (!event.pressed) {
 596:tmk_core/common/action.c ****                         swap_hands = true;
 597:tmk_core/common/action.c ****                     }
 598:tmk_core/common/action.c ****                     break;
 599:tmk_core/common/action.c ****                 case OP_SH_OFF:
 600:tmk_core/common/action.c ****                     if (!event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = false;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 605:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 606:tmk_core/common/action.c ****                     /* tap toggle */
 607:tmk_core/common/action.c **** 
 608:tmk_core/common/action.c ****                     if (event.pressed) {
 609:tmk_core/common/action.c ****                         if (swap_held) {
 610:tmk_core/common/action.c ****                             swap_held = false;
 611:tmk_core/common/action.c ****                         } else {
 612:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 613:tmk_core/common/action.c ****                         }
 614:tmk_core/common/action.c ****                     } else {
 615:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 616:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 617:tmk_core/common/action.c ****                         }
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c ****                 default:
 621:tmk_core/common/action.c ****                     /* tap key */
 622:tmk_core/common/action.c ****                     if (tap_count > 0) {
 623:tmk_core/common/action.c ****                         if (swap_held) {
 624:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 625:tmk_core/common/action.c ****                             swap_held  = false;
 626:tmk_core/common/action.c ****                         }
 627:tmk_core/common/action.c ****                         if (event.pressed) {
 628:tmk_core/common/action.c ****                             register_code(action.swap.code);
 629:tmk_core/common/action.c ****                         } else {
 630:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 631:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 632:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 633:tmk_core/common/action.c ****                         }
 634:tmk_core/common/action.c ****                     } else {
 635:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 636:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 637:tmk_core/common/action.c ****                             swap_held  = false;
 638:tmk_core/common/action.c ****                         }
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c **** #    endif
 641:tmk_core/common/action.c ****             }
 642:tmk_core/common/action.c **** #endif
 643:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 644:tmk_core/common/action.c ****         case ACT_FUNCTION:
 645:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 646:tmk_core/common/action.c ****             break;
 647:tmk_core/common/action.c **** #endif
 648:tmk_core/common/action.c ****         default:
 649:tmk_core/common/action.c ****             break;
 650:tmk_core/common/action.c ****     }
 651:tmk_core/common/action.c **** 
 652:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 653:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 654:tmk_core/common/action.c ****     switch (action.kind.id) {
 655:tmk_core/common/action.c ****         case ACT_LAYER:
 656:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 658:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 659:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 660:tmk_core/common/action.c **** #    endif
 661:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c ****         default:
 664:tmk_core/common/action.c ****             break;
 665:tmk_core/common/action.c ****     }
 666:tmk_core/common/action.c **** #endif
 667:tmk_core/common/action.c **** 
 668:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 669:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 670:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 671:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 672:tmk_core/common/action.c ****     } else {
 673:tmk_core/common/action.c ****         if (event.pressed) {
 674:tmk_core/common/action.c ****             if (tap_count > 0) {
 675:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 676:tmk_core/common/action.c ****             } else {
 677:tmk_core/common/action.c ****             }
 678:tmk_core/common/action.c ****         } else {
 679:tmk_core/common/action.c ****             if (tap_count > 0) {
 680:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 681:tmk_core/common/action.c ****             } else {
 682:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 683:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 684:tmk_core/common/action.c ****                 }
 685:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 686:tmk_core/common/action.c ****             }
 687:tmk_core/common/action.c ****         }
 688:tmk_core/common/action.c ****     }
 689:tmk_core/common/action.c **** #    endif
 690:tmk_core/common/action.c **** #endif
 691:tmk_core/common/action.c **** 
 692:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 693:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 694:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 695:tmk_core/common/action.c ****      */
 696:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 697:tmk_core/common/action.c ****         record->event.pressed = false;
 698:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 699:tmk_core/common/action.c ****         process_record(record);
 700:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 701:tmk_core/common/action.c ****     }
 702:tmk_core/common/action.c **** #endif
 703:tmk_core/common/action.c **** }
 704:tmk_core/common/action.c **** 
 705:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 706:tmk_core/common/action.c ****  *
 707:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 708:tmk_core/common/action.c ****  */
 709:tmk_core/common/action.c **** void register_code(uint8_t code) {
 133               		.loc 1 709 0
 134               		.cfi_startproc
 135               	.LVL9:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 710:tmk_core/common/action.c ****     if (code == KC_NO) {
 140               		.loc 1 710 0
 141 0000 8823      		tst r24
 142 0002 01F4      		brne .+2
 143 0004 00C0      		rjmp .L4
 711:tmk_core/common/action.c ****         return;
 712:tmk_core/common/action.c ****     }
 713:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 714:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 715:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 716:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 717:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 718:tmk_core/common/action.c **** #    endif
 719:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 720:tmk_core/common/action.c ****         send_keyboard_report();
 721:tmk_core/common/action.c ****         wait_ms(100);
 722:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 723:tmk_core/common/action.c ****         send_keyboard_report();
 724:tmk_core/common/action.c ****     }
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 727:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 728:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 729:tmk_core/common/action.c **** #    endif
 730:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 731:tmk_core/common/action.c ****         send_keyboard_report();
 732:tmk_core/common/action.c ****         wait_ms(100);
 733:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** 
 737:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 738:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 739:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 740:tmk_core/common/action.c **** #    endif
 741:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 742:tmk_core/common/action.c ****         send_keyboard_report();
 743:tmk_core/common/action.c ****         wait_ms(100);
 744:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 745:tmk_core/common/action.c ****         send_keyboard_report();
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #endif
 748:tmk_core/common/action.c **** 
 749:tmk_core/common/action.c ****     else if
 750:tmk_core/common/action.c ****         IS_KEY(code) {
 144               		.loc 1 750 0
 145 0006 9CEF      		ldi r25,lo8(-4)
 146 0008 980F      		add r25,r24
 147 000a 913A      		cpi r25,lo8(-95)
 148 000c 00F4      		brsh .L6
 751:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 752:tmk_core/common/action.c ****             if (command_proc(code)) return;
 753:tmk_core/common/action.c **** 
 754:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 755:tmk_core/common/action.c **** /* TODO: remove
 756:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 757:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 758:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****             add_key(code);
 761:tmk_core/common/action.c ****             send_keyboard_report();
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             set_mods(tmp_mods);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c ****             oneshot_cancel();
 766:tmk_core/common/action.c ****         } else
 767:tmk_core/common/action.c **** */
 768:tmk_core/common/action.c **** #endif
 769:tmk_core/common/action.c ****             {
 770:tmk_core/common/action.c ****                 add_key(code);
 149               		.loc 1 770 0
 150 000e 0E94 0000 		call add_key
 151               	.LVL10:
 152               	.L39:
 771:tmk_core/common/action.c ****                 send_keyboard_report();
 772:tmk_core/common/action.c ****             }
 773:tmk_core/common/action.c ****         }
 774:tmk_core/common/action.c ****     else if
 775:tmk_core/common/action.c ****         IS_MOD(code) {
 776:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 777:tmk_core/common/action.c ****             send_keyboard_report();
 153               		.loc 1 777 0
 154 0012 0C94 0000 		jmp send_keyboard_report
 155               	.LVL11:
 156               	.L6:
 775:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 157               		.loc 1 775 0
 158 0016 90E2      		ldi r25,lo8(32)
 159 0018 980F      		add r25,r24
 160 001a 9830      		cpi r25,lo8(8)
 161 001c 00F4      		brsh .L7
 776:tmk_core/common/action.c ****             send_keyboard_report();
 162               		.loc 1 776 0
 163 001e 8770      		andi r24,lo8(7)
 164               	.LVL12:
 165 0020 91E0      		ldi r25,lo8(1)
 166 0022 00C0      		rjmp 2f
 167               		1:
 168 0024 990F      		lsl r25
 169               		2:
 170 0026 8A95      		dec r24
 171 0028 02F4      		brpl 1b
 172 002a 892F      		mov r24,r25
 173 002c 0E94 0000 		call add_mods
 174               	.LVL13:
 175 0030 00C0      		rjmp .L39
 176               	.LVL14:
 177               	.L7:
 778:tmk_core/common/action.c ****         }
 779:tmk_core/common/action.c ****     else if
 780:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 178               		.loc 1 780 0
 179 0032 9BE5      		ldi r25,lo8(91)
 180 0034 980F      		add r25,r24
 181 0036 9330      		cpi r25,lo8(3)
 182 0038 00F4      		brsh .L8
 183               		.loc 1 780 0 is_stmt 0 discriminator 1
 184 003a 853A      		cpi r24,lo8(-91)
 185 003c 01F0      		breq .L11
 186               		.loc 1 780 0 discriminator 2
 187 003e 863A      		cpi r24,lo8(-90)
 188 0040 01F0      		breq .L12
 189               		.loc 1 780 0
 190 0042 83E8      		ldi r24,lo8(-125)
 191 0044 90E0      		ldi r25,0
 192               	.LVL15:
 193               	.L9:
 194               		.loc 1 780 0 discriminator 13
 195 0046 0C94 0000 		jmp host_system_send
 196               	.LVL16:
 197               	.L11:
 198               		.loc 1 780 0
 199 004a 81E8      		ldi r24,lo8(-127)
 200 004c 90E0      		ldi r25,0
 201               	.LVL17:
 202 004e 00C0      		rjmp .L9
 203               	.LVL18:
 204               	.L12:
 205 0050 82E8      		ldi r24,lo8(-126)
 206 0052 90E0      		ldi r25,0
 207               	.LVL19:
 208 0054 00C0      		rjmp .L9
 209               	.LVL20:
 210               	.L8:
 781:tmk_core/common/action.c ****     else if
 782:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 211               		.loc 1 782 0 is_stmt 1
 212 0056 98E5      		ldi r25,lo8(88)
 213 0058 980F      		add r25,r24
 214 005a 9731      		cpi r25,lo8(23)
 215 005c 00F0      		brlo .+2
 216 005e 00C0      		rjmp .L4
 217               		.loc 1 782 0 is_stmt 0 discriminator 1
 218 0060 883A      		cpi r24,lo8(-88)
 219 0062 01F4      		brne .+2
 220 0064 00C0      		rjmp .L13
 221               		.loc 1 782 0 discriminator 2
 222 0066 893A      		cpi r24,lo8(-87)
 223 0068 01F4      		brne .+2
 224 006a 00C0      		rjmp .L14
 225               		.loc 1 782 0 discriminator 4
 226 006c 8A3A      		cpi r24,lo8(-86)
 227 006e 01F4      		brne .+2
 228 0070 00C0      		rjmp .L15
 229               		.loc 1 782 0 discriminator 6
 230 0072 8B3A      		cpi r24,lo8(-85)
 231 0074 01F4      		brne .+2
 232 0076 00C0      		rjmp .L16
 233               		.loc 1 782 0 discriminator 8
 234 0078 8C3A      		cpi r24,lo8(-84)
 235 007a 01F4      		brne .+2
 236 007c 00C0      		rjmp .L17
 237               		.loc 1 782 0 discriminator 10
 238 007e 8B3B      		cpi r24,lo8(-69)
 239 0080 01F4      		brne .+2
 240 0082 00C0      		rjmp .L18
 241               		.loc 1 782 0 discriminator 12
 242 0084 8C3B      		cpi r24,lo8(-68)
 243 0086 01F4      		brne .+2
 244 0088 00C0      		rjmp .L19
 245               		.loc 1 782 0 discriminator 14
 246 008a 8D3A      		cpi r24,lo8(-83)
 247 008c 01F4      		brne .+2
 248 008e 00C0      		rjmp .L20
 249               		.loc 1 782 0 discriminator 16
 250 0090 803B      		cpi r24,lo8(-80)
 251 0092 01F4      		brne .+2
 252 0094 00C0      		rjmp .L21
 253               		.loc 1 782 0 discriminator 18
 254 0096 8E3A      		cpi r24,lo8(-82)
 255 0098 01F4      		brne .+2
 256 009a 00C0      		rjmp .L22
 257               		.loc 1 782 0 discriminator 20
 258 009c 8F3A      		cpi r24,lo8(-81)
 259 009e 01F4      		brne .+2
 260 00a0 00C0      		rjmp .L23
 261               		.loc 1 782 0 discriminator 22
 262 00a2 813B      		cpi r24,lo8(-79)
 263 00a4 01F4      		brne .+2
 264 00a6 00C0      		rjmp .L24
 265               		.loc 1 782 0 discriminator 24
 266 00a8 823B      		cpi r24,lo8(-78)
 267 00aa 01F4      		brne .+2
 268 00ac 00C0      		rjmp .L25
 269               		.loc 1 782 0 discriminator 26
 270 00ae 833B      		cpi r24,lo8(-77)
 271 00b0 01F4      		brne .+2
 272 00b2 00C0      		rjmp .L26
 273               		.loc 1 782 0 discriminator 28
 274 00b4 843B      		cpi r24,lo8(-76)
 275 00b6 01F4      		brne .+2
 276 00b8 00C0      		rjmp .L27
 277               		.loc 1 782 0 discriminator 30
 278 00ba 853B      		cpi r24,lo8(-75)
 279 00bc 01F4      		brne .+2
 280 00be 00C0      		rjmp .L28
 281               		.loc 1 782 0 discriminator 32
 282 00c0 863B      		cpi r24,lo8(-74)
 283 00c2 01F4      		brne .+2
 284 00c4 00C0      		rjmp .L29
 285               		.loc 1 782 0 discriminator 34
 286 00c6 873B      		cpi r24,lo8(-73)
 287 00c8 01F4      		brne .+2
 288 00ca 00C0      		rjmp .L30
 289               		.loc 1 782 0 discriminator 36
 290 00cc 883B      		cpi r24,lo8(-72)
 291 00ce 01F4      		brne .+2
 292 00d0 00C0      		rjmp .L31
 293               		.loc 1 782 0 discriminator 38
 294 00d2 893B      		cpi r24,lo8(-71)
 295 00d4 01F4      		brne .+2
 296 00d6 00C0      		rjmp .L32
 297               		.loc 1 782 0 discriminator 40
 298 00d8 8D3B      		cpi r24,lo8(-67)
 299 00da 01F4      		brne .+2
 300 00dc 00C0      		rjmp .L33
 301               		.loc 1 782 0 discriminator 42
 302 00de 8E3B      		cpi r24,lo8(-66)
 303 00e0 01F4      		brne .+2
 304 00e2 00C0      		rjmp .L34
 305               		.loc 1 782 0 discriminator 44
 306 00e4 8A3B      		cpi r24,lo8(-70)
 307 00e6 01F4      		brne .+2
 308 00e8 00C0      		rjmp .L35
 309               		.loc 1 782 0
 310 00ea 90E0      		ldi r25,0
 311 00ec 80E0      		ldi r24,0
 312               	.LVL21:
 313               	.L10:
 314               		.loc 1 782 0 discriminator 93
 315 00ee 0C94 0000 		jmp host_consumer_send
 316               	.LVL22:
 317               	.L13:
 318               		.loc 1 782 0
 319 00f2 82EE      		ldi r24,lo8(-30)
 320 00f4 90E0      		ldi r25,0
 321               	.LVL23:
 322 00f6 00C0      		rjmp .L10
 323               	.LVL24:
 324               	.L14:
 325 00f8 89EE      		ldi r24,lo8(-23)
 326 00fa 90E0      		ldi r25,0
 327               	.LVL25:
 328 00fc 00C0      		rjmp .L10
 329               	.LVL26:
 330               	.L15:
 331 00fe 8AEE      		ldi r24,lo8(-22)
 332 0100 90E0      		ldi r25,0
 333               	.LVL27:
 334 0102 00C0      		rjmp .L10
 335               	.LVL28:
 336               	.L16:
 337 0104 85EB      		ldi r24,lo8(-75)
 338 0106 90E0      		ldi r25,0
 339               	.LVL29:
 340 0108 00C0      		rjmp .L10
 341               	.LVL30:
 342               	.L17:
 343 010a 86EB      		ldi r24,lo8(-74)
 344 010c 90E0      		ldi r25,0
 345               	.LVL31:
 346 010e 00C0      		rjmp .L10
 347               	.LVL32:
 348               	.L18:
 349 0110 83EB      		ldi r24,lo8(-77)
 350 0112 90E0      		ldi r25,0
 351               	.LVL33:
 352 0114 00C0      		rjmp .L10
 353               	.LVL34:
 354               	.L19:
 355 0116 84EB      		ldi r24,lo8(-76)
 356 0118 90E0      		ldi r25,0
 357               	.LVL35:
 358 011a 00C0      		rjmp .L10
 359               	.LVL36:
 360               	.L20:
 361 011c 87EB      		ldi r24,lo8(-73)
 362 011e 90E0      		ldi r25,0
 363               	.LVL37:
 364 0120 00C0      		rjmp .L10
 365               	.LVL38:
 366               	.L21:
 367 0122 8CEC      		ldi r24,lo8(-52)
 368 0124 90E0      		ldi r25,0
 369               	.LVL39:
 370 0126 00C0      		rjmp .L10
 371               	.LVL40:
 372               	.L22:
 373 0128 8DEC      		ldi r24,lo8(-51)
 374 012a 90E0      		ldi r25,0
 375               	.LVL41:
 376 012c 00C0      		rjmp .L10
 377               	.LVL42:
 378               	.L23:
 379 012e 83E8      		ldi r24,lo8(-125)
 380 0130 91E0      		ldi r25,lo8(1)
 381               	.LVL43:
 382 0132 00C0      		rjmp .L10
 383               	.LVL44:
 384               	.L24:
 385 0134 8AE8      		ldi r24,lo8(-118)
 386 0136 91E0      		ldi r25,lo8(1)
 387               	.LVL45:
 388 0138 00C0      		rjmp .L10
 389               	.LVL46:
 390               	.L25:
 391 013a 82E9      		ldi r24,lo8(-110)
 392 013c 91E0      		ldi r25,lo8(1)
 393               	.LVL47:
 394 013e 00C0      		rjmp .L10
 395               	.LVL48:
 396               	.L26:
 397 0140 84E9      		ldi r24,lo8(-108)
 398 0142 91E0      		ldi r25,lo8(1)
 399               	.LVL49:
 400 0144 00C0      		rjmp .L10
 401               	.LVL50:
 402               	.L27:
 403 0146 81E2      		ldi r24,lo8(33)
 404 0148 92E0      		ldi r25,lo8(2)
 405               	.LVL51:
 406 014a 00C0      		rjmp .L10
 407               	.LVL52:
 408               	.L28:
 409 014c 83E2      		ldi r24,lo8(35)
 410 014e 92E0      		ldi r25,lo8(2)
 411               	.LVL53:
 412 0150 00C0      		rjmp .L10
 413               	.LVL54:
 414               	.L29:
 415 0152 84E2      		ldi r24,lo8(36)
 416 0154 92E0      		ldi r25,lo8(2)
 417               	.LVL55:
 418 0156 00C0      		rjmp .L10
 419               	.LVL56:
 420               	.L30:
 421 0158 85E2      		ldi r24,lo8(37)
 422 015a 92E0      		ldi r25,lo8(2)
 423               	.LVL57:
 424 015c 00C0      		rjmp .L10
 425               	.LVL58:
 426               	.L31:
 427 015e 86E2      		ldi r24,lo8(38)
 428 0160 92E0      		ldi r25,lo8(2)
 429               	.LVL59:
 430 0162 00C0      		rjmp .L10
 431               	.LVL60:
 432               	.L32:
 433 0164 87E2      		ldi r24,lo8(39)
 434 0166 92E0      		ldi r25,lo8(2)
 435               	.LVL61:
 436 0168 00C0      		rjmp .L10
 437               	.LVL62:
 438               	.L33:
 439 016a 8FE6      		ldi r24,lo8(111)
 440 016c 90E0      		ldi r25,0
 441               	.LVL63:
 442 016e 00C0      		rjmp .L10
 443               	.LVL64:
 444               	.L34:
 445 0170 80E7      		ldi r24,lo8(112)
 446 0172 90E0      		ldi r25,0
 447               	.LVL65:
 448 0174 00C0      		rjmp .L10
 449               	.LVL66:
 450               	.L35:
 451 0176 8AE2      		ldi r24,lo8(42)
 452 0178 92E0      		ldi r25,lo8(2)
 453               	.LVL67:
 454 017a 00C0      		rjmp .L10
 455               	.LVL68:
 456               	.L4:
 457               	/* epilogue start */
 783:tmk_core/common/action.c **** 
 784:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 785:tmk_core/common/action.c ****     else if
 786:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 787:tmk_core/common/action.c ****             mousekey_on(code);
 788:tmk_core/common/action.c ****             mousekey_send();
 789:tmk_core/common/action.c ****         }
 790:tmk_core/common/action.c **** #endif
 791:tmk_core/common/action.c **** }
 458               		.loc 1 791 0 is_stmt 1
 459 017c 0895      		ret
 460               		.cfi_endproc
 461               	.LFE19:
 463               		.section	.text.unregister_code,"ax",@progbits
 464               	.global	unregister_code
 466               	unregister_code:
 467               	.LFB20:
 792:tmk_core/common/action.c **** 
 793:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 794:tmk_core/common/action.c ****  *
 795:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 796:tmk_core/common/action.c ****  */
 797:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 468               		.loc 1 797 0
 469               		.cfi_startproc
 470               	.LVL69:
 471               	/* prologue: function */
 472               	/* frame size = 0 */
 473               	/* stack size = 0 */
 474               	.L__stack_usage = 0
 798:tmk_core/common/action.c ****     if (code == KC_NO) {
 475               		.loc 1 798 0
 476 0000 8823      		tst r24
 477 0002 01F0      		breq .L40
 799:tmk_core/common/action.c ****         return;
 800:tmk_core/common/action.c ****     }
 801:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 802:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 803:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 804:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 805:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 806:tmk_core/common/action.c **** #    endif
 807:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 810:tmk_core/common/action.c ****         send_keyboard_report();
 811:tmk_core/common/action.c ****     }
 812:tmk_core/common/action.c **** 
 813:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 814:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 815:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 816:tmk_core/common/action.c **** #    endif
 817:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 818:tmk_core/common/action.c ****         send_keyboard_report();
 819:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 820:tmk_core/common/action.c ****         send_keyboard_report();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 824:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 825:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 826:tmk_core/common/action.c **** #    endif
 827:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 828:tmk_core/common/action.c ****         send_keyboard_report();
 829:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 830:tmk_core/common/action.c ****         send_keyboard_report();
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****     else if
 835:tmk_core/common/action.c ****         IS_KEY(code) {
 478               		.loc 1 835 0
 479 0004 9CEF      		ldi r25,lo8(-4)
 480 0006 980F      		add r25,r24
 481 0008 913A      		cpi r25,lo8(-95)
 482 000a 00F4      		brsh .L42
 836:tmk_core/common/action.c ****             del_key(code);
 483               		.loc 1 836 0
 484 000c 0E94 0000 		call del_key
 485               	.LVL70:
 486               	.L48:
 837:tmk_core/common/action.c ****             send_keyboard_report();
 838:tmk_core/common/action.c ****         }
 839:tmk_core/common/action.c ****     else if
 840:tmk_core/common/action.c ****         IS_MOD(code) {
 841:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 842:tmk_core/common/action.c ****             send_keyboard_report();
 487               		.loc 1 842 0
 488 0010 0C94 0000 		jmp send_keyboard_report
 489               	.LVL71:
 490               	.L42:
 840:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 491               		.loc 1 840 0
 492 0014 90E2      		ldi r25,lo8(32)
 493 0016 980F      		add r25,r24
 494 0018 9830      		cpi r25,lo8(8)
 495 001a 00F4      		brsh .L43
 841:tmk_core/common/action.c ****             send_keyboard_report();
 496               		.loc 1 841 0
 497 001c 8770      		andi r24,lo8(7)
 498               	.LVL72:
 499 001e 91E0      		ldi r25,lo8(1)
 500 0020 00C0      		rjmp 2f
 501               		1:
 502 0022 990F      		lsl r25
 503               		2:
 504 0024 8A95      		dec r24
 505 0026 02F4      		brpl 1b
 506 0028 892F      		mov r24,r25
 507 002a 0E94 0000 		call del_mods
 508               	.LVL73:
 509 002e 00C0      		rjmp .L48
 510               	.LVL74:
 511               	.L43:
 843:tmk_core/common/action.c ****         }
 844:tmk_core/common/action.c ****     else if
 845:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 512               		.loc 1 845 0
 513 0030 9BE5      		ldi r25,lo8(91)
 514 0032 980F      		add r25,r24
 515 0034 9330      		cpi r25,lo8(3)
 516 0036 00F4      		brsh .L44
 517               		.loc 1 845 0 is_stmt 0 discriminator 1
 518 0038 90E0      		ldi r25,0
 519 003a 80E0      		ldi r24,0
 520               	.LVL75:
 521 003c 0C94 0000 		jmp host_system_send
 522               	.LVL76:
 523               	.L44:
 846:tmk_core/common/action.c ****     else if
 847:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 524               		.loc 1 847 0 is_stmt 1
 525 0040 885A      		subi r24,lo8(-(88))
 526               	.LVL77:
 527 0042 8731      		cpi r24,lo8(23)
 528 0044 00F4      		brsh .L40
 529               		.loc 1 847 0 is_stmt 0 discriminator 1
 530 0046 90E0      		ldi r25,0
 531 0048 80E0      		ldi r24,0
 532               	.LVL78:
 533 004a 0C94 0000 		jmp host_consumer_send
 534               	.LVL79:
 535               	.L40:
 536               	/* epilogue start */
 848:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 849:tmk_core/common/action.c ****     else if
 850:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 851:tmk_core/common/action.c ****             mousekey_off(code);
 852:tmk_core/common/action.c ****             mousekey_send();
 853:tmk_core/common/action.c ****         }
 854:tmk_core/common/action.c **** #endif
 855:tmk_core/common/action.c **** }
 537               		.loc 1 855 0 is_stmt 1
 538 004e 0895      		ret
 539               		.cfi_endproc
 540               	.LFE20:
 542               		.section	.text.tap_code,"ax",@progbits
 543               	.global	tap_code
 545               	tap_code:
 546               	.LFB21:
 856:tmk_core/common/action.c **** 
 857:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 858:tmk_core/common/action.c ****  *
 859:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 860:tmk_core/common/action.c ****  */
 861:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 547               		.loc 1 861 0
 548               		.cfi_startproc
 549               	.LVL80:
 550 0000 CF93      		push r28
 551               	.LCFI4:
 552               		.cfi_def_cfa_offset 3
 553               		.cfi_offset 28, -2
 554               	/* prologue: function */
 555               	/* frame size = 0 */
 556               	/* stack size = 1 */
 557               	.L__stack_usage = 1
 558 0002 C82F      		mov r28,r24
 862:tmk_core/common/action.c ****     register_code(code);
 559               		.loc 1 862 0
 560 0004 0E94 0000 		call register_code
 561               	.LVL81:
 863:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 562               		.loc 1 863 0
 563 0008 C933      		cpi r28,lo8(57)
 564 000a 01F4      		brne .L51
 565               	.LVL82:
 566               	.LBB16:
 567               	.LBB17:
 568               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 569               		.loc 2 187 0
 570 000c 2FEF      		ldi r18,lo8(255999)
 571 000e 87EE      		ldi r24,hi8(255999)
 572 0010 93E0      		ldi r25,hlo8(255999)
 573 0012 2150      	1:	subi r18,1
 574 0014 8040      		sbci r24,0
 575 0016 9040      		sbci r25,0
 576 0018 01F4      		brne 1b
 577 001a 00C0      		rjmp .
 578 001c 0000      		nop
 579               	.LVL83:
 580               	.L51:
 581               	.LBE17:
 582               	.LBE16:
 864:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 865:tmk_core/common/action.c ****     } else {
 866:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 867:tmk_core/common/action.c ****     }
 868:tmk_core/common/action.c ****     unregister_code(code);
 583               		.loc 1 868 0
 584 001e 8C2F      		mov r24,r28
 585               	/* epilogue start */
 869:tmk_core/common/action.c **** }
 586               		.loc 1 869 0
 587 0020 CF91      		pop r28
 588               	.LVL84:
 868:tmk_core/common/action.c **** }
 589               		.loc 1 868 0
 590 0022 0C94 0000 		jmp unregister_code
 591               	.LVL85:
 592               		.cfi_endproc
 593               	.LFE21:
 595               		.section	.text.register_mods,"ax",@progbits
 596               	.global	register_mods
 598               	register_mods:
 599               	.LFB22:
 870:tmk_core/common/action.c **** 
 871:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:tmk_core/common/action.c ****  *
 873:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:tmk_core/common/action.c ****  */
 875:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 600               		.loc 1 875 0
 601               		.cfi_startproc
 602               	.LVL86:
 603               	/* prologue: function */
 604               	/* frame size = 0 */
 605               	/* stack size = 0 */
 606               	.L__stack_usage = 0
 876:tmk_core/common/action.c ****     if (mods) {
 607               		.loc 1 876 0
 608 0000 8823      		tst r24
 609 0002 01F0      		breq .L52
 877:tmk_core/common/action.c ****         add_mods(mods);
 610               		.loc 1 877 0
 611 0004 0E94 0000 		call add_mods
 612               	.LVL87:
 878:tmk_core/common/action.c ****         send_keyboard_report();
 613               		.loc 1 878 0
 614 0008 0C94 0000 		jmp send_keyboard_report
 615               	.LVL88:
 616               	.L52:
 617               	/* epilogue start */
 879:tmk_core/common/action.c ****     }
 880:tmk_core/common/action.c **** }
 618               		.loc 1 880 0
 619 000c 0895      		ret
 620               		.cfi_endproc
 621               	.LFE22:
 623               		.section	.text.unregister_mods,"ax",@progbits
 624               	.global	unregister_mods
 626               	unregister_mods:
 627               	.LFB23:
 881:tmk_core/common/action.c **** 
 882:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 883:tmk_core/common/action.c ****  *
 884:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 885:tmk_core/common/action.c ****  */
 886:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 628               		.loc 1 886 0
 629               		.cfi_startproc
 630               	.LVL89:
 631               	/* prologue: function */
 632               	/* frame size = 0 */
 633               	/* stack size = 0 */
 634               	.L__stack_usage = 0
 887:tmk_core/common/action.c ****     if (mods) {
 635               		.loc 1 887 0
 636 0000 8823      		tst r24
 637 0002 01F0      		breq .L54
 888:tmk_core/common/action.c ****         del_mods(mods);
 638               		.loc 1 888 0
 639 0004 0E94 0000 		call del_mods
 640               	.LVL90:
 889:tmk_core/common/action.c ****         send_keyboard_report();
 641               		.loc 1 889 0
 642 0008 0C94 0000 		jmp send_keyboard_report
 643               	.LVL91:
 644               	.L54:
 645               	/* epilogue start */
 890:tmk_core/common/action.c ****     }
 891:tmk_core/common/action.c **** }
 646               		.loc 1 891 0
 647 000c 0895      		ret
 648               		.cfi_endproc
 649               	.LFE23:
 651               		.section	.text.process_action,"ax",@progbits
 652               	.global	process_action
 654               	process_action:
 655               	.LFB18:
 197:tmk_core/common/action.c ****     keyevent_t event = record->event;
 656               		.loc 1 197 0
 657               		.cfi_startproc
 658               	.LVL92:
 659 0000 CF92      		push r12
 660               	.LCFI5:
 661               		.cfi_def_cfa_offset 3
 662               		.cfi_offset 12, -2
 663 0002 DF92      		push r13
 664               	.LCFI6:
 665               		.cfi_def_cfa_offset 4
 666               		.cfi_offset 13, -3
 667 0004 EF92      		push r14
 668               	.LCFI7:
 669               		.cfi_def_cfa_offset 5
 670               		.cfi_offset 14, -4
 671 0006 FF92      		push r15
 672               	.LCFI8:
 673               		.cfi_def_cfa_offset 6
 674               		.cfi_offset 15, -5
 675 0008 0F93      		push r16
 676               	.LCFI9:
 677               		.cfi_def_cfa_offset 7
 678               		.cfi_offset 16, -6
 679 000a 1F93      		push r17
 680               	.LCFI10:
 681               		.cfi_def_cfa_offset 8
 682               		.cfi_offset 17, -7
 683 000c CF93      		push r28
 684               	.LCFI11:
 685               		.cfi_def_cfa_offset 9
 686               		.cfi_offset 28, -8
 687 000e DF93      		push r29
 688               	.LCFI12:
 689               		.cfi_def_cfa_offset 10
 690               		.cfi_offset 29, -9
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 8 */
 694               	.L__stack_usage = 8
 695 0010 6C01      		movw r12,r24
 696 0012 D62F      		mov r29,r22
 697 0014 C72F      		mov r28,r23
 698               	.LVL93:
 200:tmk_core/common/action.c **** #endif
 699               		.loc 1 200 0
 700 0016 FC01      		movw r30,r24
 701 0018 1581      		ldd r17,Z+5
 702 001a 1295      		swap r17
 703 001c 1F70      		andi r17,lo8(15)
 704               	.LVL94:
 203:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 705               		.loc 1 203 0
 706 001e 0281      		ldd r16,Z+2
 707 0020 0111      		cpse r16,__zero_reg__
 205:tmk_core/common/action.c ****     }
 708               		.loc 1 205 0
 709 0022 0E94 0000 		call clear_weak_mods
 710               	.LVL95:
 711               	.L57:
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 712               		.loc 1 211 0
 713 0026 0E94 0000 		call is_oneshot_layer_active
 714               	.LVL96:
 715 002a E82E      		mov r14,r24
 716 002c 8823      		tst r24
 717 002e 01F0      		breq .L58
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 718               		.loc 1 211 0 is_stmt 0 discriminator 1
 719 0030 0023      		tst r16
 720 0032 01F0      		breq .L130
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 721               		.loc 1 211 0 discriminator 2
 722 0034 80E2      		ldi r24,lo8(32)
 723 0036 8D0F      		add r24,r29
 724 0038 8830      		cpi r24,lo8(8)
 725 003a 00F0      		brlo .L130
 212:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 726               		.loc 1 212 0 is_stmt 1
 727 003c 82E0      		ldi r24,lo8(2)
 728 003e 0E94 0000 		call clear_oneshot_layer_state
 729               	.LVL97:
 213:tmk_core/common/action.c ****     }
 730               		.loc 1 213 0
 731 0042 0E94 0000 		call is_oneshot_layer_active
 732               	.LVL98:
 733 0046 91E0      		ldi r25,lo8(1)
 734 0048 E82E      		mov r14,r24
 735 004a E926      		eor r14,r25
 736               	.LVL99:
 737               	.L58:
 217:tmk_core/common/action.c ****         /* Key and Mods */
 738               		.loc 1 217 0
 739 004c FC2E      		mov r15,r28
 740 004e F294      		swap r15
 741 0050 9FE0      		ldi r25,lo8(15)
 742 0052 F922      		and r15,r25
 743 0054 FBE0      		ldi r31,lo8(11)
 744 0056 FF15      		cp r31,r15
 745 0058 00F4      		brsh .+2
 746 005a 00C0      		rjmp .L59
 747 005c EF2D      		mov r30,r15
 748 005e F0E0      		ldi r31,0
 749 0060 E050      		subi r30,lo8(-(gs(.L61)))
 750 0062 F040      		sbci r31,hi8(-(gs(.L61)))
 751 0064 0C94 0000 		jmp __tablejump2__
 752               		.p2align	1
 753               	.L61:
 754 0068 0000      		.word gs(.L60)
 755 006a 0000      		.word gs(.L60)
 756 006c 0000      		.word gs(.L62)
 757 006e 0000      		.word gs(.L62)
 758 0070 0000      		.word gs(.L59)
 759 0072 0000      		.word gs(.L59)
 760 0074 0000      		.word gs(.L59)
 761 0076 0000      		.word gs(.L59)
 762 0078 0000      		.word gs(.L63)
 763 007a 0000      		.word gs(.L64)
 764 007c 0000      		.word gs(.L65)
 765 007e 0000      		.word gs(.L65)
 766               	.LVL100:
 767               	.L130:
 209:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 768               		.loc 1 209 0
 769 0080 E12C      		mov r14,__zero_reg__
 770 0082 00C0      		rjmp .L58
 771               	.LVL101:
 772               	.L60:
 773 0084 1C2F      		mov r17,r28
 774               	.LVL102:
 775 0086 1F70      		andi r17,lo8(15)
 776               	.LBB18:
 221:tmk_core/common/action.c ****             if (event.pressed) {
 777               		.loc 1 221 0
 778 0088 C07F      		andi r28,lo8(-16)
 779               	.LVL103:
 780 008a 01F0      		breq .L66
 221:tmk_core/common/action.c ****             if (event.pressed) {
 781               		.loc 1 221 0 is_stmt 0 discriminator 2
 782 008c 1295      		swap r17
 783 008e 107F      		andi r17,lo8(-16)
 784               	.L66:
 785               	.LVL104:
 222:tmk_core/common/action.c ****                 if (mods) {
 786               		.loc 1 222 0 is_stmt 1 discriminator 4
 787 0090 0023      		tst r16
 788 0092 01F0      		breq .L67
 223:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 789               		.loc 1 223 0
 790 0094 1123      		tst r17
 791 0096 01F0      		breq .L89
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 792               		.loc 1 224 0
 793 0098 80E2      		ldi r24,lo8(32)
 794 009a 8D0F      		add r24,r29
 795 009c 8830      		cpi r24,lo8(8)
 796 009e 00F0      		brlo .L69
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 797               		.loc 1 224 0 is_stmt 0 discriminator 1
 798 00a0 D111      		cpse r29,__zero_reg__
 799 00a2 00C0      		rjmp .L70
 800               	.L69:
 228:tmk_core/common/action.c ****                     } else {
 801               		.loc 1 228 0 is_stmt 1
 802 00a4 812F      		mov r24,r17
 803 00a6 0E94 0000 		call add_mods
 804               	.LVL105:
 805               	.L71:
 232:tmk_core/common/action.c ****                 }
 806               		.loc 1 232 0
 807 00aa 0E94 0000 		call send_keyboard_report
 808               	.LVL106:
 809               	.L89:
 810               	.LBE18:
 811               	.LBB19:
 318:tmk_core/common/action.c ****                             }
 812               		.loc 1 318 0
 813 00ae 8D2F      		mov r24,r29
 814 00b0 0E94 0000 		call register_code
 815               	.LVL107:
 816 00b4 00C0      		rjmp .L72
 817               	.LVL108:
 818               	.L70:
 819               	.LBE19:
 820               	.LBB22:
 230:tmk_core/common/action.c ****                     }
 821               		.loc 1 230 0
 822 00b6 812F      		mov r24,r17
 823 00b8 0E94 0000 		call add_weak_mods
 824               	.LVL109:
 825 00bc 00C0      		rjmp .L71
 826               	.L67:
 236:tmk_core/common/action.c ****                 if (mods) {
 827               		.loc 1 236 0
 828 00be 8D2F      		mov r24,r29
 829 00c0 0E94 0000 		call unregister_code
 830               	.LVL110:
 237:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 831               		.loc 1 237 0
 832 00c4 1123      		tst r17
 833 00c6 01F0      		breq .L72
 238:tmk_core/common/action.c ****                         del_mods(mods);
 834               		.loc 1 238 0
 835 00c8 80E2      		ldi r24,lo8(32)
 836 00ca 8D0F      		add r24,r29
 837 00cc 8830      		cpi r24,lo8(8)
 838 00ce 00F0      		brlo .L74
 238:tmk_core/common/action.c ****                         del_mods(mods);
 839               		.loc 1 238 0 is_stmt 0 discriminator 1
 840 00d0 D111      		cpse r29,__zero_reg__
 841 00d2 00C0      		rjmp .L75
 842               	.L74:
 239:tmk_core/common/action.c ****                     } else {
 843               		.loc 1 239 0 is_stmt 1
 844 00d4 812F      		mov r24,r17
 845 00d6 0E94 0000 		call del_mods
 846               	.LVL111:
 847               	.L76:
 243:tmk_core/common/action.c ****                 }
 848               		.loc 1 243 0
 849 00da 0E94 0000 		call send_keyboard_report
 850               	.LVL112:
 851               	.L72:
 852               	.LBE22:
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 853               		.loc 1 696 0
 854 00de EE20      		tst r14
 855 00e0 01F4      		brne .+2
 856 00e2 00C0      		rjmp .L56
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 857               		.loc 1 696 0 is_stmt 0 discriminator 1
 858 00e4 0E94 0000 		call get_oneshot_layer_state
 859               	.LVL113:
 860 00e8 80FD      		sbrc r24,0
 861 00ea 00C0      		rjmp .L56
 697:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 862               		.loc 1 697 0 is_stmt 1
 863 00ec F601      		movw r30,r12
 864 00ee 1282      		std Z+2,__zero_reg__
 698:tmk_core/common/action.c ****         process_record(record);
 865               		.loc 1 698 0
 866 00f0 0E94 0000 		call get_oneshot_layer
 867               	.LVL114:
 868 00f4 0E94 0000 		call layer_on
 869               	.LVL115:
 699:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 870               		.loc 1 699 0
 871 00f8 C601      		movw r24,r12
 872 00fa 0E94 0000 		call process_record
 873               	.LVL116:
 700:tmk_core/common/action.c ****     }
 874               		.loc 1 700 0
 875 00fe 0E94 0000 		call get_oneshot_layer
 876               	.LVL117:
 877               	/* epilogue start */
 703:tmk_core/common/action.c **** 
 878               		.loc 1 703 0
 879 0102 DF91      		pop r29
 880               	.LVL118:
 881 0104 CF91      		pop r28
 882 0106 1F91      		pop r17
 883 0108 0F91      		pop r16
 884 010a FF90      		pop r15
 885 010c EF90      		pop r14
 886               	.LVL119:
 887 010e DF90      		pop r13
 888 0110 CF90      		pop r12
 889               	.LVL120:
 700:tmk_core/common/action.c ****     }
 890               		.loc 1 700 0
 891 0112 0C94 0000 		jmp layer_off
 892               	.LVL121:
 893               	.L75:
 894               	.LBB23:
 241:tmk_core/common/action.c ****                     }
 895               		.loc 1 241 0
 896 0116 812F      		mov r24,r17
 897 0118 0E94 0000 		call del_weak_mods
 898               	.LVL122:
 899 011c 00C0      		rjmp .L76
 900               	.LVL123:
 901               	.L62:
 902 011e 2C2F      		mov r18,r28
 903 0120 2F70      		andi r18,lo8(15)
 904 0122 F22E      		mov r15,r18
 905               	.LBE23:
 906               	.LBB24:
 250:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 907               		.loc 1 250 0
 908 0124 C07F      		andi r28,lo8(-16)
 909               	.LVL124:
 910 0126 C032      		cpi r28,lo8(32)
 911 0128 01F0      		breq .L77
 250:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 912               		.loc 1 250 0 is_stmt 0 discriminator 2
 913 012a F294      		swap r15
 914 012c 80EF      		ldi r24,lo8(-16)
 915 012e F822      		and r15,r24
 916               	.L77:
 917               	.LVL125:
 251:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 918               		.loc 1 251 0 is_stmt 1 discriminator 4
 919 0130 DD23      		tst r29
 920 0132 01F0      		breq .L79
 921 0134 D130      		cpi r29,lo8(1)
 922 0136 01F0      		breq .L80
 306:tmk_core/common/action.c ****                         if (tap_count > 0) {
 923               		.loc 1 306 0
 924 0138 0023      		tst r16
 925 013a 01F0      		breq .L87
 307:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 926               		.loc 1 307 0
 927 013c 1123      		tst r17
 928 013e 01F0      		breq .L88
 309:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 929               		.loc 1 309 0
 930 0140 F601      		movw r30,r12
 931 0142 8581      		ldd r24,Z+5
 932 0144 80FF      		sbrs r24,0
 933 0146 00C0      		rjmp .L89
 312:tmk_core/common/action.c ****                                 register_mods(mods);
 934               		.loc 1 312 0
 935 0148 8F70      		andi r24,lo8(15)
 936 014a 8583      		std Z+5,r24
 937 014c 00C0      		rjmp .L88
 938               	.L79:
 255:tmk_core/common/action.c ****                         if (tap_count == 0) {
 939               		.loc 1 255 0
 940 014e 0023      		tst r16
 941 0150 01F0      		breq .L81
 256:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 942               		.loc 1 256 0
 943 0152 1111      		cpse r17,__zero_reg__
 944 0154 00C0      		rjmp .L82
 945               	.L83:
 270:tmk_core/common/action.c ****                         }
 946               		.loc 1 270 0
 947 0156 0E94 0000 		call get_oneshot_mods
 948               	.LVL126:
 949 015a 8F29      		or r24,r15
 950               	.L157:
 322:tmk_core/common/action.c ****                         }
 951               		.loc 1 322 0
 952 015c 0E94 0000 		call register_mods
 953               	.LVL127:
 954 0160 00C0      		rjmp .L72
 955               	.L82:
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 956               		.loc 1 259 0
 957 0162 1130      		cpi r17,lo8(1)
 958 0164 01F4      		brne .L83
 261:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 959               		.loc 1 261 0
 960 0166 0E94 0000 		call get_oneshot_mods
 961               	.LVL128:
 962 016a 8F29      		or r24,r15
 963 016c 0E94 0000 		call set_oneshot_mods
 964               	.LVL129:
 965 0170 00C0      		rjmp .L72
 966               	.L81:
 273:tmk_core/common/action.c ****                             clear_oneshot_mods();
 967               		.loc 1 273 0
 968 0172 1111      		cpse r17,__zero_reg__
 969 0174 00C0      		rjmp .L84
 970               	.L158:
 288:tmk_core/common/action.c ****                             unregister_mods(mods);
 971               		.loc 1 288 0
 972 0176 0E94 0000 		call clear_oneshot_mods
 973               	.LVL130:
 974               	.L90:
 333:tmk_core/common/action.c ****                         }
 975               		.loc 1 333 0
 976 017a 8F2D      		mov r24,r15
 977 017c 0E94 0000 		call unregister_mods
 978               	.LVL131:
 979 0180 00C0      		rjmp .L72
 980               	.L84:
 276:tmk_core/common/action.c ****                             // Retain Oneshot mods
 981               		.loc 1 276 0
 982 0182 1130      		cpi r17,lo8(1)
 983 0184 01F4      		brne .+2
 984 0186 00C0      		rjmp .L72
 985 0188 00C0      		rjmp .L158
 986               	.L80:
 295:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 987               		.loc 1 295 0
 988 018a 0023      		tst r16
 989 018c 01F0      		breq .L86
 296:tmk_core/common/action.c ****                             register_mods(mods);
 990               		.loc 1 296 0
 991 018e 1630      		cpi r17,lo8(6)
 992 0190 00F0      		brlo .+2
 993 0192 00C0      		rjmp .L72
 994               	.L88:
 322:tmk_core/common/action.c ****                         }
 995               		.loc 1 322 0
 996 0194 8F2D      		mov r24,r15
 997 0196 00C0      		rjmp .L157
 998               	.L86:
 300:tmk_core/common/action.c ****                             unregister_mods(mods);
 999               		.loc 1 300 0
 1000 0198 1530      		cpi r17,lo8(5)
 1001 019a 00F0      		brlo .+2
 1002 019c 00C0      		rjmp .L72
 1003 019e 00C0      		rjmp .L90
 1004               	.L87:
 325:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1005               		.loc 1 325 0
 1006 01a0 1123      		tst r17
 1007 01a2 01F0      		breq .L90
 327:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1008               		.loc 1 327 0
 1009 01a4 D933      		cpi r29,lo8(57)
 1010 01a6 01F4      		brne .L91
 1011               	.LVL132:
 1012               	.LBB20:
 1013               	.LBB21:
 1014               		.loc 2 187 0
 1015 01a8 FFEF      		ldi r31,lo8(255999)
 1016 01aa 27EE      		ldi r18,hi8(255999)
 1017 01ac 83E0      		ldi r24,hlo8(255999)
 1018 01ae F150      	1:	subi r31,1
 1019 01b0 2040      		sbci r18,0
 1020 01b2 8040      		sbci r24,0
 1021 01b4 01F4      		brne 1b
 1022 01b6 00C0      		rjmp .
 1023 01b8 0000      		nop
 1024               	.LVL133:
 1025               	.L91:
 1026               	.LBE21:
 1027               	.LBE20:
 330:tmk_core/common/action.c ****                         } else {
 1028               		.loc 1 330 0
 1029 01ba 8D2F      		mov r24,r29
 1030 01bc 0E94 0000 		call unregister_code
 1031               	.LVL134:
 1032 01c0 00C0      		rjmp .L72
 1033               	.LVL135:
 1034               	.L63:
 1035               	.LBE24:
 401:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1036               		.loc 1 401 0
 1037 01c2 8C2F      		mov r24,r28
 1038 01c4 8370      		andi r24,lo8(3)
 1039 01c6 01F0      		breq .+2
 1040 01c8 00C0      		rjmp .L92
 403:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1041               		.loc 1 403 0
 1042 01ca 0111      		cpse r16,__zero_reg__
 1043 01cc 00C0      		rjmp .L93
 1044               	.LVL136:
 1045               	.LBB25:
 404:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1046               		.loc 1 404 0
 1047 01ce 4D2F      		mov r20,r29
 1048 01d0 4295      		swap r20
 1049 01d2 4695      		lsr r20
 1050 01d4 4770      		andi r20,lo8(7)
 1051 01d6 440F      		lsl r20
 1052 01d8 440F      		lsl r20
 405:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1053               		.loc 1 405 0
 1054 01da 0D2F      		mov r16,r29
 1055               	.LVL137:
 1056 01dc 0F70      		andi r16,lo8(15)
 1057 01de 10E0      		ldi r17,0
 1058               	.LVL138:
 1059 01e0 30E0      		ldi r19,0
 1060 01e2 20E0      		ldi r18,0
 1061 01e4 042E      		mov r0,r20
 1062 01e6 00C0      		rjmp 2f
 1063               		1:
 1064 01e8 000F      		lsl r16
 1065 01ea 111F      		rol r17
 1066 01ec 221F      		rol r18
 1067 01ee 331F      		rol r19
 1068               		2:
 1069 01f0 0A94      		dec r0
 1070 01f2 02F4      		brpl 1b
 1071               	.LVL139:
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1072               		.loc 1 406 0
 1073 01f4 60E0      		ldi r22,0
 1074 01f6 70E0      		ldi r23,0
 1075 01f8 CB01      		movw r24,r22
 1076 01fa D4FF      		sbrs r29,4
 1077 01fc 00C0      		rjmp .L94
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1078               		.loc 1 406 0 is_stmt 0 discriminator 1
 1079 01fe 6FE0      		ldi r22,lo8(15)
 1080 0200 70E0      		ldi r23,0
 1081 0202 80E0      		ldi r24,0
 1082 0204 90E0      		ldi r25,0
 1083 0206 00C0      		rjmp 2f
 1084               		1:
 1085 0208 660F      		lsl r22
 1086 020a 771F      		rol r23
 1087 020c 881F      		rol r24
 1088 020e 991F      		rol r25
 1089               		2:
 1090 0210 4A95      		dec r20
 1091 0212 02F4      		brpl 1b
 1092 0214 6095      		com r22
 1093 0216 7095      		com r23
 1094 0218 8095      		com r24
 1095 021a 9095      		com r25
 1096               	.L94:
 1097               	.LVL140:
 1098 021c 602B      		or r22,r16
 1099               	.LVL141:
 1100 021e 712B      		or r23,r17
 1101 0220 822B      		or r24,r18
 1102 0222 932B      		or r25,r19
 407:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1103               		.loc 1 407 0 is_stmt 1 discriminator 4
 1104 0224 C695      		lsr r28
 1105 0226 C695      		lsr r28
 1106               	.LVL142:
 1107 0228 C370      		andi r28,lo8(3)
 1108 022a C230      		cpi r28,lo8(2)
 1109 022c 01F0      		breq .L96
 1110 022e 00F4      		brsh .L97
 1111 0230 C130      		cpi r28,lo8(1)
 1112 0232 01F0      		breq .L98
 409:tmk_core/common/action.c ****                             break;
 1113               		.loc 1 409 0 discriminator 4
 1114 0234 0E94 0000 		call default_layer_and
 1115               	.LVL143:
 1116               	.L93:
 1117               	.LBE25:
 661:tmk_core/common/action.c ****             break;
 1118               		.loc 1 661 0
 1119 0238 0E94 0000 		call host_keyboard_leds
 1120               	.LVL144:
 1121 023c 0E94 0000 		call led_set
 1122               	.LVL145:
 662:tmk_core/common/action.c ****         default:
 1123               		.loc 1 662 0
 1124 0240 00C0      		rjmp .L72
 1125               	.LVL146:
 1126               	.L98:
 1127               	.LBB26:
 412:tmk_core/common/action.c ****                             break;
 1128               		.loc 1 412 0
 1129 0242 0E94 0000 		call default_layer_or
 1130               	.LVL147:
 413:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1131               		.loc 1 413 0
 1132 0246 00C0      		rjmp .L93
 1133               	.L96:
 415:tmk_core/common/action.c ****                             break;
 1134               		.loc 1 415 0
 1135 0248 0E94 0000 		call default_layer_xor
 1136               	.LVL148:
 416:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1137               		.loc 1 416 0
 1138 024c 00C0      		rjmp .L93
 1139               	.L97:
 418:tmk_core/common/action.c ****                             break;
 1140               		.loc 1 418 0
 1141 024e 0E94 0000 		call default_layer_set
 1142               	.LVL149:
 419:tmk_core/common/action.c ****                     }
 1143               		.loc 1 419 0
 1144 0252 00C0      		rjmp .L93
 1145               	.LVL150:
 1146               	.L92:
 1147               	.LBE26:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1148               		.loc 1 424 0
 1149 0254 8695      		lsr r24
 1150 0256 0023      		tst r16
 1151 0258 01F0      		breq .L100
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1152               		.loc 1 424 0 is_stmt 0 discriminator 1
 1153 025a 8C2F      		mov r24,r28
 1154 025c 8170      		andi r24,lo8(1)
 1155               	.L100:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1156               		.loc 1 424 0 discriminator 4
 1157 025e 8823      		tst r24
 1158 0260 01F0      		breq .L93
 1159               	.LVL151:
 1160               	.LBB27:
 425:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1161               		.loc 1 425 0 is_stmt 1
 1162 0262 4D2F      		mov r20,r29
 1163 0264 4295      		swap r20
 1164 0266 4695      		lsr r20
 1165 0268 4770      		andi r20,lo8(7)
 1166 026a 440F      		lsl r20
 1167 026c 440F      		lsl r20
 426:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1168               		.loc 1 426 0
 1169 026e 0D2F      		mov r16,r29
 1170               	.LVL152:
 1171 0270 0F70      		andi r16,lo8(15)
 1172 0272 10E0      		ldi r17,0
 1173               	.LVL153:
 1174 0274 30E0      		ldi r19,0
 1175 0276 20E0      		ldi r18,0
 1176 0278 042E      		mov r0,r20
 1177 027a 00C0      		rjmp 2f
 1178               		1:
 1179 027c 000F      		lsl r16
 1180 027e 111F      		rol r17
 1181 0280 221F      		rol r18
 1182 0282 331F      		rol r19
 1183               		2:
 1184 0284 0A94      		dec r0
 1185 0286 02F4      		brpl 1b
 1186               	.LVL154:
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1187               		.loc 1 427 0
 1188 0288 60E0      		ldi r22,0
 1189 028a 70E0      		ldi r23,0
 1190 028c CB01      		movw r24,r22
 1191 028e D4FF      		sbrs r29,4
 1192 0290 00C0      		rjmp .L101
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1193               		.loc 1 427 0 is_stmt 0 discriminator 1
 1194 0292 6FE0      		ldi r22,lo8(15)
 1195 0294 70E0      		ldi r23,0
 1196 0296 80E0      		ldi r24,0
 1197 0298 90E0      		ldi r25,0
 1198 029a 00C0      		rjmp 2f
 1199               		1:
 1200 029c 660F      		lsl r22
 1201 029e 771F      		rol r23
 1202 02a0 881F      		rol r24
 1203 02a2 991F      		rol r25
 1204               		2:
 1205 02a4 4A95      		dec r20
 1206 02a6 02F4      		brpl 1b
 1207 02a8 6095      		com r22
 1208 02aa 7095      		com r23
 1209 02ac 8095      		com r24
 1210 02ae 9095      		com r25
 1211               	.L101:
 1212               	.LVL155:
 1213 02b0 602B      		or r22,r16
 1214               	.LVL156:
 1215 02b2 712B      		or r23,r17
 1216 02b4 822B      		or r24,r18
 1217 02b6 932B      		or r25,r19
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1218               		.loc 1 428 0 is_stmt 1 discriminator 4
 1219 02b8 C695      		lsr r28
 1220 02ba C695      		lsr r28
 1221               	.LVL157:
 1222 02bc C370      		andi r28,lo8(3)
 1223 02be C230      		cpi r28,lo8(2)
 1224 02c0 01F0      		breq .L103
 1225 02c2 00F4      		brsh .L104
 1226 02c4 C130      		cpi r28,lo8(1)
 1227 02c6 01F0      		breq .L105
 430:tmk_core/common/action.c ****                             break;
 1228               		.loc 1 430 0 discriminator 4
 1229 02c8 0E94 0000 		call layer_and
 1230               	.LVL158:
 431:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1231               		.loc 1 431 0 discriminator 4
 1232 02cc 00C0      		rjmp .L93
 1233               	.L105:
 433:tmk_core/common/action.c ****                             break;
 1234               		.loc 1 433 0
 1235 02ce 0E94 0000 		call layer_or
 1236               	.LVL159:
 434:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1237               		.loc 1 434 0
 1238 02d2 00C0      		rjmp .L93
 1239               	.L103:
 436:tmk_core/common/action.c ****                             break;
 1240               		.loc 1 436 0
 1241 02d4 0E94 0000 		call layer_xor
 1242               	.LVL160:
 437:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1243               		.loc 1 437 0
 1244 02d8 00C0      		rjmp .L93
 1245               	.L104:
 439:tmk_core/common/action.c ****                             break;
 1246               		.loc 1 439 0
 1247 02da 0E94 0000 		call layer_state_set
 1248               	.LVL161:
 440:tmk_core/common/action.c ****                     }
 1249               		.loc 1 440 0
 1250 02de 00C0      		rjmp .L93
 1251               	.LVL162:
 1252               	.L64:
 1253 02e0 CF70      		andi r28,lo8(15)
 1254               	.LVL163:
 1255               	.LBE27:
 446:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1256               		.loc 1 446 0
 1257 02e2 0023      		tst r16
 1258 02e4 01F0      		breq .L106
 447:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1259               		.loc 1 447 0
 1260 02e6 8C2F      		mov r24,r28
 1261 02e8 0E94 0000 		call layer_on
 1262               	.LVL164:
 448:tmk_core/common/action.c ****             } else {
 1263               		.loc 1 448 0
 1264 02ec 8D2F      		mov r24,r29
 1265 02ee 0E94 0000 		call register_mods
 1266               	.LVL165:
 1267 02f2 00C0      		rjmp .L93
 1268               	.L106:
 450:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1269               		.loc 1 450 0
 1270 02f4 8D2F      		mov r24,r29
 1271 02f6 0E94 0000 		call unregister_mods
 1272               	.LVL166:
 451:tmk_core/common/action.c ****             }
 1273               		.loc 1 451 0
 1274 02fa 8C2F      		mov r24,r28
 1275 02fc 0E94 0000 		call layer_off
 1276               	.LVL167:
 1277 0300 00C0      		rjmp .L93
 1278               	.LVL168:
 1279               	.L65:
 457:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1280               		.loc 1 457 0
 1281 0302 D23F      		cpi r29,lo8(-14)
 1282 0304 01F0      		breq .L108
 1283 0306 00F4      		brsh .L109
 1284 0308 D03F      		cpi r29,lo8(-16)
 1285 030a 01F0      		breq .L110
 1286 030c D13F      		cpi r29,lo8(-15)
 1287 030e 01F0      		breq .L111
 1288               	.L107:
 519:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1289               		.loc 1 519 0
 1290 0310 0023      		tst r16
 1291 0312 01F4      		brne .+2
 1292 0314 00C0      		rjmp .L121
 520:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1293               		.loc 1 520 0
 1294 0316 1123      		tst r17
 1295 0318 01F4      		brne .+2
 1296 031a 00C0      		rjmp .L122
 522:tmk_core/common/action.c ****                         } else {
 1297               		.loc 1 522 0
 1298 031c 8D2F      		mov r24,r29
 1299 031e 0E94 0000 		call register_code
 1300               	.LVL169:
 1301 0322 00C0      		rjmp .L59
 1302               	.L109:
 457:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1303               		.loc 1 457 0
 1304 0324 D33F      		cpi r29,lo8(-13)
 1305 0326 01F0      		breq .L112
 1306 0328 D43F      		cpi r29,lo8(-12)
 1307 032a 01F4      		brne .L107
 505:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1308               		.loc 1 505 0
 1309 032c 0023      		tst r16
 1310 032e 01F0      		breq .L120
 506:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1311               		.loc 1 506 0
 1312 0330 CF71      		andi r28,lo8(31)
 1313               	.LVL170:
 1314 0332 8C2F      		mov r24,r28
 1315 0334 0E94 0000 		call layer_on
 1316               	.LVL171:
 507:tmk_core/common/action.c ****                     } else {
 1317               		.loc 1 507 0
 1318 0338 63E0      		ldi r22,lo8(3)
 1319 033a 8C2F      		mov r24,r28
 1320 033c 0E94 0000 		call set_oneshot_layer
 1321               	.LVL172:
 1322 0340 00C0      		rjmp .L59
 1323               	.LVL173:
 1324               	.L110:
 460:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1325               		.loc 1 460 0
 1326 0342 0023      		tst r16
 1327 0344 01F0      		breq .L114
 461:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1328               		.loc 1 461 0
 1329 0346 1530      		cpi r17,lo8(5)
 1330 0348 00F4      		brsh .L59
 1331               	.L115:
 462:tmk_core/common/action.c ****                         }
 1332               		.loc 1 462 0
 1333 034a 8C2F      		mov r24,r28
 1334 034c 8F71      		andi r24,lo8(31)
 1335 034e 0E94 0000 		call layer_invert
 1336               	.LVL174:
 1337               	.L59:
 654:tmk_core/common/action.c ****         case ACT_LAYER:
 1338               		.loc 1 654 0
 1339 0352 88EF      		ldi r24,lo8(-8)
 1340 0354 8F0D      		add r24,r15
 1341 0356 8430      		cpi r24,lo8(4)
 1342 0358 00F0      		brlo .+2
 1343 035a 00C0      		rjmp .L72
 1344 035c 00C0      		rjmp .L93
 1345               	.L114:
 465:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1346               		.loc 1 465 0
 1347 035e 1630      		cpi r17,lo8(6)
 1348 0360 00F4      		brsh .L59
 1349 0362 00C0      		rjmp .L115
 1350               	.L111:
 1351 0364 8C2F      		mov r24,r28
 1352 0366 8F71      		andi r24,lo8(31)
 471:tmk_core/common/action.c ****                     break;
 1353               		.loc 1 471 0
 1354 0368 0023      		tst r16
 1355 036a 01F0      		breq .L155
 1356               	.L156:
 525:tmk_core/common/action.c ****                         }
 1357               		.loc 1 525 0
 1358 036c 0E94 0000 		call layer_on
 1359               	.LVL175:
 1360 0370 00C0      		rjmp .L59
 1361               	.L108:
 1362 0372 8C2F      		mov r24,r28
 1363 0374 8F71      		andi r24,lo8(31)
 474:tmk_core/common/action.c ****                     break;
 1364               		.loc 1 474 0
 1365 0376 0023      		tst r16
 1366 0378 01F0      		breq .L156
 1367               	.L155:
 538:tmk_core/common/action.c ****                         }
 1368               		.loc 1 538 0
 1369 037a 0E94 0000 		call layer_off
 1370               	.LVL176:
 1371 037e 00C0      		rjmp .L59
 1372               	.L112:
 477:tmk_core/common/action.c ****                     break;
 1373               		.loc 1 477 0
 1374 0380 0023      		tst r16
 1375 0382 01F0      		breq .L119
 477:tmk_core/common/action.c ****                     break;
 1376               		.loc 1 477 0 is_stmt 0 discriminator 1
 1377 0384 8C2F      		mov r24,r28
 1378 0386 8F71      		andi r24,lo8(31)
 1379 0388 0E94 0000 		call layer_move
 1380               	.LVL177:
 1381 038c 00C0      		rjmp .L59
 1382               	.L119:
 477:tmk_core/common/action.c ****                     break;
 1383               		.loc 1 477 0 discriminator 2
 1384 038e 0E94 0000 		call layer_clear
 1385               	.LVL178:
 1386 0392 00C0      		rjmp .L59
 1387               	.L120:
 509:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1388               		.loc 1 509 0 is_stmt 1
 1389 0394 81E0      		ldi r24,lo8(1)
 1390 0396 0E94 0000 		call clear_oneshot_layer_state
 1391               	.LVL179:
 510:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1392               		.loc 1 510 0
 1393 039a 1230      		cpi r17,lo8(2)
 1394 039c 00F0      		brlo .L59
 511:tmk_core/common/action.c ****                         }
 1395               		.loc 1 511 0
 1396 039e 82E0      		ldi r24,lo8(2)
 1397 03a0 0E94 0000 		call clear_oneshot_layer_state
 1398               	.LVL180:
 1399 03a4 00C0      		rjmp .L59
 1400               	.L122:
 525:tmk_core/common/action.c ****                         }
 1401               		.loc 1 525 0
 1402 03a6 8C2F      		mov r24,r28
 1403 03a8 8F71      		andi r24,lo8(31)
 1404 03aa 00C0      		rjmp .L156
 1405               	.L121:
 528:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1406               		.loc 1 528 0
 1407 03ac 1123      		tst r17
 1408 03ae 01F0      		breq .L123
 530:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1409               		.loc 1 530 0
 1410 03b0 D933      		cpi r29,lo8(57)
 1411 03b2 01F4      		brne .L125
 1412               	.LVL181:
 1413               	.LBB28:
 1414               	.LBB29:
 1415               		.loc 2 187 0
 1416 03b4 9FEF      		ldi r25,lo8(255999)
 1417 03b6 E7EE      		ldi r30,hi8(255999)
 1418 03b8 F3E0      		ldi r31,hlo8(255999)
 1419 03ba 9150      	1:	subi r25,1
 1420 03bc E040      		sbci r30,0
 1421 03be F040      		sbci r31,0
 1422 03c0 01F4      		brne 1b
 1423 03c2 00C0      		rjmp .
 1424 03c4 0000      		nop
 1425               	.LVL182:
 1426               	.L125:
 1427               	.LBE29:
 1428               	.LBE28:
 535:tmk_core/common/action.c ****                         } else {
 1429               		.loc 1 535 0
 1430 03c6 8D2F      		mov r24,r29
 1431 03c8 0E94 0000 		call unregister_code
 1432               	.LVL183:
 1433 03cc 00C0      		rjmp .L59
 1434               	.L123:
 538:tmk_core/common/action.c ****                         }
 1435               		.loc 1 538 0
 1436 03ce 8C2F      		mov r24,r28
 1437 03d0 8F71      		andi r24,lo8(31)
 1438 03d2 00C0      		rjmp .L155
 1439               	.LVL184:
 1440               	.L56:
 1441               	/* epilogue start */
 703:tmk_core/common/action.c **** 
 1442               		.loc 1 703 0
 1443 03d4 DF91      		pop r29
 1444               	.LVL185:
 1445 03d6 CF91      		pop r28
 1446 03d8 1F91      		pop r17
 1447 03da 0F91      		pop r16
 1448 03dc FF90      		pop r15
 1449 03de EF90      		pop r14
 1450               	.LVL186:
 1451 03e0 DF90      		pop r13
 1452 03e2 CF90      		pop r12
 1453               	.LVL187:
 1454 03e4 0895      		ret
 1455               		.cfi_endproc
 1456               	.LFE18:
 1458               		.section	.text.process_record,"ax",@progbits
 1459               	.global	process_record
 1461               	process_record:
 1462               	.LFB17:
 172:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1463               		.loc 1 172 0
 1464               		.cfi_startproc
 1465               	.LVL188:
 1466 0000 0F93      		push r16
 1467               	.LCFI13:
 1468               		.cfi_def_cfa_offset 3
 1469               		.cfi_offset 16, -2
 1470 0002 1F93      		push r17
 1471               	.LCFI14:
 1472               		.cfi_def_cfa_offset 4
 1473               		.cfi_offset 17, -3
 1474 0004 CF93      		push r28
 1475               	.LCFI15:
 1476               		.cfi_def_cfa_offset 5
 1477               		.cfi_offset 28, -4
 1478 0006 DF93      		push r29
 1479               	.LCFI16:
 1480               		.cfi_def_cfa_offset 6
 1481               		.cfi_offset 29, -5
 1482               	/* prologue: function */
 1483               	/* frame size = 0 */
 1484               	/* stack size = 4 */
 1485               	.L__stack_usage = 4
 1486 0008 EC01      		movw r28,r24
 173:tmk_core/common/action.c ****         return;
 1487               		.loc 1 173 0
 1488 000a 9881      		ld r25,Y
 1489 000c 8981      		ldd r24,Y+1
 1490               	.LVL189:
 1491               	.LBB32:
 1492               	.LBB33:
 1493               		.file 3 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1494               		.loc 3 48 0
 1495 000e 2B81      		ldd r18,Y+3
 1496 0010 3C81      		ldd r19,Y+4
 1497 0012 232B      		or r18,r19
 1498 0014 01F0      		breq .L163
 1499 0016 8F3F      		cpi r24,lo8(-1)
 1500 0018 01F4      		brne .L164
 1501 001a 81E0      		ldi r24,lo8(1)
 1502 001c 9F3F      		cpi r25,lo8(-1)
 1503 001e 01F0      		breq .L160
 1504               	.L164:
 1505 0020 80E0      		ldi r24,0
 1506 0022 00C0      		rjmp .L160
 1507               	.L163:
 1508 0024 81E0      		ldi r24,lo8(1)
 1509               	.L160:
 1510               	.LBE33:
 1511               	.LBE32:
 173:tmk_core/common/action.c ****         return;
 1512               		.loc 1 173 0
 1513 0026 80FD      		sbrc r24,0
 1514 0028 00C0      		rjmp .L159
 177:tmk_core/common/action.c **** 
 1515               		.loc 1 177 0
 1516 002a CE01      		movw r24,r28
 1517 002c 0E94 0000 		call process_record_quantum
 1518               	.LVL190:
 1519 0030 8823      		tst r24
 1520 0032 01F0      		breq .L159
 179:tmk_core/common/action.c ****     dprint("ACTION: ");
 1521               		.loc 1 179 0
 1522 0034 6881      		ld r22,Y
 1523 0036 7981      		ldd r23,Y+1
 1524 0038 8A81      		ldd r24,Y+2
 1525 003a 0E94 0000 		call store_or_get_action
 1526               	.LVL191:
 1527 003e 8C01      		movw r16,r24
 1528               	.LVL192:
 184:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1529               		.loc 1 184 0
 1530 0040 0E94 0000 		call layer_debug
 1531               	.LVL193:
 186:tmk_core/common/action.c **** #endif
 1532               		.loc 1 186 0
 1533 0044 0E94 0000 		call default_layer_debug
 1534               	.LVL194:
 190:tmk_core/common/action.c **** }
 1535               		.loc 1 190 0
 1536 0048 B801      		movw r22,r16
 1537 004a CE01      		movw r24,r28
 1538               	/* epilogue start */
 191:tmk_core/common/action.c **** 
 1539               		.loc 1 191 0
 1540 004c DF91      		pop r29
 1541 004e CF91      		pop r28
 1542               	.LVL195:
 1543 0050 1F91      		pop r17
 1544 0052 0F91      		pop r16
 1545               	.LVL196:
 190:tmk_core/common/action.c **** }
 1546               		.loc 1 190 0
 1547 0054 0C94 0000 		jmp process_action
 1548               	.LVL197:
 1549               	.L159:
 1550               	/* epilogue start */
 191:tmk_core/common/action.c **** 
 1551               		.loc 1 191 0
 1552 0058 DF91      		pop r29
 1553 005a CF91      		pop r28
 1554               	.LVL198:
 1555 005c 1F91      		pop r17
 1556 005e 0F91      		pop r16
 1557 0060 0895      		ret
 1558               		.cfi_endproc
 1559               	.LFE17:
 1561               		.section	.text.process_record_nocache,"ax",@progbits
 1562               	.global	process_record_nocache
 1564               	process_record_nocache:
 1565               	.LFB14:
 134:tmk_core/common/action.c ****     disable_action_cache = true;
 1566               		.loc 1 134 0
 1567               		.cfi_startproc
 1568               	.LVL199:
 1569               	/* prologue: function */
 1570               	/* frame size = 0 */
 1571               	/* stack size = 0 */
 1572               	.L__stack_usage = 0
 135:tmk_core/common/action.c ****     process_record(record);
 1573               		.loc 1 135 0
 1574 0000 21E0      		ldi r18,lo8(1)
 1575 0002 2093 0000 		sts disable_action_cache,r18
 136:tmk_core/common/action.c ****     disable_action_cache = false;
 1576               		.loc 1 136 0
 1577 0006 0E94 0000 		call process_record
 1578               	.LVL200:
 137:tmk_core/common/action.c **** }
 1579               		.loc 1 137 0
 1580 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1581               	/* epilogue start */
 138:tmk_core/common/action.c **** #else
 1582               		.loc 1 138 0
 1583 000e 0895      		ret
 1584               		.cfi_endproc
 1585               	.LFE14:
 1587               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1588               	.global	clear_keyboard_but_mods_and_keys
 1590               	clear_keyboard_but_mods_and_keys:
 1591               	.LFB26:
 892:tmk_core/common/action.c **** 
 893:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 894:tmk_core/common/action.c ****  *
 895:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 896:tmk_core/common/action.c ****  */
 897:tmk_core/common/action.c **** void clear_keyboard(void) {
 898:tmk_core/common/action.c ****     clear_mods();
 899:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 900:tmk_core/common/action.c **** }
 901:tmk_core/common/action.c **** 
 902:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 903:tmk_core/common/action.c ****  *
 904:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 905:tmk_core/common/action.c ****  */
 906:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 907:tmk_core/common/action.c ****     clear_keys();
 908:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 909:tmk_core/common/action.c **** }
 910:tmk_core/common/action.c **** 
 911:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 912:tmk_core/common/action.c ****  *
 913:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 914:tmk_core/common/action.c ****  */
 915:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1592               		.loc 1 915 0
 1593               		.cfi_startproc
 1594               	/* prologue: function */
 1595               	/* frame size = 0 */
 1596               	/* stack size = 0 */
 1597               	.L__stack_usage = 0
 916:tmk_core/common/action.c ****     clear_weak_mods();
 1598               		.loc 1 916 0
 1599 0000 0E94 0000 		call clear_weak_mods
 1600               	.LVL201:
 917:tmk_core/common/action.c ****     clear_macro_mods();
 1601               		.loc 1 917 0
 1602 0004 0E94 0000 		call clear_macro_mods
 1603               	.LVL202:
 918:tmk_core/common/action.c ****     send_keyboard_report();
 1604               		.loc 1 918 0
 1605 0008 0C94 0000 		jmp send_keyboard_report
 1606               	.LVL203:
 1607               		.cfi_endproc
 1608               	.LFE26:
 1610               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1611               	.global	clear_keyboard_but_mods
 1613               	clear_keyboard_but_mods:
 1614               	.LFB25:
 906:tmk_core/common/action.c ****     clear_keys();
 1615               		.loc 1 906 0
 1616               		.cfi_startproc
 1617               	/* prologue: function */
 1618               	/* frame size = 0 */
 1619               	/* stack size = 0 */
 1620               	.L__stack_usage = 0
 907:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1621               		.loc 1 907 0
 1622 0000 0E94 0000 		call clear_keys
 1623               	.LVL204:
 908:tmk_core/common/action.c **** }
 1624               		.loc 1 908 0
 1625 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1626               	.LVL205:
 1627               		.cfi_endproc
 1628               	.LFE25:
 1630               		.section	.text.clear_keyboard,"ax",@progbits
 1631               	.global	clear_keyboard
 1633               	clear_keyboard:
 1634               	.LFB24:
 897:tmk_core/common/action.c ****     clear_mods();
 1635               		.loc 1 897 0
 1636               		.cfi_startproc
 1637               	/* prologue: function */
 1638               	/* frame size = 0 */
 1639               	/* stack size = 0 */
 1640               	.L__stack_usage = 0
 898:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1641               		.loc 1 898 0
 1642 0000 0E94 0000 		call clear_mods
 1643               	.LVL206:
 899:tmk_core/common/action.c **** }
 1644               		.loc 1 899 0
 1645 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1646               	.LVL207:
 1647               		.cfi_endproc
 1648               	.LFE24:
 1650               		.section	.text.is_tap_action,"ax",@progbits
 1651               	.global	is_tap_action
 1653               	is_tap_action:
 1654               	.LFB28:
 919:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 920:tmk_core/common/action.c ****     mousekey_clear();
 921:tmk_core/common/action.c ****     mousekey_send();
 922:tmk_core/common/action.c **** #endif
 923:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 924:tmk_core/common/action.c ****     host_system_send(0);
 925:tmk_core/common/action.c ****     host_consumer_send(0);
 926:tmk_core/common/action.c **** #endif
 927:tmk_core/common/action.c **** }
 928:tmk_core/common/action.c **** 
 929:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 930:tmk_core/common/action.c ****  *
 931:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 932:tmk_core/common/action.c ****  */
 933:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 934:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 935:tmk_core/common/action.c ****     return is_tap_action(action);
 936:tmk_core/common/action.c **** }
 937:tmk_core/common/action.c **** 
 938:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 939:tmk_core/common/action.c ****  *
 940:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 941:tmk_core/common/action.c ****  */
 942:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1655               		.loc 1 942 0
 1656               		.cfi_startproc
 1657               	.LVL208:
 1658               	/* prologue: function */
 1659               	/* frame size = 0 */
 1660               	/* stack size = 0 */
 1661               	.L__stack_usage = 0
 943:tmk_core/common/action.c ****     switch (action.kind.id) {
 1662               		.loc 1 943 0
 1663 0000 E92F      		mov r30,r25
 1664 0002 E295      		swap r30
 1665 0004 EF70      		andi r30,lo8(15)
 1666 0006 E250      		subi r30,lo8(-(-2))
 1667 0008 EE30      		cpi r30,lo8(14)
 1668 000a 00F4      		brsh .L184
 1669 000c F0E0      		ldi r31,0
 1670 000e E050      		subi r30,lo8(-(gs(.L178)))
 1671 0010 F040      		sbci r31,hi8(-(gs(.L178)))
 1672 0012 0C94 0000 		jmp __tablejump2__
 1673               		.p2align	1
 1674               	.L178:
 1675 0016 0000      		.word gs(.L177)
 1676 0018 0000      		.word gs(.L177)
 1677 001a 0000      		.word gs(.L184)
 1678 001c 0000      		.word gs(.L184)
 1679 001e 0000      		.word gs(.L179)
 1680 0020 0000      		.word gs(.L184)
 1681 0022 0000      		.word gs(.L184)
 1682 0024 0000      		.word gs(.L184)
 1683 0026 0000      		.word gs(.L177)
 1684 0028 0000      		.word gs(.L177)
 1685 002a 0000      		.word gs(.L180)
 1686 002c 0000      		.word gs(.L184)
 1687 002e 0000      		.word gs(.L184)
 1688 0030 0000      		.word gs(.L180)
 1689               	.L177:
 944:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 945:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 946:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 947:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 948:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1690               		.loc 1 948 0
 1691 0032 803F      		cpi r24,lo8(-16)
 1692 0034 01F0      		breq .L186
 1693 0036 00F4      		brsh .L182
 1694 0038 883E      		cpi r24,lo8(-24)
 1695 003a 00F4      		brsh .L184
 1696               	.L186:
 949:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 950:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 951:tmk_core/common/action.c ****                 case OP_ONESHOT:
 952:tmk_core/common/action.c ****                     return true;
 1697               		.loc 1 952 0
 1698 003c 81E0      		ldi r24,lo8(1)
 1699               	.LVL209:
 1700               	/* epilogue start */
 953:tmk_core/common/action.c ****             }
 954:tmk_core/common/action.c ****             return false;
 955:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 956:tmk_core/common/action.c ****             switch (action.swap.code) {
 957:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 958:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 959:tmk_core/common/action.c ****                     return true;
 960:tmk_core/common/action.c ****             }
 961:tmk_core/common/action.c ****             return false;
 962:tmk_core/common/action.c ****         case ACT_MACRO:
 963:tmk_core/common/action.c ****         case ACT_FUNCTION:
 964:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 965:tmk_core/common/action.c ****                 return true;
 966:tmk_core/common/action.c ****             }
 967:tmk_core/common/action.c ****             return false;
 968:tmk_core/common/action.c ****     }
 969:tmk_core/common/action.c ****     return false;
 970:tmk_core/common/action.c **** }
 1701               		.loc 1 970 0
 1702 003e 0895      		ret
 1703               	.LVL210:
 1704               	.L182:
 948:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1705               		.loc 1 948 0
 1706 0040 843F      		cpi r24,lo8(-12)
 1707 0042 01F0      		breq .L186
 1708               	.L184:
 954:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1709               		.loc 1 954 0
 1710 0044 80E0      		ldi r24,0
 1711               	.LVL211:
 1712 0046 0895      		ret
 1713               	.LVL212:
 1714               	.L179:
 956:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1715               		.loc 1 956 0
 1716 0048 883E      		cpi r24,lo8(-24)
 1717 004a 00F0      		brlo .L186
 1718 004c 813F      		cpi r24,lo8(-15)
 1719 004e 01F4      		brne .L184
 1720 0050 00C0      		rjmp .L186
 1721               	.L180:
 964:tmk_core/common/action.c ****                 return true;
 1722               		.loc 1 964 0
 1723 0052 93FB      		bst r25,3
 1724 0054 8827      		clr r24
 1725 0056 80F9      		bld r24,0
 1726               	.LVL213:
 1727 0058 0895      		ret
 1728               		.cfi_endproc
 1729               	.LFE28:
 1731               		.section	.text.is_tap_key,"ax",@progbits
 1732               	.global	is_tap_key
 1734               	is_tap_key:
 1735               	.LFB27:
 933:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1736               		.loc 1 933 0
 1737               		.cfi_startproc
 1738               	.LVL214:
 1739               	/* prologue: function */
 1740               	/* frame size = 0 */
 1741               	/* stack size = 0 */
 1742               	.L__stack_usage = 0
 934:tmk_core/common/action.c ****     return is_tap_action(action);
 1743               		.loc 1 934 0
 1744 0000 0E94 0000 		call layer_switch_get_action
 1745               	.LVL215:
 935:tmk_core/common/action.c **** }
 1746               		.loc 1 935 0
 1747 0004 0C94 0000 		jmp is_tap_action
 1748               	.LVL216:
 1749               		.cfi_endproc
 1750               	.LFE27:
 1752               		.section	.text.debug_event,"ax",@progbits
 1753               	.global	debug_event
 1755               	debug_event:
 1756               	.LFB29:
 971:tmk_core/common/action.c **** 
 972:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 973:tmk_core/common/action.c ****  *
 974:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 975:tmk_core/common/action.c ****  */
 976:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1757               		.loc 1 976 0
 1758               		.cfi_startproc
 1759 0000 CF93      		push r28
 1760               	.LCFI17:
 1761               		.cfi_def_cfa_offset 3
 1762               		.cfi_offset 28, -2
 1763 0002 DF93      		push r29
 1764               	.LCFI18:
 1765               		.cfi_def_cfa_offset 4
 1766               		.cfi_offset 29, -3
 1767 0004 00D0      		rcall .
 1768 0006 00D0      		rcall .
 1769 0008 1F92      		push __zero_reg__
 1770               	.LCFI19:
 1771               		.cfi_def_cfa_offset 9
 1772 000a CDB7      		in r28,__SP_L__
 1773 000c DEB7      		in r29,__SP_H__
 1774               	.LCFI20:
 1775               		.cfi_def_cfa_register 28
 1776               	/* prologue: function */
 1777               	/* frame size = 5 */
 1778               	/* stack size = 7 */
 1779               	.L__stack_usage = 7
 1780               	/* epilogue start */
 1781               		.loc 1 976 0
 1782 000e 0F90      		pop __tmp_reg__
 1783 0010 0F90      		pop __tmp_reg__
 1784 0012 0F90      		pop __tmp_reg__
 1785 0014 0F90      		pop __tmp_reg__
 1786 0016 0F90      		pop __tmp_reg__
 1787 0018 DF91      		pop r29
 1788 001a CF91      		pop r28
 1789 001c 0895      		ret
 1790               		.cfi_endproc
 1791               	.LFE29:
 1793               		.section	.text.debug_record,"ax",@progbits
 1794               	.global	debug_record
 1796               	debug_record:
 1797               	.LFB30:
 977:tmk_core/common/action.c **** 
 978:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 979:tmk_core/common/action.c ****  *
 980:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 981:tmk_core/common/action.c ****  */
 982:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1798               		.loc 1 982 0
 1799               		.cfi_startproc
 1800 0000 CF93      		push r28
 1801               	.LCFI21:
 1802               		.cfi_def_cfa_offset 3
 1803               		.cfi_offset 28, -2
 1804 0002 DF93      		push r29
 1805               	.LCFI22:
 1806               		.cfi_def_cfa_offset 4
 1807               		.cfi_offset 29, -3
 1808 0004 00D0      		rcall .
 1809 0006 00D0      		rcall .
 1810 0008 00D0      		rcall .
 1811               	.LCFI23:
 1812               		.cfi_def_cfa_offset 10
 1813 000a CDB7      		in r28,__SP_L__
 1814 000c DEB7      		in r29,__SP_H__
 1815               	.LCFI24:
 1816               		.cfi_def_cfa_register 28
 1817               	/* prologue: function */
 1818               	/* frame size = 6 */
 1819               	/* stack size = 8 */
 1820               	.L__stack_usage = 8
 1821               	/* epilogue start */
 983:tmk_core/common/action.c ****     debug_event(record.event);
 984:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 985:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** }
 1822               		.loc 1 987 0
 1823 000e 2696      		adiw r28,6
 1824 0010 0FB6      		in __tmp_reg__,__SREG__
 1825 0012 F894      		cli
 1826 0014 DEBF      		out __SP_H__,r29
 1827 0016 0FBE      		out __SREG__,__tmp_reg__
 1828 0018 CDBF      		out __SP_L__,r28
 1829 001a DF91      		pop r29
 1830 001c CF91      		pop r28
 1831 001e 0895      		ret
 1832               		.cfi_endproc
 1833               	.LFE30:
 1835               		.section	.text.debug_action,"ax",@progbits
 1836               	.global	debug_action
 1838               	debug_action:
 1839               	.LFB31:
 988:tmk_core/common/action.c **** 
 989:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 990:tmk_core/common/action.c ****  *
 991:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 992:tmk_core/common/action.c ****  */
 993:tmk_core/common/action.c **** void debug_action(action_t action) {
 1840               		.loc 1 993 0
 1841               		.cfi_startproc
 1842               	.LVL217:
 1843               	/* prologue: function */
 1844               	/* frame size = 0 */
 1845               	/* stack size = 0 */
 1846               	.L__stack_usage = 0
 1847               	/* epilogue start */
 994:tmk_core/common/action.c ****     switch (action.kind.id) {
 995:tmk_core/common/action.c ****         case ACT_LMODS:
 996:tmk_core/common/action.c ****             dprint("ACT_LMODS");
 997:tmk_core/common/action.c ****             break;
 998:tmk_core/common/action.c ****         case ACT_RMODS:
 999:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1000:tmk_core/common/action.c ****             break;
1001:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1002:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1003:tmk_core/common/action.c ****             break;
1004:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1005:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1006:tmk_core/common/action.c ****             break;
1007:tmk_core/common/action.c ****         case ACT_USAGE:
1008:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1009:tmk_core/common/action.c ****             break;
1010:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1011:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1012:tmk_core/common/action.c ****             break;
1013:tmk_core/common/action.c ****         case ACT_LAYER:
1014:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1015:tmk_core/common/action.c ****             break;
1016:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1017:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1018:tmk_core/common/action.c ****             break;
1019:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1020:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1021:tmk_core/common/action.c ****             break;
1022:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1023:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1024:tmk_core/common/action.c ****             break;
1025:tmk_core/common/action.c ****         case ACT_MACRO:
1026:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1027:tmk_core/common/action.c ****             break;
1028:tmk_core/common/action.c ****         case ACT_COMMAND:
1029:tmk_core/common/action.c ****             dprint("ACT_COMMAND");
1030:tmk_core/common/action.c ****             break;
1031:tmk_core/common/action.c ****         case ACT_FUNCTION:
1032:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1033:tmk_core/common/action.c ****             break;
1034:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1035:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1036:tmk_core/common/action.c ****             break;
1037:tmk_core/common/action.c ****         default:
1038:tmk_core/common/action.c ****             dprint("UNKNOWN");
1039:tmk_core/common/action.c ****             break;
1040:tmk_core/common/action.c ****     }
1041:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
1042:tmk_core/common/action.c **** }
 1848               		.loc 1 1042 0
 1849 0000 0895      		ret
 1850               		.cfi_endproc
 1851               	.LFE31:
 1853               	.global	disable_action_cache
 1854               		.section	.bss.disable_action_cache,"aw",@nobits
 1857               	disable_action_cache:
 1858 0000 00        		.zero	1
 1859               		.comm	tp_buttons,2,1
 1860               		.text
 1861               	.Letext0:
 1862               		.file 4 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdint.h"
 1863               		.file 5 "tmk_core/common/keycode.h"
 1864               		.file 6 "tmk_core/common/report.h"
 1865               		.file 7 "tmk_core/common/host.h"
 1866               		.file 8 "tmk_core/common/mousekey.h"
 1867               		.file 9 "tmk_core/common/command.h"
 1868               		.file 10 "tmk_core/common/action_code.h"
 1869               		.file 11 "tmk_core/common/action.h"
 1870               		.file 12 "tmk_core/common/action_layer.h"
 1871               		.file 13 "tmk_core/common/action_util.h"
 1872               		.file 14 "tmk_core/common/debug.h"
 1873               		.file 15 "tmk_core/common/led.h"
 1874               		.file 16 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/tmp//cccXsuzR.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//cccXsuzR.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//cccXsuzR.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//cccXsuzR.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//cccXsuzR.s:6      *ABS*:0000000000000001 __zero_reg__
/var/tmp//cccXsuzR.s:13     .text.action_exec:0000000000000000 action_exec
/var/tmp//cccXsuzR.s:89     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/tmp//cccXsuzR.s:109    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/tmp//cccXsuzR.s:131    .text.register_code:0000000000000000 register_code
/var/tmp//cccXsuzR.s:466    .text.unregister_code:0000000000000000 unregister_code
/var/tmp//cccXsuzR.s:545    .text.tap_code:0000000000000000 tap_code
/var/tmp//cccXsuzR.s:598    .text.register_mods:0000000000000000 register_mods
/var/tmp//cccXsuzR.s:626    .text.unregister_mods:0000000000000000 unregister_mods
/var/tmp//cccXsuzR.s:654    .text.process_action:0000000000000000 process_action
/var/tmp//cccXsuzR.s:1461   .text.process_record:0000000000000000 process_record
/var/tmp//cccXsuzR.s:1564   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/tmp//cccXsuzR.s:1857   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/tmp//cccXsuzR.s:1590   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/tmp//cccXsuzR.s:1613   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/tmp//cccXsuzR.s:1633   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/tmp//cccXsuzR.s:1653   .text.is_tap_action:0000000000000000 is_tap_action
/var/tmp//cccXsuzR.s:1734   .text.is_tap_key:0000000000000000 is_tap_key
/var/tmp//cccXsuzR.s:1755   .text.debug_event:0000000000000000 debug_event
/var/tmp//cccXsuzR.s:1796   .text.debug_record:0000000000000000 debug_record
/var/tmp//cccXsuzR.s:1838   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
add_key
send_keyboard_report
add_mods
host_system_send
host_consumer_send
del_key
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
host_keyboard_leds
led_set
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_clear_bss

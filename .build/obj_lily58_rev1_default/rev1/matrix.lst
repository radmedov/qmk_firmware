   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB28:
  14               		.file 1 "keyboards/lily58/rev1/matrix.c"
   1:keyboards/lily58/rev1/matrix.c **** /*
   2:keyboards/lily58/rev1/matrix.c **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:keyboards/lily58/rev1/matrix.c **** 
   4:keyboards/lily58/rev1/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:keyboards/lily58/rev1/matrix.c **** it under the terms of the GNU General Public License as published by
   6:keyboards/lily58/rev1/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:keyboards/lily58/rev1/matrix.c **** (at your option) any later version.
   8:keyboards/lily58/rev1/matrix.c **** 
   9:keyboards/lily58/rev1/matrix.c **** This program is distributed in the hope that it will be useful,
  10:keyboards/lily58/rev1/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:keyboards/lily58/rev1/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:keyboards/lily58/rev1/matrix.c **** GNU General Public License for more details.
  13:keyboards/lily58/rev1/matrix.c **** 
  14:keyboards/lily58/rev1/matrix.c **** You should have received a copy of the GNU General Public License
  15:keyboards/lily58/rev1/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:keyboards/lily58/rev1/matrix.c **** */
  17:keyboards/lily58/rev1/matrix.c **** 
  18:keyboards/lily58/rev1/matrix.c **** /*
  19:keyboards/lily58/rev1/matrix.c ****  * scan matrix
  20:keyboards/lily58/rev1/matrix.c ****  */
  21:keyboards/lily58/rev1/matrix.c **** #include <stdint.h>
  22:keyboards/lily58/rev1/matrix.c **** #include <stdbool.h>
  23:keyboards/lily58/rev1/matrix.c **** #include <string.h>
  24:keyboards/lily58/rev1/matrix.c **** #include <avr/io.h>
  25:keyboards/lily58/rev1/matrix.c **** #include <avr/wdt.h>
  26:keyboards/lily58/rev1/matrix.c **** #include <avr/interrupt.h>
  27:keyboards/lily58/rev1/matrix.c **** #include <util/delay.h>
  28:keyboards/lily58/rev1/matrix.c **** #include "print.h"
  29:keyboards/lily58/rev1/matrix.c **** #include "debug.h"
  30:keyboards/lily58/rev1/matrix.c **** #include "util.h"
  31:keyboards/lily58/rev1/matrix.c **** #include "matrix.h"
  32:keyboards/lily58/rev1/matrix.c **** #include "split_util.h"
  33:keyboards/lily58/rev1/matrix.c **** #include "pro_micro.h"
  34:keyboards/lily58/rev1/matrix.c **** 
  35:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
  36:keyboards/lily58/rev1/matrix.c **** #  include "i2c.h"
  37:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
  38:keyboards/lily58/rev1/matrix.c **** #  include "split_scomm.h"
  39:keyboards/lily58/rev1/matrix.c **** #endif
  40:keyboards/lily58/rev1/matrix.c **** 
  41:keyboards/lily58/rev1/matrix.c **** #ifndef DEBOUNCE
  42:keyboards/lily58/rev1/matrix.c **** #  define DEBOUNCE	5
  43:keyboards/lily58/rev1/matrix.c **** #endif
  44:keyboards/lily58/rev1/matrix.c **** 
  45:keyboards/lily58/rev1/matrix.c **** #define ERROR_DISCONNECT_COUNT 5
  46:keyboards/lily58/rev1/matrix.c **** 
  47:keyboards/lily58/rev1/matrix.c **** static uint8_t debouncing = DEBOUNCE;
  48:keyboards/lily58/rev1/matrix.c **** static const int ROWS_PER_HAND = MATRIX_ROWS/2;
  49:keyboards/lily58/rev1/matrix.c **** static uint8_t error_count = 0;
  50:keyboards/lily58/rev1/matrix.c **** uint8_t is_master = 0 ;
  51:keyboards/lily58/rev1/matrix.c **** 
  52:keyboards/lily58/rev1/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  53:keyboards/lily58/rev1/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  54:keyboards/lily58/rev1/matrix.c **** 
  55:keyboards/lily58/rev1/matrix.c **** /* matrix state(1:on, 0:off) */
  56:keyboards/lily58/rev1/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  57:keyboards/lily58/rev1/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  58:keyboards/lily58/rev1/matrix.c **** 
  59:keyboards/lily58/rev1/matrix.c **** static matrix_row_t read_cols(void);
  60:keyboards/lily58/rev1/matrix.c **** static void init_cols(void);
  61:keyboards/lily58/rev1/matrix.c **** static void unselect_rows(void);
  62:keyboards/lily58/rev1/matrix.c **** static void select_row(uint8_t row);
  63:keyboards/lily58/rev1/matrix.c **** static uint8_t matrix_master_scan(void);
  64:keyboards/lily58/rev1/matrix.c **** 
  65:keyboards/lily58/rev1/matrix.c **** 
  66:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  67:keyboards/lily58/rev1/matrix.c **** void matrix_init_kb(void) {
  68:keyboards/lily58/rev1/matrix.c ****     matrix_init_user();
  69:keyboards/lily58/rev1/matrix.c **** }
  70:keyboards/lily58/rev1/matrix.c **** 
  71:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  72:keyboards/lily58/rev1/matrix.c **** void matrix_scan_kb(void) {
  73:keyboards/lily58/rev1/matrix.c ****     matrix_scan_user();
  74:keyboards/lily58/rev1/matrix.c **** }
  75:keyboards/lily58/rev1/matrix.c **** 
  76:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  77:keyboards/lily58/rev1/matrix.c **** void matrix_init_user(void) {
  78:keyboards/lily58/rev1/matrix.c **** }
  79:keyboards/lily58/rev1/matrix.c **** 
  80:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  81:keyboards/lily58/rev1/matrix.c **** void matrix_scan_user(void) {
  82:keyboards/lily58/rev1/matrix.c **** }
  83:keyboards/lily58/rev1/matrix.c **** 
  84:keyboards/lily58/rev1/matrix.c **** inline
  85:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_rows(void)
  86:keyboards/lily58/rev1/matrix.c **** {
  87:keyboards/lily58/rev1/matrix.c ****     return MATRIX_ROWS;
  88:keyboards/lily58/rev1/matrix.c **** }
  89:keyboards/lily58/rev1/matrix.c **** 
  90:keyboards/lily58/rev1/matrix.c **** inline
  91:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_cols(void)
  92:keyboards/lily58/rev1/matrix.c **** {
  93:keyboards/lily58/rev1/matrix.c ****     return MATRIX_COLS;
  94:keyboards/lily58/rev1/matrix.c **** }
  95:keyboards/lily58/rev1/matrix.c **** 
  96:keyboards/lily58/rev1/matrix.c **** void matrix_init(void)
  97:keyboards/lily58/rev1/matrix.c **** {
  98:keyboards/lily58/rev1/matrix.c ****     debug_enable = true;
  99:keyboards/lily58/rev1/matrix.c ****     debug_matrix = true;
 100:keyboards/lily58/rev1/matrix.c ****     debug_mouse = true;
 101:keyboards/lily58/rev1/matrix.c ****     // initialize row and col
 102:keyboards/lily58/rev1/matrix.c ****     unselect_rows();
 103:keyboards/lily58/rev1/matrix.c ****     init_cols();
 104:keyboards/lily58/rev1/matrix.c **** 
 105:keyboards/lily58/rev1/matrix.c ****     TX_RX_LED_INIT;
 106:keyboards/lily58/rev1/matrix.c ****     TXLED0;
 107:keyboards/lily58/rev1/matrix.c ****     RXLED0;
 108:keyboards/lily58/rev1/matrix.c **** 
 109:keyboards/lily58/rev1/matrix.c ****     // initialize matrix state: all keys off
 110:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 111:keyboards/lily58/rev1/matrix.c ****         matrix[i] = 0;
 112:keyboards/lily58/rev1/matrix.c ****         matrix_debouncing[i] = 0;
 113:keyboards/lily58/rev1/matrix.c ****     }
 114:keyboards/lily58/rev1/matrix.c **** 
 115:keyboards/lily58/rev1/matrix.c ****     is_master = has_usb();
 116:keyboards/lily58/rev1/matrix.c **** 
 117:keyboards/lily58/rev1/matrix.c ****     matrix_init_quantum();
 118:keyboards/lily58/rev1/matrix.c **** }
 119:keyboards/lily58/rev1/matrix.c **** 
 120:keyboards/lily58/rev1/matrix.c **** uint8_t _matrix_scan(void)
 121:keyboards/lily58/rev1/matrix.c **** {
 122:keyboards/lily58/rev1/matrix.c ****     // Right hand is stored after the left in the matirx so, we need to offset it
 123:keyboards/lily58/rev1/matrix.c ****     int offset = isLeftHand ? 0 : (ROWS_PER_HAND);
 124:keyboards/lily58/rev1/matrix.c **** 
 125:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 126:keyboards/lily58/rev1/matrix.c ****         select_row(i);
 127:keyboards/lily58/rev1/matrix.c ****         _delay_us(30);  // without this wait read unstable value.
 128:keyboards/lily58/rev1/matrix.c ****         matrix_row_t cols = read_cols();
 129:keyboards/lily58/rev1/matrix.c ****         if (matrix_debouncing[i+offset] != cols) {
 130:keyboards/lily58/rev1/matrix.c ****             matrix_debouncing[i+offset] = cols;
 131:keyboards/lily58/rev1/matrix.c ****             debouncing = DEBOUNCE;
 132:keyboards/lily58/rev1/matrix.c ****         }
 133:keyboards/lily58/rev1/matrix.c ****         unselect_rows();
 134:keyboards/lily58/rev1/matrix.c ****     }
 135:keyboards/lily58/rev1/matrix.c **** 
 136:keyboards/lily58/rev1/matrix.c ****     if (debouncing) {
 137:keyboards/lily58/rev1/matrix.c ****         if (--debouncing) {
 138:keyboards/lily58/rev1/matrix.c ****             _delay_ms(1);
 139:keyboards/lily58/rev1/matrix.c ****         } else {
 140:keyboards/lily58/rev1/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 141:keyboards/lily58/rev1/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 142:keyboards/lily58/rev1/matrix.c ****             }
 143:keyboards/lily58/rev1/matrix.c ****         }
 144:keyboards/lily58/rev1/matrix.c ****     }
 145:keyboards/lily58/rev1/matrix.c **** 
 146:keyboards/lily58/rev1/matrix.c ****     return 1;
 147:keyboards/lily58/rev1/matrix.c **** }
 148:keyboards/lily58/rev1/matrix.c **** 
 149:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 150:keyboards/lily58/rev1/matrix.c **** 
 151:keyboards/lily58/rev1/matrix.c **** // Get rows from other half over i2c
 152:keyboards/lily58/rev1/matrix.c **** int i2c_transaction(void) {
 153:keyboards/lily58/rev1/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 154:keyboards/lily58/rev1/matrix.c **** 
 155:keyboards/lily58/rev1/matrix.c ****     int err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_WRITE);
 156:keyboards/lily58/rev1/matrix.c ****     if (err) goto i2c_error;
 157:keyboards/lily58/rev1/matrix.c **** 
 158:keyboards/lily58/rev1/matrix.c ****     // start of matrix stored at 0x00
 159:keyboards/lily58/rev1/matrix.c ****     err = i2c_master_write(0x00);
 160:keyboards/lily58/rev1/matrix.c ****     if (err) goto i2c_error;
 161:keyboards/lily58/rev1/matrix.c **** 
 162:keyboards/lily58/rev1/matrix.c ****     // Start read
 163:keyboards/lily58/rev1/matrix.c ****     err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_READ);
 164:keyboards/lily58/rev1/matrix.c ****     if (err) goto i2c_error;
 165:keyboards/lily58/rev1/matrix.c **** 
 166:keyboards/lily58/rev1/matrix.c ****     if (!err) {
 167:keyboards/lily58/rev1/matrix.c ****         int i;
 168:keyboards/lily58/rev1/matrix.c ****         for (i = 0; i < ROWS_PER_HAND-1; ++i) {
 169:keyboards/lily58/rev1/matrix.c ****             matrix[slaveOffset+i] = i2c_master_read(I2C_ACK);
 170:keyboards/lily58/rev1/matrix.c ****         }
 171:keyboards/lily58/rev1/matrix.c ****         matrix[slaveOffset+i] = i2c_master_read(I2C_NACK);
 172:keyboards/lily58/rev1/matrix.c ****         i2c_master_stop();
 173:keyboards/lily58/rev1/matrix.c ****     } else {
 174:keyboards/lily58/rev1/matrix.c **** i2c_error: // the cable is disconnceted, or something else went wrong
 175:keyboards/lily58/rev1/matrix.c ****         i2c_reset_state();
 176:keyboards/lily58/rev1/matrix.c ****         return err;
 177:keyboards/lily58/rev1/matrix.c ****     }
 178:keyboards/lily58/rev1/matrix.c **** 
 179:keyboards/lily58/rev1/matrix.c ****     return 0;
 180:keyboards/lily58/rev1/matrix.c **** }
 181:keyboards/lily58/rev1/matrix.c **** 
 182:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 183:keyboards/lily58/rev1/matrix.c **** 
 184:keyboards/lily58/rev1/matrix.c **** int serial_transaction(int master_changed) {
 185:keyboards/lily58/rev1/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 186:keyboards/lily58/rev1/matrix.c **** #ifdef SERIAL_USE_MULTI_TRANSACTION
 187:keyboards/lily58/rev1/matrix.c ****     int ret=serial_update_buffers(master_changed);
 188:keyboards/lily58/rev1/matrix.c **** #else
 189:keyboards/lily58/rev1/matrix.c ****     int ret=serial_update_buffers();
 190:keyboards/lily58/rev1/matrix.c **** #endif
 191:keyboards/lily58/rev1/matrix.c ****     if (ret ) {
 192:keyboards/lily58/rev1/matrix.c ****         if(ret==2) RXLED1;
 193:keyboards/lily58/rev1/matrix.c ****         return 1;
 194:keyboards/lily58/rev1/matrix.c ****     }
 195:keyboards/lily58/rev1/matrix.c ****     RXLED0;
 196:keyboards/lily58/rev1/matrix.c ****     memcpy(&matrix[slaveOffset],
 197:keyboards/lily58/rev1/matrix.c ****         (void *)serial_slave_buffer, SERIAL_SLAVE_BUFFER_LENGTH);
 198:keyboards/lily58/rev1/matrix.c ****     return 0;
 199:keyboards/lily58/rev1/matrix.c **** }
 200:keyboards/lily58/rev1/matrix.c **** #endif
 201:keyboards/lily58/rev1/matrix.c **** 
 202:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_scan(void)
 203:keyboards/lily58/rev1/matrix.c **** {
 204:keyboards/lily58/rev1/matrix.c ****     if (is_master) {
 205:keyboards/lily58/rev1/matrix.c ****         matrix_master_scan();
 206:keyboards/lily58/rev1/matrix.c ****     }else{
 207:keyboards/lily58/rev1/matrix.c ****         matrix_slave_scan();
 208:keyboards/lily58/rev1/matrix.c ****         int offset = (isLeftHand) ? ROWS_PER_HAND : 0;
 209:keyboards/lily58/rev1/matrix.c ****         memcpy(&matrix[offset],
 210:keyboards/lily58/rev1/matrix.c ****                (void *)serial_master_buffer, SERIAL_MASTER_BUFFER_LENGTH);
 211:keyboards/lily58/rev1/matrix.c ****         matrix_scan_quantum();
 212:keyboards/lily58/rev1/matrix.c ****     }
 213:keyboards/lily58/rev1/matrix.c ****     return 1;
 214:keyboards/lily58/rev1/matrix.c **** }
 215:keyboards/lily58/rev1/matrix.c **** 
 216:keyboards/lily58/rev1/matrix.c **** 
 217:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_master_scan(void) {
 218:keyboards/lily58/rev1/matrix.c **** 
 219:keyboards/lily58/rev1/matrix.c ****     int ret = _matrix_scan();
 220:keyboards/lily58/rev1/matrix.c ****     int mchanged = 1;
 221:keyboards/lily58/rev1/matrix.c **** 
 222:keyboards/lily58/rev1/matrix.c ****     int offset = (isLeftHand) ? 0 : ROWS_PER_HAND;
 223:keyboards/lily58/rev1/matrix.c **** 
 224:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 225:keyboards/lily58/rev1/matrix.c **** //    for (int i = 0; i < ROWS_PER_HAND; ++i) {
 226:keyboards/lily58/rev1/matrix.c ****         /* i2c_slave_buffer[i] = matrix[offset+i]; */
 227:keyboards/lily58/rev1/matrix.c **** //        i2c_slave_buffer[i] = matrix[offset+i];
 228:keyboards/lily58/rev1/matrix.c **** //    }
 229:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 230:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 231:keyboards/lily58/rev1/matrix.c ****     mchanged = memcmp((void *)serial_master_buffer,
 232:keyboards/lily58/rev1/matrix.c **** 		      &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 233:keyboards/lily58/rev1/matrix.c ****   #endif
 234:keyboards/lily58/rev1/matrix.c ****     memcpy((void *)serial_master_buffer,
 235:keyboards/lily58/rev1/matrix.c **** 	   &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 236:keyboards/lily58/rev1/matrix.c **** #endif
 237:keyboards/lily58/rev1/matrix.c **** 
 238:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 239:keyboards/lily58/rev1/matrix.c ****     if( i2c_transaction() ) {
 240:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 241:keyboards/lily58/rev1/matrix.c ****     if( serial_transaction(mchanged) ) {
 242:keyboards/lily58/rev1/matrix.c **** #endif
 243:keyboards/lily58/rev1/matrix.c ****         // turn on the indicator led when halves are disconnected
 244:keyboards/lily58/rev1/matrix.c ****         TXLED1;
 245:keyboards/lily58/rev1/matrix.c **** 
 246:keyboards/lily58/rev1/matrix.c ****         error_count++;
 247:keyboards/lily58/rev1/matrix.c **** 
 248:keyboards/lily58/rev1/matrix.c ****         if (error_count > ERROR_DISCONNECT_COUNT) {
 249:keyboards/lily58/rev1/matrix.c ****             // reset other half if disconnected
 250:keyboards/lily58/rev1/matrix.c ****             int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 251:keyboards/lily58/rev1/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 252:keyboards/lily58/rev1/matrix.c ****                 matrix[slaveOffset+i] = 0;
 253:keyboards/lily58/rev1/matrix.c ****             }
 254:keyboards/lily58/rev1/matrix.c ****         }
 255:keyboards/lily58/rev1/matrix.c ****     } else {
 256:keyboards/lily58/rev1/matrix.c ****         // turn off the indicator led on no error
 257:keyboards/lily58/rev1/matrix.c ****         TXLED0;
 258:keyboards/lily58/rev1/matrix.c ****         error_count = 0;
 259:keyboards/lily58/rev1/matrix.c ****     }
 260:keyboards/lily58/rev1/matrix.c ****     matrix_scan_quantum();
 261:keyboards/lily58/rev1/matrix.c ****     return ret;
 262:keyboards/lily58/rev1/matrix.c **** }
 263:keyboards/lily58/rev1/matrix.c **** 
 264:keyboards/lily58/rev1/matrix.c **** void matrix_slave_scan(void) {
 265:keyboards/lily58/rev1/matrix.c ****     _matrix_scan();
 266:keyboards/lily58/rev1/matrix.c **** 
 267:keyboards/lily58/rev1/matrix.c ****     int offset = (isLeftHand) ? 0 : ROWS_PER_HAND;
 268:keyboards/lily58/rev1/matrix.c **** 
 269:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 270:keyboards/lily58/rev1/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 271:keyboards/lily58/rev1/matrix.c ****         /* i2c_slave_buffer[i] = matrix[offset+i]; */
 272:keyboards/lily58/rev1/matrix.c ****         i2c_slave_buffer[i] = matrix[offset+i];
 273:keyboards/lily58/rev1/matrix.c ****     }
 274:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 275:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 276:keyboards/lily58/rev1/matrix.c ****     int change = 0;
 277:keyboards/lily58/rev1/matrix.c ****   #endif
 278:keyboards/lily58/rev1/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 279:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 280:keyboards/lily58/rev1/matrix.c ****         if( serial_slave_buffer[i] != matrix[offset+i] )
 281:keyboards/lily58/rev1/matrix.c **** 	    change = 1;
 282:keyboards/lily58/rev1/matrix.c ****   #endif
 283:keyboards/lily58/rev1/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 284:keyboards/lily58/rev1/matrix.c ****     }
 285:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 286:keyboards/lily58/rev1/matrix.c ****     slave_buffer_change_count += change;
 287:keyboards/lily58/rev1/matrix.c ****   #endif
 288:keyboards/lily58/rev1/matrix.c **** #endif
 289:keyboards/lily58/rev1/matrix.c **** }
 290:keyboards/lily58/rev1/matrix.c **** 
 291:keyboards/lily58/rev1/matrix.c **** bool matrix_is_modified(void)
 292:keyboards/lily58/rev1/matrix.c **** {
 293:keyboards/lily58/rev1/matrix.c ****     if (debouncing) return false;
 294:keyboards/lily58/rev1/matrix.c ****     return true;
 295:keyboards/lily58/rev1/matrix.c **** }
 296:keyboards/lily58/rev1/matrix.c **** 
 297:keyboards/lily58/rev1/matrix.c **** inline
 298:keyboards/lily58/rev1/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 299:keyboards/lily58/rev1/matrix.c **** {
 300:keyboards/lily58/rev1/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 301:keyboards/lily58/rev1/matrix.c **** }
 302:keyboards/lily58/rev1/matrix.c **** 
 303:keyboards/lily58/rev1/matrix.c **** inline
 304:keyboards/lily58/rev1/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 305:keyboards/lily58/rev1/matrix.c **** {
 306:keyboards/lily58/rev1/matrix.c ****     return matrix[row];
 307:keyboards/lily58/rev1/matrix.c **** }
 308:keyboards/lily58/rev1/matrix.c **** 
 309:keyboards/lily58/rev1/matrix.c **** void matrix_print(void)
 310:keyboards/lily58/rev1/matrix.c **** {
 311:keyboards/lily58/rev1/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 312:keyboards/lily58/rev1/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 313:keyboards/lily58/rev1/matrix.c ****         phex(row); print(": ");
 314:keyboards/lily58/rev1/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 315:keyboards/lily58/rev1/matrix.c ****         print("\n");
 316:keyboards/lily58/rev1/matrix.c ****     }
 317:keyboards/lily58/rev1/matrix.c **** }
 318:keyboards/lily58/rev1/matrix.c **** 
 319:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_key_count(void)
 320:keyboards/lily58/rev1/matrix.c **** {
 321:keyboards/lily58/rev1/matrix.c ****     uint8_t count = 0;
 322:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 323:keyboards/lily58/rev1/matrix.c ****         count += bitpop16(matrix[i]);
 324:keyboards/lily58/rev1/matrix.c ****     }
 325:keyboards/lily58/rev1/matrix.c ****     return count;
 326:keyboards/lily58/rev1/matrix.c **** }
 327:keyboards/lily58/rev1/matrix.c **** 
 328:keyboards/lily58/rev1/matrix.c **** static void  init_cols(void)
 329:keyboards/lily58/rev1/matrix.c **** {
 330:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 331:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 1) &=  ~_BV(col_pins[x] & 0xF);
 332:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 2) |= _BV(col_pins[x] & 0xF);
 333:keyboards/lily58/rev1/matrix.c ****     }
 334:keyboards/lily58/rev1/matrix.c **** }
 335:keyboards/lily58/rev1/matrix.c **** 
 336:keyboards/lily58/rev1/matrix.c **** static matrix_row_t read_cols(void)
 337:keyboards/lily58/rev1/matrix.c **** {
 338:keyboards/lily58/rev1/matrix.c ****     matrix_row_t result = 0;
 339:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 340:keyboards/lily58/rev1/matrix.c ****         result |= (_SFR_IO8(col_pins[x] >> 4) & _BV(col_pins[x] & 0xF)) ? 0 : (1 << x);
 341:keyboards/lily58/rev1/matrix.c ****     }
 342:keyboards/lily58/rev1/matrix.c ****     return result;
 343:keyboards/lily58/rev1/matrix.c **** }
 344:keyboards/lily58/rev1/matrix.c **** 
 345:keyboards/lily58/rev1/matrix.c **** static void unselect_rows(void)
 346:keyboards/lily58/rev1/matrix.c **** {
  15               		.loc 1 346 0
  16               		.cfi_startproc
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21 0002 DF93      		push r29
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 29, -3
  25               	/* prologue: function */
  26               	/* frame size = 0 */
  27               	/* stack size = 2 */
  28               	.L__stack_usage = 2
  29               	.LVL0:
  30 0004 A0E0      		ldi r26,lo8(row_pins)
  31 0006 B0E0      		ldi r27,hi8(row_pins)
  32 0008 40E0      		ldi r20,lo8(row_pins+5)
  33 000a 50E0      		ldi r21,hi8(row_pins+5)
  34               	.LBB9:
 347:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < ROWS_PER_HAND; x++) {
 348:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((row_pins[x] >> 4) + 1) &=  ~_BV(row_pins[x] & 0xF);
  35               		.loc 1 348 0
  36 000c C1E0      		ldi r28,lo8(1)
  37 000e D0E0      		ldi r29,0
  38               	.LVL1:
  39               	.L2:
  40               		.loc 1 348 0 is_stmt 0 discriminator 3
  41 0010 8D91      		ld r24,X+
  42               	.LVL2:
  43 0012 E82F      		mov r30,r24
  44 0014 E295      		swap r30
  45 0016 EF70      		andi r30,lo8(15)
  46 0018 F0E0      		ldi r31,0
  47 001a 61A1      		ldd r22,Z+33
  48 001c 8F70      		andi r24,lo8(15)
  49 001e 9E01      		movw r18,r28
  50 0020 00C0      		rjmp 2f
  51               		1:
  52 0022 220F      		lsl r18
  53               		2:
  54 0024 8A95      		dec r24
  55 0026 02F4      		brpl 1b
  56 0028 922F      		mov r25,r18
  57 002a 9095      		com r25
  58 002c 9623      		and r25,r22
  59 002e 91A3      		std Z+33,r25
 349:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((row_pins[x] >> 4) + 2) |= _BV(row_pins[x] & 0xF);
  60               		.loc 1 349 0 is_stmt 1 discriminator 3
  61 0030 82A1      		ldd r24,Z+34
  62 0032 822B      		or r24,r18
  63 0034 82A3      		std Z+34,r24
  64               	.LVL3:
 347:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < ROWS_PER_HAND; x++) {
  65               		.loc 1 347 0 discriminator 3
  66 0036 4A17      		cp r20,r26
  67 0038 5B07      		cpc r21,r27
  68 003a 01F4      		brne .L2
  69               	/* epilogue start */
  70               	.LBE9:
 350:keyboards/lily58/rev1/matrix.c ****     }
 351:keyboards/lily58/rev1/matrix.c **** }
  71               		.loc 1 351 0
  72 003c DF91      		pop r29
  73 003e CF91      		pop r28
  74 0040 0895      		ret
  75               		.cfi_endproc
  76               	.LFE28:
  78               		.section	.text.matrix_init_user,"ax",@progbits
  79               		.weak	matrix_init_user
  81               	matrix_init_user:
  82               	.LFB11:
  77:keyboards/lily58/rev1/matrix.c **** }
  83               		.loc 1 77 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
  89               	/* epilogue start */
  78:keyboards/lily58/rev1/matrix.c **** 
  90               		.loc 1 78 0
  91 0000 0895      		ret
  92               		.cfi_endproc
  93               	.LFE11:
  95               		.set	matrix_init_user.localalias.0,matrix_init_user
  96               		.section	.text.matrix_init_kb,"ax",@progbits
  97               		.weak	matrix_init_kb
  99               	matrix_init_kb:
 100               	.LFB9:
  67:keyboards/lily58/rev1/matrix.c ****     matrix_init_user();
 101               		.loc 1 67 0
 102               		.cfi_startproc
 103               	/* prologue: function */
 104               	/* frame size = 0 */
 105               	/* stack size = 0 */
 106               	.L__stack_usage = 0
  68:keyboards/lily58/rev1/matrix.c **** }
 107               		.loc 1 68 0
 108 0000 0C94 0000 		jmp matrix_init_user
 109               	.LVL4:
 110               		.cfi_endproc
 111               	.LFE9:
 113               		.section	.text.matrix_scan_user,"ax",@progbits
 114               		.weak	matrix_scan_user
 116               	matrix_scan_user:
 117               	.LFB31:
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 123               	/* epilogue start */
 124 0000 0895      		ret
 125               		.cfi_endproc
 126               	.LFE31:
 128               		.section	.text.matrix_scan_kb,"ax",@progbits
 129               		.weak	matrix_scan_kb
 131               	matrix_scan_kb:
 132               	.LFB10:
  72:keyboards/lily58/rev1/matrix.c ****     matrix_scan_user();
 133               		.loc 1 72 0
 134               		.cfi_startproc
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  73:keyboards/lily58/rev1/matrix.c **** }
 139               		.loc 1 73 0
 140 0000 0C94 0000 		jmp matrix_scan_user
 141               	.LVL5:
 142               		.cfi_endproc
 143               	.LFE10:
 145               		.section	.text.matrix_rows,"ax",@progbits
 146               	.global	matrix_rows
 148               	matrix_rows:
 149               	.LFB13:
  86:keyboards/lily58/rev1/matrix.c ****     return MATRIX_ROWS;
 150               		.loc 1 86 0
 151               		.cfi_startproc
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  88:keyboards/lily58/rev1/matrix.c **** 
 156               		.loc 1 88 0
 157 0000 8AE0      		ldi r24,lo8(10)
 158               	/* epilogue start */
 159 0002 0895      		ret
 160               		.cfi_endproc
 161               	.LFE13:
 163               		.section	.text.matrix_cols,"ax",@progbits
 164               	.global	matrix_cols
 166               	matrix_cols:
 167               	.LFB14:
  92:keyboards/lily58/rev1/matrix.c ****     return MATRIX_COLS;
 168               		.loc 1 92 0
 169               		.cfi_startproc
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 0 */
 173               	.L__stack_usage = 0
  94:keyboards/lily58/rev1/matrix.c **** 
 174               		.loc 1 94 0
 175 0000 86E0      		ldi r24,lo8(6)
 176               	/* epilogue start */
 177 0002 0895      		ret
 178               		.cfi_endproc
 179               	.LFE14:
 181               		.section	.text.matrix_init,"ax",@progbits
 182               	.global	matrix_init
 184               	matrix_init:
 185               	.LFB15:
  97:keyboards/lily58/rev1/matrix.c ****     debug_enable = true;
 186               		.loc 1 97 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
  98:keyboards/lily58/rev1/matrix.c ****     debug_matrix = true;
 192               		.loc 1 98 0
 193 0000 8091 0000 		lds r24,debug_config
 100:keyboards/lily58/rev1/matrix.c ****     // initialize row and col
 194               		.loc 1 100 0
 195 0004 8360      		ori r24,lo8(3)
 196 0006 8860      		ori r24,lo8(1<<3)
 197 0008 8093 0000 		sts debug_config,r24
 102:keyboards/lily58/rev1/matrix.c ****     init_cols();
 198               		.loc 1 102 0
 199 000c 0E94 0000 		call unselect_rows
 200               	.LVL6:
 201 0010 A0E0      		ldi r26,lo8(col_pins)
 202 0012 B0E0      		ldi r27,hi8(col_pins)
 203               	.LBB14:
 204               	.LBB15:
 331:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 2) |= _BV(col_pins[x] & 0xF);
 205               		.loc 1 331 0
 206 0014 61E0      		ldi r22,lo8(1)
 207 0016 70E0      		ldi r23,0
 208               	.LVL7:
 209               	.L11:
 210 0018 8D91      		ld r24,X+
 211               	.LVL8:
 212 001a E82F      		mov r30,r24
 213 001c E295      		swap r30
 214 001e EF70      		andi r30,lo8(15)
 215 0020 F0E0      		ldi r31,0
 216 0022 41A1      		ldd r20,Z+33
 217 0024 8F70      		andi r24,lo8(15)
 218 0026 9B01      		movw r18,r22
 219 0028 00C0      		rjmp 2f
 220               		1:
 221 002a 220F      		lsl r18
 222               		2:
 223 002c 8A95      		dec r24
 224 002e 02F4      		brpl 1b
 225 0030 922F      		mov r25,r18
 226 0032 9095      		com r25
 227 0034 9423      		and r25,r20
 228 0036 91A3      		std Z+33,r25
 332:keyboards/lily58/rev1/matrix.c ****     }
 229               		.loc 1 332 0
 230 0038 82A1      		ldd r24,Z+34
 231 003a 822B      		or r24,r18
 232 003c 82A3      		std Z+34,r24
 233               	.LVL9:
 330:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 1) &=  ~_BV(col_pins[x] & 0xF);
 234               		.loc 1 330 0
 235 003e 80E0      		ldi r24,hi8(col_pins+6)
 236 0040 A030      		cpi r26,lo8(col_pins+6)
 237 0042 B807      		cpc r27,r24
 238 0044 01F4      		brne .L11
 239               	.LVL10:
 240               	.LBE15:
 241               	.LBE14:
 105:keyboards/lily58/rev1/matrix.c ****     TXLED0;
 242               		.loc 1 105 0
 243 0046 559A      		sbi 0xa,5
 244 0048 209A      		sbi 0x4,0
 106:keyboards/lily58/rev1/matrix.c ****     RXLED0;
 245               		.loc 1 106 0
 246 004a 5D9A      		sbi 0xb,5
 107:keyboards/lily58/rev1/matrix.c **** 
 247               		.loc 1 107 0
 248 004c 289A      		sbi 0x5,0
 249               	.LVL11:
 250 004e E0E0      		ldi r30,lo8(matrix)
 251 0050 F0E0      		ldi r31,hi8(matrix)
 252 0052 A0E0      		ldi r26,lo8(matrix_debouncing)
 253 0054 B0E0      		ldi r27,hi8(matrix_debouncing)
 254               	.LVL12:
 255               	.L12:
 256               	.LBB16:
 111:keyboards/lily58/rev1/matrix.c ****         matrix_debouncing[i] = 0;
 257               		.loc 1 111 0 discriminator 3
 258 0056 1192      		st Z+,__zero_reg__
 259               	.LVL13:
 112:keyboards/lily58/rev1/matrix.c ****     }
 260               		.loc 1 112 0 discriminator 3
 261 0058 1D92      		st X+,__zero_reg__
 262               	.LVL14:
 110:keyboards/lily58/rev1/matrix.c ****         matrix[i] = 0;
 263               		.loc 1 110 0 discriminator 3
 264 005a 80E0      		ldi r24,hi8(matrix+10)
 265 005c E030      		cpi r30,lo8(matrix+10)
 266 005e F807      		cpc r31,r24
 267 0060 01F4      		brne .L12
 268               	.LBE16:
 115:keyboards/lily58/rev1/matrix.c **** 
 269               		.loc 1 115 0
 270 0062 0E94 0000 		call has_usb
 271               	.LVL15:
 272 0066 8093 0000 		sts is_master,r24
 117:keyboards/lily58/rev1/matrix.c **** }
 273               		.loc 1 117 0
 274 006a 0C94 0000 		jmp matrix_init_quantum
 275               	.LVL16:
 276               		.cfi_endproc
 277               	.LFE15:
 279               		.section	.text._matrix_scan,"ax",@progbits
 280               	.global	_matrix_scan
 282               	_matrix_scan:
 283               	.LFB16:
 121:keyboards/lily58/rev1/matrix.c ****     // Right hand is stored after the left in the matirx so, we need to offset it
 284               		.loc 1 121 0
 285               		.cfi_startproc
 286 0000 9F92      		push r9
 287               	.LCFI2:
 288               		.cfi_def_cfa_offset 3
 289               		.cfi_offset 9, -2
 290 0002 AF92      		push r10
 291               	.LCFI3:
 292               		.cfi_def_cfa_offset 4
 293               		.cfi_offset 10, -3
 294 0004 BF92      		push r11
 295               	.LCFI4:
 296               		.cfi_def_cfa_offset 5
 297               		.cfi_offset 11, -4
 298 0006 CF92      		push r12
 299               	.LCFI5:
 300               		.cfi_def_cfa_offset 6
 301               		.cfi_offset 12, -5
 302 0008 DF92      		push r13
 303               	.LCFI6:
 304               		.cfi_def_cfa_offset 7
 305               		.cfi_offset 13, -6
 306 000a EF92      		push r14
 307               	.LCFI7:
 308               		.cfi_def_cfa_offset 8
 309               		.cfi_offset 14, -7
 310 000c FF92      		push r15
 311               	.LCFI8:
 312               		.cfi_def_cfa_offset 9
 313               		.cfi_offset 15, -8
 314 000e 0F93      		push r16
 315               	.LCFI9:
 316               		.cfi_def_cfa_offset 10
 317               		.cfi_offset 16, -9
 318 0010 1F93      		push r17
 319               	.LCFI10:
 320               		.cfi_def_cfa_offset 11
 321               		.cfi_offset 17, -10
 322 0012 CF93      		push r28
 323               	.LCFI11:
 324               		.cfi_def_cfa_offset 12
 325               		.cfi_offset 28, -11
 326 0014 DF93      		push r29
 327               	.LCFI12:
 328               		.cfi_def_cfa_offset 13
 329               		.cfi_offset 29, -12
 330               	/* prologue: function */
 331               	/* frame size = 0 */
 332               	/* stack size = 11 */
 333               	.L__stack_usage = 11
 123:keyboards/lily58/rev1/matrix.c **** 
 334               		.loc 1 123 0
 335 0016 8091 0000 		lds r24,isLeftHand
 336 001a D0E0      		ldi r29,0
 337 001c C0E0      		ldi r28,0
 338 001e 8111      		cpse r24,__zero_reg__
 339 0020 00C0      		rjmp .L16
 340 0022 C5E0      		ldi r28,lo8(5)
 341 0024 D0E0      		ldi r29,0
 342               	.L16:
 343               	.LVL17:
 344 0026 80E0      		ldi r24,lo8(row_pins)
 345 0028 E82E      		mov r14,r24
 346 002a 80E0      		ldi r24,hi8(row_pins)
 347 002c F82E      		mov r15,r24
 348 002e 8E01      		movw r16,r28
 349 0030 0050      		subi r16,lo8(-(matrix_debouncing))
 350 0032 1040      		sbci r17,hi8(-(matrix_debouncing))
 123:keyboards/lily58/rev1/matrix.c **** 
 351               		.loc 1 123 0 is_stmt 0 discriminator 4
 352 0034 6801      		movw r12,r16
 353               	.LBB29:
 354               	.LBB30:
 355               	.LBB31:
 356               	.LBB32:
 352:keyboards/lily58/rev1/matrix.c **** 
 353:keyboards/lily58/rev1/matrix.c **** static void select_row(uint8_t row)
 354:keyboards/lily58/rev1/matrix.c **** {
 355:keyboards/lily58/rev1/matrix.c ****     _SFR_IO8((row_pins[row] >> 4) + 1) |=  _BV(row_pins[row] & 0xF);
 357               		.loc 1 355 0 is_stmt 1 discriminator 4
 358 0036 AA24      		clr r10
 359 0038 A394      		inc r10
 360 003a B12C      		mov r11,__zero_reg__
 361               	.LBE32:
 362               	.LBE31:
 131:keyboards/lily58/rev1/matrix.c ****         }
 363               		.loc 1 131 0 discriminator 4
 364 003c 25E0      		ldi r18,lo8(5)
 365 003e 922E      		mov r9,r18
 366               	.LVL18:
 367               	.L20:
 368               	.LBB34:
 369               	.LBB33:
 370               		.loc 1 355 0
 371 0040 F701      		movw r30,r14
 372 0042 8191      		ld r24,Z+
 373 0044 7F01      		movw r14,r30
 374               	.LVL19:
 375 0046 E82F      		mov r30,r24
 376 0048 E295      		swap r30
 377 004a EF70      		andi r30,lo8(15)
 378 004c F0E0      		ldi r31,0
 379 004e 21A1      		ldd r18,Z+33
 380 0050 8F70      		andi r24,lo8(15)
 381 0052 A501      		movw r20,r10
 382 0054 00C0      		rjmp 2f
 383               		1:
 384 0056 440F      		lsl r20
 385 0058 551F      		rol r21
 386               		2:
 387 005a 8A95      		dec r24
 388 005c 02F4      		brpl 1b
 389 005e CA01      		movw r24,r20
 390 0060 922F      		mov r25,r18
 391 0062 982B      		or r25,r24
 392 0064 91A3      		std Z+33,r25
 356:keyboards/lily58/rev1/matrix.c ****     _SFR_IO8((row_pins[row] >> 4) + 2) &= ~_BV(row_pins[row] & 0xF);
 393               		.loc 1 356 0
 394 0066 92A1      		ldd r25,Z+34
 395 0068 8095      		com r24
 396 006a 8923      		and r24,r25
 397 006c 82A3      		std Z+34,r24
 398               	.LVL20:
 399               	.LBE33:
 400               	.LBE34:
 401               	.LBB35:
 402               	.LBB36:
 403               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 404               		.loc 2 276 0
 405 006e 50EA      		ldi r21,lo8(-96)
 406 0070 5A95      	1:	dec r21
 407 0072 01F4      		brne 1b
 408               	.LVL21:
 409 0074 E0E0      		ldi r30,lo8(col_pins)
 410 0076 F0E0      		ldi r31,hi8(col_pins)
 411               	.LBE36:
 412               	.LBE35:
 413               	.LBB37:
 414               	.LBB38:
 338:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 415               		.loc 1 338 0
 416 0078 20E0      		ldi r18,0
 417               	.LBB39:
 339:keyboards/lily58/rev1/matrix.c ****         result |= (_SFR_IO8(col_pins[x] >> 4) & _BV(col_pins[x] & 0xF)) ? 0 : (1 << x);
 418               		.loc 1 339 0
 419 007a 50E0      		ldi r21,0
 420 007c 40E0      		ldi r20,0
 421               	.LVL22:
 422               	.L18:
 340:keyboards/lily58/rev1/matrix.c ****     }
 423               		.loc 1 340 0
 424 007e 3191      		ld r19,Z+
 425 0080 A32F      		mov r26,r19
 426 0082 A295      		swap r26
 427 0084 AF70      		andi r26,lo8(15)
 428 0086 B0E0      		ldi r27,0
 429 0088 9096      		adiw r26,32
 430 008a 8C91      		ld r24,X
 431 008c 90E0      		ldi r25,0
 432 008e 3F70      		andi r19,lo8(15)
 433 0090 00C0      		rjmp 2f
 434               		1:
 435 0092 9595      		asr r25
 436 0094 8795      		ror r24
 437               		2:
 438 0096 3A95      		dec r19
 439 0098 02F4      		brpl 1b
 440 009a 80FD      		sbrc r24,0
 441 009c 00C0      		rjmp .L26
 442 009e C501      		movw r24,r10
 443 00a0 042E      		mov r0,r20
 444 00a2 00C0      		rjmp 2f
 445               		1:
 446 00a4 880F      		lsl r24
 447               		2:
 448 00a6 0A94      		dec r0
 449 00a8 02F4      		brpl 1b
 450               	.L17:
 451 00aa 282B      		or r18,r24
 452               	.LVL23:
 339:keyboards/lily58/rev1/matrix.c ****         result |= (_SFR_IO8(col_pins[x] >> 4) & _BV(col_pins[x] & 0xF)) ? 0 : (1 << x);
 453               		.loc 1 339 0
 454 00ac 4F5F      		subi r20,-1
 455 00ae 5F4F      		sbci r21,-1
 456               	.LVL24:
 457 00b0 4630      		cpi r20,6
 458 00b2 5105      		cpc r21,__zero_reg__
 459 00b4 01F4      		brne .L18
 460               	.LVL25:
 461               	.LBE39:
 462               	.LBE38:
 463               	.LBE37:
 129:keyboards/lily58/rev1/matrix.c ****             matrix_debouncing[i+offset] = cols;
 464               		.loc 1 129 0
 465 00b6 F601      		movw r30,r12
 466 00b8 8191      		ld r24,Z+
 467 00ba 6F01      		movw r12,r30
 468 00bc 8217      		cp r24,r18
 469 00be 01F0      		breq .L19
 130:keyboards/lily58/rev1/matrix.c ****             debouncing = DEBOUNCE;
 470               		.loc 1 130 0
 471 00c0 3197      		sbiw r30,1
 472 00c2 2083      		st Z,r18
 131:keyboards/lily58/rev1/matrix.c ****         }
 473               		.loc 1 131 0
 474 00c4 9092 0000 		sts debouncing,r9
 475               	.L19:
 133:keyboards/lily58/rev1/matrix.c ****     }
 476               		.loc 1 133 0 discriminator 2
 477 00c8 0E94 0000 		call unselect_rows
 478               	.LVL26:
 479               	.LBE30:
 125:keyboards/lily58/rev1/matrix.c ****         select_row(i);
 480               		.loc 1 125 0 discriminator 2
 481 00cc F0E0      		ldi r31,lo8(row_pins+5)
 482 00ce EF16      		cp r14,r31
 483 00d0 F0E0      		ldi r31,hi8(row_pins+5)
 484 00d2 FF06      		cpc r15,r31
 485 00d4 01F0      		breq .+2
 486 00d6 00C0      		rjmp .L20
 487               	.LBE29:
 136:keyboards/lily58/rev1/matrix.c ****         if (--debouncing) {
 488               		.loc 1 136 0
 489 00d8 8091 0000 		lds r24,debouncing
 490 00dc 8823      		tst r24
 491 00de 01F0      		breq .L23
 137:keyboards/lily58/rev1/matrix.c ****             _delay_ms(1);
 492               		.loc 1 137 0
 493 00e0 8150      		subi r24,lo8(-(-1))
 494 00e2 8093 0000 		sts debouncing,r24
 495 00e6 8823      		tst r24
 496 00e8 01F0      		breq .L22
 497               	.LVL27:
 498               	.LBB44:
 499               	.LBB45:
 187:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 500               		.loc 2 187 0
 501 00ea 8FE9      		ldi r24,lo8(3999)
 502 00ec 9FE0      		ldi r25,hi8(3999)
 503 00ee 0197      	1:	sbiw r24,1
 504 00f0 01F4      		brne 1b
 505 00f2 00C0      		rjmp .
 506 00f4 0000      		nop
 507               	.LVL28:
 508               	.L23:
 509               	.LBE45:
 510               	.LBE44:
 147:keyboards/lily58/rev1/matrix.c **** 
 511               		.loc 1 147 0
 512 00f6 81E0      		ldi r24,lo8(1)
 513               	/* epilogue start */
 514 00f8 DF91      		pop r29
 515 00fa CF91      		pop r28
 516 00fc 1F91      		pop r17
 517 00fe 0F91      		pop r16
 518 0100 FF90      		pop r15
 519 0102 EF90      		pop r14
 520               	.LVL29:
 521 0104 DF90      		pop r13
 522 0106 CF90      		pop r12
 523 0108 BF90      		pop r11
 524 010a AF90      		pop r10
 525 010c 9F90      		pop r9
 526 010e 0895      		ret
 527               	.LVL30:
 528               	.L26:
 529               	.LBB46:
 530               	.LBB43:
 531               	.LBB42:
 532               	.LBB41:
 533               	.LBB40:
 340:keyboards/lily58/rev1/matrix.c ****     }
 534               		.loc 1 340 0
 535 0110 80E0      		ldi r24,0
 536 0112 00C0      		rjmp .L17
 537               	.LVL31:
 538               	.L22:
 539 0114 C050      		subi r28,lo8(-(matrix))
 540 0116 D040      		sbci r29,hi8(-(matrix))
 541               	.LBE40:
 542               	.LBE41:
 543               	.LBE42:
 544               	.LBE43:
 545               	.LBE46:
 137:keyboards/lily58/rev1/matrix.c ****             _delay_ms(1);
 546               		.loc 1 137 0
 547 0118 85E0      		ldi r24,lo8(5)
 548               	.L24:
 549               	.LVL32:
 550               	.LBB47:
 141:keyboards/lily58/rev1/matrix.c ****             }
 551               		.loc 1 141 0 discriminator 3
 552 011a F801      		movw r30,r16
 553 011c 9191      		ld r25,Z+
 554 011e 8F01      		movw r16,r30
 555 0120 9993      		st Y+,r25
 556 0122 8150      		subi r24,lo8(-(-1))
 140:keyboards/lily58/rev1/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 557               		.loc 1 140 0 discriminator 3
 558 0124 01F4      		brne .L24
 559 0126 00C0      		rjmp .L23
 560               	.LBE47:
 561               		.cfi_endproc
 562               	.LFE16:
 564               		.section	.text.serial_transaction,"ax",@progbits
 565               	.global	serial_transaction
 567               	serial_transaction:
 568               	.LFB17:
 184:keyboards/lily58/rev1/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 569               		.loc 1 184 0
 570               		.cfi_startproc
 571               	.LVL33:
 572 0000 CF93      		push r28
 573               	.LCFI13:
 574               		.cfi_def_cfa_offset 3
 575               		.cfi_offset 28, -2
 576 0002 DF93      		push r29
 577               	.LCFI14:
 578               		.cfi_def_cfa_offset 4
 579               		.cfi_offset 29, -3
 580               	/* prologue: function */
 581               	/* frame size = 0 */
 582               	/* stack size = 2 */
 583               	.L__stack_usage = 2
 185:keyboards/lily58/rev1/matrix.c **** #ifdef SERIAL_USE_MULTI_TRANSACTION
 584               		.loc 1 185 0
 585 0004 2091 0000 		lds r18,isLeftHand
 586 0008 D0E0      		ldi r29,0
 587 000a C0E0      		ldi r28,0
 588 000c 2223      		tst r18
 589 000e 01F0      		breq .L34
 590 0010 C5E0      		ldi r28,lo8(5)
 591 0012 D0E0      		ldi r29,0
 592               	.L34:
 593               	.LVL34:
 187:keyboards/lily58/rev1/matrix.c **** #else
 594               		.loc 1 187 0 discriminator 4
 595 0014 0E94 0000 		call serial_update_buffers
 596               	.LVL35:
 191:keyboards/lily58/rev1/matrix.c ****         if(ret==2) RXLED1;
 597               		.loc 1 191 0 discriminator 4
 598 0018 0097      		sbiw r24,0
 599 001a 01F0      		breq .L35
 192:keyboards/lily58/rev1/matrix.c ****         return 1;
 600               		.loc 1 192 0
 601 001c 0297      		sbiw r24,2
 602 001e 01F4      		brne .L38
 192:keyboards/lily58/rev1/matrix.c ****         return 1;
 603               		.loc 1 192 0 is_stmt 0 discriminator 1
 604 0020 2898      		cbi 0x5,0
 605               	.L38:
 193:keyboards/lily58/rev1/matrix.c ****     }
 606               		.loc 1 193 0 is_stmt 1
 607 0022 81E0      		ldi r24,lo8(1)
 608 0024 90E0      		ldi r25,0
 609               	.LVL36:
 610 0026 00C0      		rjmp .L33
 611               	.LVL37:
 612               	.L35:
 195:keyboards/lily58/rev1/matrix.c ****     memcpy(&matrix[slaveOffset],
 613               		.loc 1 195 0
 614 0028 289A      		sbi 0x5,0
 196:keyboards/lily58/rev1/matrix.c ****         (void *)serial_slave_buffer, SERIAL_SLAVE_BUFFER_LENGTH);
 615               		.loc 1 196 0
 616 002a DE01      		movw r26,r28
 617 002c A050      		subi r26,lo8(-(matrix))
 618 002e B040      		sbci r27,hi8(-(matrix))
 619 0030 25E0      		ldi r18,lo8(5)
 620 0032 E0E0      		ldi r30,lo8(serial_slave_buffer)
 621 0034 F0E0      		ldi r31,hi8(serial_slave_buffer)
 622               		0:
 623 0036 0190      		ld r0,Z+
 624 0038 0D92      		st X+,r0
 625 003a 2A95      		dec r18
 626 003c 01F4      		brne 0b
 627               	.LVL38:
 628               	.L33:
 629               	/* epilogue start */
 199:keyboards/lily58/rev1/matrix.c **** #endif
 630               		.loc 1 199 0
 631 003e DF91      		pop r29
 632 0040 CF91      		pop r28
 633               	.LVL39:
 634 0042 0895      		ret
 635               		.cfi_endproc
 636               	.LFE17:
 638               		.section	.text.matrix_slave_scan,"ax",@progbits
 639               	.global	matrix_slave_scan
 641               	matrix_slave_scan:
 642               	.LFB20:
 264:keyboards/lily58/rev1/matrix.c ****     _matrix_scan();
 643               		.loc 1 264 0
 644               		.cfi_startproc
 645               	/* prologue: function */
 646               	/* frame size = 0 */
 647               	/* stack size = 0 */
 648               	.L__stack_usage = 0
 265:keyboards/lily58/rev1/matrix.c **** 
 649               		.loc 1 265 0
 650 0000 0E94 0000 		call _matrix_scan
 651               	.LVL40:
 267:keyboards/lily58/rev1/matrix.c **** 
 652               		.loc 1 267 0
 653 0004 8091 0000 		lds r24,isLeftHand
 654 0008 F0E0      		ldi r31,0
 655 000a E0E0      		ldi r30,0
 656 000c 8111      		cpse r24,__zero_reg__
 657 000e 00C0      		rjmp .L40
 658 0010 E5E0      		ldi r30,lo8(5)
 659 0012 F0E0      		ldi r31,0
 660               	.L40:
 661               	.LVL41:
 662 0014 E050      		subi r30,lo8(-(matrix))
 663 0016 F040      		sbci r31,hi8(-(matrix))
 664               	.LVL42:
 665               	.LBB48:
 278:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 666               		.loc 1 278 0 discriminator 4
 667 0018 90E0      		ldi r25,0
 668 001a 80E0      		ldi r24,0
 669               	.LBE48:
 276:keyboards/lily58/rev1/matrix.c ****   #endif
 670               		.loc 1 276 0 discriminator 4
 671 001c 20E0      		ldi r18,0
 672               	.LVL43:
 673               	.L42:
 674               	.LBB49:
 280:keyboards/lily58/rev1/matrix.c **** 	    change = 1;
 675               		.loc 1 280 0
 676 001e DC01      		movw r26,r24
 677 0020 A050      		subi r26,lo8(-(serial_slave_buffer))
 678 0022 B040      		sbci r27,hi8(-(serial_slave_buffer))
 679 0024 4C91      		ld r20,X
 680 0026 3191      		ld r19,Z+
 681 0028 4313      		cpse r20,r19
 281:keyboards/lily58/rev1/matrix.c ****   #endif
 682               		.loc 1 281 0
 683 002a 21E0      		ldi r18,lo8(1)
 684               	.LVL44:
 685               	.L41:
 283:keyboards/lily58/rev1/matrix.c ****     }
 686               		.loc 1 283 0 discriminator 2
 687 002c 3C93      		st X,r19
 278:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 688               		.loc 1 278 0 discriminator 2
 689 002e 0196      		adiw r24,1
 690               	.LVL45:
 691 0030 8530      		cpi r24,5
 692 0032 9105      		cpc r25,__zero_reg__
 693 0034 01F4      		brne .L42
 694               	.LBE49:
 286:keyboards/lily58/rev1/matrix.c ****   #endif
 695               		.loc 1 286 0
 696 0036 8091 0000 		lds r24,slave_buffer_change_count
 697               	.LVL46:
 698 003a 820F      		add r24,r18
 699 003c 8093 0000 		sts slave_buffer_change_count,r24
 700               	/* epilogue start */
 289:keyboards/lily58/rev1/matrix.c **** 
 701               		.loc 1 289 0
 702 0040 0895      		ret
 703               		.cfi_endproc
 704               	.LFE20:
 706               		.section	.text.matrix_scan,"ax",@progbits
 707               	.global	matrix_scan
 709               	matrix_scan:
 710               	.LFB18:
 203:keyboards/lily58/rev1/matrix.c ****     if (is_master) {
 711               		.loc 1 203 0
 712               		.cfi_startproc
 713 0000 CF93      		push r28
 714               	.LCFI15:
 715               		.cfi_def_cfa_offset 3
 716               		.cfi_offset 28, -2
 717 0002 DF93      		push r29
 718               	.LCFI16:
 719               		.cfi_def_cfa_offset 4
 720               		.cfi_offset 29, -3
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 2 */
 724               	.L__stack_usage = 2
 204:keyboards/lily58/rev1/matrix.c ****         matrix_master_scan();
 725               		.loc 1 204 0
 726 0004 8091 0000 		lds r24,is_master
 727 0008 8823      		tst r24
 728 000a 01F4      		brne .+2
 729 000c 00C0      		rjmp .L46
 730               	.LBB55:
 731               	.LBB56:
 219:keyboards/lily58/rev1/matrix.c ****     int mchanged = 1;
 732               		.loc 1 219 0
 733 000e 0E94 0000 		call _matrix_scan
 734               	.LVL47:
 222:keyboards/lily58/rev1/matrix.c **** 
 735               		.loc 1 222 0
 736 0012 8091 0000 		lds r24,isLeftHand
 737 0016 D0E0      		ldi r29,0
 738 0018 C0E0      		ldi r28,0
 739 001a 8111      		cpse r24,__zero_reg__
 740 001c 00C0      		rjmp .L47
 741 001e C5E0      		ldi r28,lo8(5)
 742 0020 D0E0      		ldi r29,0
 743               	.L47:
 744               	.LVL48:
 232:keyboards/lily58/rev1/matrix.c ****   #endif
 745               		.loc 1 232 0
 746 0022 C050      		subi r28,lo8(-(matrix))
 747 0024 D040      		sbci r29,hi8(-(matrix))
 748               	.LVL49:
 231:keyboards/lily58/rev1/matrix.c **** 		      &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 749               		.loc 1 231 0
 750 0026 45E0      		ldi r20,lo8(5)
 751 0028 50E0      		ldi r21,0
 752 002a BE01      		movw r22,r28
 753 002c 80E0      		ldi r24,lo8(serial_master_buffer)
 754 002e 90E0      		ldi r25,hi8(serial_master_buffer)
 755 0030 0E94 0000 		call memcmp
 756               	.LVL50:
 234:keyboards/lily58/rev1/matrix.c **** 	   &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 757               		.loc 1 234 0
 758 0034 25E0      		ldi r18,lo8(5)
 759 0036 FE01      		movw r30,r28
 760 0038 A0E0      		ldi r26,lo8(serial_master_buffer)
 761 003a B0E0      		ldi r27,hi8(serial_master_buffer)
 762               		0:
 763 003c 0190      		ld r0,Z+
 764 003e 0D92      		st X+,r0
 765 0040 2A95      		dec r18
 766 0042 01F4      		brne 0b
 241:keyboards/lily58/rev1/matrix.c **** #endif
 767               		.loc 1 241 0
 768 0044 0E94 0000 		call serial_transaction
 769               	.LVL51:
 770 0048 892B      		or r24,r25
 771 004a 01F0      		breq .L48
 244:keyboards/lily58/rev1/matrix.c **** 
 772               		.loc 1 244 0
 773 004c 5D98      		cbi 0xb,5
 246:keyboards/lily58/rev1/matrix.c **** 
 774               		.loc 1 246 0
 775 004e 8091 0000 		lds r24,error_count
 776 0052 8F5F      		subi r24,lo8(-(1))
 777 0054 8093 0000 		sts error_count,r24
 248:keyboards/lily58/rev1/matrix.c ****             // reset other half if disconnected
 778               		.loc 1 248 0
 779 0058 8630      		cpi r24,lo8(6)
 780 005a 00F0      		brlo .L58
 781               	.LBB57:
 250:keyboards/lily58/rev1/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 782               		.loc 1 250 0
 783 005c 8091 0000 		lds r24,isLeftHand
 784 0060 F0E0      		ldi r31,0
 785 0062 E0E0      		ldi r30,0
 786 0064 8823      		tst r24
 787 0066 01F0      		breq .L51
 788 0068 E5E0      		ldi r30,lo8(5)
 789 006a F0E0      		ldi r31,0
 790               	.L51:
 791               	.LVL52:
 792               	.LBB58:
 252:keyboards/lily58/rev1/matrix.c ****             }
 793               		.loc 1 252 0
 794 006c E050      		subi r30,lo8(-(matrix))
 795 006e F040      		sbci r31,hi8(-(matrix))
 796               	.LVL53:
 797 0070 1082      		st Z,__zero_reg__
 798               	.LVL54:
 799 0072 1182      		std Z+1,__zero_reg__
 800               	.LVL55:
 801 0074 1282      		std Z+2,__zero_reg__
 802               	.LVL56:
 803 0076 1382      		std Z+3,__zero_reg__
 804               	.LVL57:
 805 0078 1482      		std Z+4,__zero_reg__
 806               	.LVL58:
 807               	.L58:
 808               	.LBE58:
 809               	.LBE57:
 810               	.LBE56:
 811               	.LBE55:
 812               	.LBB60:
 211:keyboards/lily58/rev1/matrix.c ****     }
 813               		.loc 1 211 0 discriminator 4
 814 007a 0E94 0000 		call matrix_scan_quantum
 815               	.LVL59:
 816               	.LBE60:
 214:keyboards/lily58/rev1/matrix.c **** 
 817               		.loc 1 214 0 discriminator 4
 818 007e 81E0      		ldi r24,lo8(1)
 819               	/* epilogue start */
 820 0080 DF91      		pop r29
 821 0082 CF91      		pop r28
 822 0084 0895      		ret
 823               	.LVL60:
 824               	.L48:
 825               	.LBB61:
 826               	.LBB59:
 257:keyboards/lily58/rev1/matrix.c ****         error_count = 0;
 827               		.loc 1 257 0
 828 0086 5D9A      		sbi 0xb,5
 258:keyboards/lily58/rev1/matrix.c ****     }
 829               		.loc 1 258 0
 830 0088 1092 0000 		sts error_count,__zero_reg__
 831 008c 00C0      		rjmp .L58
 832               	.LVL61:
 833               	.L46:
 834               	.LBE59:
 835               	.LBE61:
 836               	.LBB62:
 207:keyboards/lily58/rev1/matrix.c ****         int offset = (isLeftHand) ? ROWS_PER_HAND : 0;
 837               		.loc 1 207 0
 838 008e 0E94 0000 		call matrix_slave_scan
 839               	.LVL62:
 208:keyboards/lily58/rev1/matrix.c ****         memcpy(&matrix[offset],
 840               		.loc 1 208 0
 841 0092 8091 0000 		lds r24,isLeftHand
 842 0096 B0E0      		ldi r27,0
 843 0098 A0E0      		ldi r26,0
 844 009a 8823      		tst r24
 845 009c 01F0      		breq .L54
 846 009e A5E0      		ldi r26,lo8(5)
 847 00a0 B0E0      		ldi r27,0
 848               	.L54:
 849               	.LVL63:
 209:keyboards/lily58/rev1/matrix.c ****                (void *)serial_master_buffer, SERIAL_MASTER_BUFFER_LENGTH);
 850               		.loc 1 209 0 discriminator 4
 851 00a2 A050      		subi r26,lo8(-(matrix))
 852 00a4 B040      		sbci r27,hi8(-(matrix))
 853               	.LVL64:
 854 00a6 85E0      		ldi r24,lo8(5)
 855 00a8 E0E0      		ldi r30,lo8(serial_master_buffer)
 856 00aa F0E0      		ldi r31,hi8(serial_master_buffer)
 857               		0:
 858 00ac 0190      		ld r0,Z+
 859 00ae 0D92      		st X+,r0
 860 00b0 8A95      		dec r24
 861 00b2 01F4      		brne 0b
 862               	.LVL65:
 863 00b4 00C0      		rjmp .L58
 864               	.LBE62:
 865               		.cfi_endproc
 866               	.LFE18:
 868               		.section	.text.matrix_is_modified,"ax",@progbits
 869               	.global	matrix_is_modified
 871               	matrix_is_modified:
 872               	.LFB21:
 292:keyboards/lily58/rev1/matrix.c ****     if (debouncing) return false;
 873               		.loc 1 292 0
 874               		.cfi_startproc
 875               	/* prologue: function */
 876               	/* frame size = 0 */
 877               	/* stack size = 0 */
 878               	.L__stack_usage = 0
 293:keyboards/lily58/rev1/matrix.c ****     return true;
 879               		.loc 1 293 0
 880 0000 81E0      		ldi r24,lo8(1)
 881 0002 9091 0000 		lds r25,debouncing
 882 0006 9111      		cpse r25,__zero_reg__
 883 0008 80E0      		ldi r24,0
 884               	.L60:
 885               	/* epilogue start */
 295:keyboards/lily58/rev1/matrix.c **** 
 886               		.loc 1 295 0
 887 000a 0895      		ret
 888               		.cfi_endproc
 889               	.LFE21:
 891               		.section	.text.matrix_is_on,"ax",@progbits
 892               	.global	matrix_is_on
 894               	matrix_is_on:
 895               	.LFB22:
 299:keyboards/lily58/rev1/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 896               		.loc 1 299 0
 897               		.cfi_startproc
 898               	.LVL66:
 899               	/* prologue: function */
 900               	/* frame size = 0 */
 901               	/* stack size = 0 */
 902               	.L__stack_usage = 0
 300:keyboards/lily58/rev1/matrix.c **** }
 903               		.loc 1 300 0
 904 0000 E82F      		mov r30,r24
 905 0002 F0E0      		ldi r31,0
 906 0004 E050      		subi r30,lo8(-(matrix))
 907 0006 F040      		sbci r31,hi8(-(matrix))
 908 0008 2081      		ld r18,Z
 909 000a 30E0      		ldi r19,0
 910 000c 81E0      		ldi r24,lo8(1)
 911 000e 90E0      		ldi r25,0
 912               	.LVL67:
 913 0010 00C0      		rjmp 2f
 914               		1:
 915 0012 880F      		lsl r24
 916 0014 991F      		rol r25
 917               		2:
 918 0016 6A95      		dec r22
 919 0018 02F4      		brpl 1b
 920 001a 2823      		and r18,r24
 921 001c 3923      		and r19,r25
 922 001e 81E0      		ldi r24,lo8(1)
 923 0020 232B      		or r18,r19
 924 0022 01F4      		brne .L65
 925 0024 80E0      		ldi r24,0
 926               	.L65:
 927               	/* epilogue start */
 301:keyboards/lily58/rev1/matrix.c **** 
 928               		.loc 1 301 0
 929 0026 0895      		ret
 930               		.cfi_endproc
 931               	.LFE22:
 933               		.section	.text.matrix_get_row,"ax",@progbits
 934               	.global	matrix_get_row
 936               	matrix_get_row:
 937               	.LFB23:
 305:keyboards/lily58/rev1/matrix.c ****     return matrix[row];
 938               		.loc 1 305 0
 939               		.cfi_startproc
 940               	.LVL68:
 941               	/* prologue: function */
 942               	/* frame size = 0 */
 943               	/* stack size = 0 */
 944               	.L__stack_usage = 0
 306:keyboards/lily58/rev1/matrix.c **** }
 945               		.loc 1 306 0
 946 0000 E82F      		mov r30,r24
 947 0002 F0E0      		ldi r31,0
 948 0004 E050      		subi r30,lo8(-(matrix))
 949 0006 F040      		sbci r31,hi8(-(matrix))
 307:keyboards/lily58/rev1/matrix.c **** 
 950               		.loc 1 307 0
 951 0008 8081      		ld r24,Z
 952               	.LVL69:
 953               	/* epilogue start */
 954 000a 0895      		ret
 955               		.cfi_endproc
 956               	.LFE23:
 958               		.section	.text.matrix_print,"ax",@progbits
 959               	.global	matrix_print
 961               	matrix_print:
 962               	.LFB24:
 310:keyboards/lily58/rev1/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 963               		.loc 1 310 0
 964               		.cfi_startproc
 965               	/* prologue: function */
 966               	/* frame size = 0 */
 967               	/* stack size = 0 */
 968               	.L__stack_usage = 0
 969               	.LVL70:
 970               	/* epilogue start */
 317:keyboards/lily58/rev1/matrix.c **** 
 971               		.loc 1 317 0
 972 0000 0895      		ret
 973               		.cfi_endproc
 974               	.LFE24:
 976               		.section	.text.matrix_key_count,"ax",@progbits
 977               	.global	matrix_key_count
 979               	matrix_key_count:
 980               	.LFB25:
 320:keyboards/lily58/rev1/matrix.c ****     uint8_t count = 0;
 981               		.loc 1 320 0
 982               		.cfi_startproc
 983 0000 0F93      		push r16
 984               	.LCFI17:
 985               		.cfi_def_cfa_offset 3
 986               		.cfi_offset 16, -2
 987 0002 1F93      		push r17
 988               	.LCFI18:
 989               		.cfi_def_cfa_offset 4
 990               		.cfi_offset 17, -3
 991 0004 CF93      		push r28
 992               	.LCFI19:
 993               		.cfi_def_cfa_offset 5
 994               		.cfi_offset 28, -4
 995               	/* prologue: function */
 996               	/* frame size = 0 */
 997               	/* stack size = 3 */
 998               	.L__stack_usage = 3
 999               	.LVL71:
 1000 0006 00E0      		ldi r16,lo8(matrix)
 1001 0008 10E0      		ldi r17,hi8(matrix)
 321:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 1002               		.loc 1 321 0
 1003 000a C0E0      		ldi r28,0
 1004               	.LVL72:
 1005               	.L69:
 1006               	.LBB63:
 323:keyboards/lily58/rev1/matrix.c ****     }
 1007               		.loc 1 323 0 discriminator 3
 1008 000c F801      		movw r30,r16
 1009 000e 8191      		ld r24,Z+
 1010 0010 8F01      		movw r16,r30
 1011               	.LVL73:
 1012 0012 90E0      		ldi r25,0
 1013 0014 0E94 0000 		call bitpop16
 1014               	.LVL74:
 1015 0018 C80F      		add r28,r24
 1016               	.LVL75:
 322:keyboards/lily58/rev1/matrix.c ****         count += bitpop16(matrix[i]);
 1017               		.loc 1 322 0 discriminator 3
 1018 001a F0E0      		ldi r31,hi8(matrix+10)
 1019 001c 0030      		cpi r16,lo8(matrix+10)
 1020 001e 1F07      		cpc r17,r31
 1021 0020 01F4      		brne .L69
 1022               	.LBE63:
 326:keyboards/lily58/rev1/matrix.c **** 
 1023               		.loc 1 326 0
 1024 0022 8C2F      		mov r24,r28
 1025               	/* epilogue start */
 1026 0024 CF91      		pop r28
 1027               	.LVL76:
 1028 0026 1F91      		pop r17
 1029 0028 0F91      		pop r16
 1030               	.LVL77:
 1031 002a 0895      		ret
 1032               		.cfi_endproc
 1033               	.LFE25:
 1035               		.section	.bss.matrix_debouncing,"aw",@nobits
 1038               	matrix_debouncing:
 1039 0000 0000 0000 		.zero	10
 1039      0000 0000 
 1039      0000 
 1040               		.section	.bss.matrix,"aw",@nobits
 1043               	matrix:
 1044 0000 0000 0000 		.zero	10
 1044      0000 0000 
 1044      0000 
 1045               		.section	.rodata.col_pins,"a",@progbits
 1048               	col_pins:
 1049 0000 F6        		.byte	-10
 1050 0001 F7        		.byte	-9
 1051 0002 31        		.byte	49
 1052 0003 33        		.byte	51
 1053 0004 32        		.byte	50
 1054 0005 36        		.byte	54
 1055               		.section	.rodata.row_pins,"a",@progbits
 1058               	row_pins:
 1059 0000 66        		.byte	102
 1060 0001 97        		.byte	-105
 1061 0002 C6        		.byte	-58
 1062 0003 34        		.byte	52
 1063 0004 35        		.byte	53
 1064 0005 0000 0000 		.zero	5
 1064      00
 1065               	.global	is_master
 1066               		.section	.bss.is_master,"aw",@nobits
 1069               	is_master:
 1070 0000 00        		.zero	1
 1071               		.section	.bss.error_count,"aw",@nobits
 1074               	error_count:
 1075 0000 00        		.zero	1
 1076               		.section	.data.debouncing,"aw",@progbits
 1079               	debouncing:
 1080 0000 05        		.byte	5
 1081               		.text
 1082               	.Letext0:
 1083               		.file 3 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdint.h"
 1084               		.file 4 "tmk_core/common/debug.h"
 1085               		.file 5 "tmk_core/common/matrix.h"
 1086               		.file 6 "keyboards/lily58/rev1/split_util.h"
 1087               		.file 7 "drivers/avr/pro_micro.h"
 1088               		.file 8 "keyboards/lily58/rev1/split_scomm.h"
 1089               		.file 9 "tmk_core/common/util.h"
 1090               		.file 10 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
/var/tmp//ccrX8RN4.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//ccrX8RN4.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//ccrX8RN4.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//ccrX8RN4.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//ccrX8RN4.s:6      *ABS*:0000000000000001 __zero_reg__
/var/tmp//ccrX8RN4.s:12     .text.unselect_rows:0000000000000000 unselect_rows
/var/tmp//ccrX8RN4.s:1058   .rodata.row_pins:0000000000000000 row_pins
/var/tmp//ccrX8RN4.s:81     .text.matrix_init_user:0000000000000000 matrix_init_user
/var/tmp//ccrX8RN4.s:81     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
/var/tmp//ccrX8RN4.s:99     .text.matrix_init_kb:0000000000000000 matrix_init_kb
/var/tmp//ccrX8RN4.s:116    .text.matrix_scan_user:0000000000000000 matrix_scan_user
/var/tmp//ccrX8RN4.s:131    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
/var/tmp//ccrX8RN4.s:148    .text.matrix_rows:0000000000000000 matrix_rows
/var/tmp//ccrX8RN4.s:166    .text.matrix_cols:0000000000000000 matrix_cols
/var/tmp//ccrX8RN4.s:184    .text.matrix_init:0000000000000000 matrix_init
/var/tmp//ccrX8RN4.s:1048   .rodata.col_pins:0000000000000000 col_pins
/var/tmp//ccrX8RN4.s:1043   .bss.matrix:0000000000000000 matrix
/var/tmp//ccrX8RN4.s:1038   .bss.matrix_debouncing:0000000000000000 matrix_debouncing
/var/tmp//ccrX8RN4.s:1069   .bss.is_master:0000000000000000 is_master
/var/tmp//ccrX8RN4.s:282    .text._matrix_scan:0000000000000000 _matrix_scan
/var/tmp//ccrX8RN4.s:1079   .data.debouncing:0000000000000000 debouncing
/var/tmp//ccrX8RN4.s:567    .text.serial_transaction:0000000000000000 serial_transaction
/var/tmp//ccrX8RN4.s:641    .text.matrix_slave_scan:0000000000000000 matrix_slave_scan
/var/tmp//ccrX8RN4.s:709    .text.matrix_scan:0000000000000000 matrix_scan
/var/tmp//ccrX8RN4.s:1074   .bss.error_count:0000000000000000 error_count
/var/tmp//ccrX8RN4.s:871    .text.matrix_is_modified:0000000000000000 matrix_is_modified
/var/tmp//ccrX8RN4.s:894    .text.matrix_is_on:0000000000000000 matrix_is_on
/var/tmp//ccrX8RN4.s:936    .text.matrix_get_row:0000000000000000 matrix_get_row
/var/tmp//ccrX8RN4.s:961    .text.matrix_print:0000000000000000 matrix_print
/var/tmp//ccrX8RN4.s:979    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
has_usb
matrix_init_quantum
isLeftHand
serial_update_buffers
serial_slave_buffer
slave_buffer_change_count
serial_master_buffer
memcmp
matrix_scan_quantum
bitpop16
__do_copy_data
__do_clear_bss

   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB19:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** 
  19:quantum/quantum.c **** #if !defined(RGBLIGHT_ENABLE) && !defined(RGB_MATRIX_ENABLE)
  20:quantum/quantum.c **** #    include "rgb.h"
  21:quantum/quantum.c **** #endif
  22:quantum/quantum.c **** 
  23:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  24:quantum/quantum.c **** #    include "outputselect.h"
  25:quantum/quantum.c **** #endif
  26:quantum/quantum.c **** 
  27:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  28:quantum/quantum.c **** #    define BREATHING_PERIOD 6
  29:quantum/quantum.c **** #endif
  30:quantum/quantum.c **** 
  31:quantum/quantum.c **** #include "backlight.h"
  32:quantum/quantum.c **** extern backlight_config_t backlight_config;
  33:quantum/quantum.c **** 
  34:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  35:quantum/quantum.c **** #    include "fauxclicky.h"
  36:quantum/quantum.c **** #endif
  37:quantum/quantum.c **** 
  38:quantum/quantum.c **** #ifdef API_ENABLE
  39:quantum/quantum.c **** #    include "api.h"
  40:quantum/quantum.c **** #endif
  41:quantum/quantum.c **** 
  42:quantum/quantum.c **** #ifdef MIDI_ENABLE
  43:quantum/quantum.c **** #    include "process_midi.h"
  44:quantum/quantum.c **** #endif
  45:quantum/quantum.c **** 
  46:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  47:quantum/quantum.c **** #    include "velocikey.h"
  48:quantum/quantum.c **** #endif
  49:quantum/quantum.c **** 
  50:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  51:quantum/quantum.c **** #    include "haptic.h"
  52:quantum/quantum.c **** #endif
  53:quantum/quantum.c **** 
  54:quantum/quantum.c **** #ifdef ENCODER_ENABLE
  55:quantum/quantum.c **** #    include "encoder.h"
  56:quantum/quantum.c **** #endif
  57:quantum/quantum.c **** 
  58:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  59:quantum/quantum.c **** #    ifndef GOODBYE_SONG
  60:quantum/quantum.c **** #        define GOODBYE_SONG SONG(GOODBYE_SOUND)
  61:quantum/quantum.c **** #    endif
  62:quantum/quantum.c **** #    ifndef AG_NORM_SONG
  63:quantum/quantum.c **** #        define AG_NORM_SONG SONG(AG_NORM_SOUND)
  64:quantum/quantum.c **** #    endif
  65:quantum/quantum.c **** #    ifndef AG_SWAP_SONG
  66:quantum/quantum.c **** #        define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  67:quantum/quantum.c **** #    endif
  68:quantum/quantum.c **** #    ifndef CG_NORM_SONG
  69:quantum/quantum.c **** #        define CG_NORM_SONG SONG(AG_NORM_SOUND)
  70:quantum/quantum.c **** #    endif
  71:quantum/quantum.c **** #    ifndef CG_SWAP_SONG
  72:quantum/quantum.c **** #        define CG_SWAP_SONG SONG(AG_SWAP_SOUND)
  73:quantum/quantum.c **** #    endif
  74:quantum/quantum.c **** float goodbye_song[][2] = GOODBYE_SONG;
  75:quantum/quantum.c **** float ag_norm_song[][2] = AG_NORM_SONG;
  76:quantum/quantum.c **** float ag_swap_song[][2] = AG_SWAP_SONG;
  77:quantum/quantum.c **** float cg_norm_song[][2] = CG_NORM_SONG;
  78:quantum/quantum.c **** float cg_swap_song[][2] = CG_SWAP_SONG;
  79:quantum/quantum.c **** #    ifdef DEFAULT_LAYER_SONGS
  80:quantum/quantum.c **** float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  81:quantum/quantum.c **** #    endif
  82:quantum/quantum.c **** #endif
  83:quantum/quantum.c **** 
  84:quantum/quantum.c **** static void do_code16(uint16_t code, void (*f)(uint8_t)) {
  15               		.loc 1 84 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  85:quantum/quantum.c ****     switch (code) {
  40               		.loc 1 85 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  86:quantum/quantum.c ****         case QK_MODS ... QK_MODS_MAX:
  87:quantum/quantum.c ****             break;
  88:quantum/quantum.c ****         default:
  89:quantum/quantum.c ****             return;
  90:quantum/quantum.c ****     }
  91:quantum/quantum.c **** 
  92:quantum/quantum.c ****     if (code & QK_LCTL) f(KC_LCTL);
  46               		.loc 1 92 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  49               		.loc 1 92 0 is_stmt 0 discriminator 1
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  93:quantum/quantum.c ****     if (code & QK_LSFT) f(KC_LSFT);
  55               		.loc 1 93 0 is_stmt 1
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  58               		.loc 1 93 0 is_stmt 0 discriminator 1
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  94:quantum/quantum.c ****     if (code & QK_LALT) f(KC_LALT);
  64               		.loc 1 94 0 is_stmt 1
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  67               		.loc 1 94 0 is_stmt 0 discriminator 1
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  95:quantum/quantum.c ****     if (code & QK_LGUI) f(KC_LGUI);
  73               		.loc 1 95 0 is_stmt 1
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  76               		.loc 1 95 0 is_stmt 0 discriminator 1
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  96:quantum/quantum.c **** 
  97:quantum/quantum.c ****     if (code < QK_RMODS_MIN) return;
  82               		.loc 1 97 0 is_stmt 1
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F4      		brsh .L21
  86               	.L1:
  87               	/* epilogue start */
  98:quantum/quantum.c **** 
  99:quantum/quantum.c ****     if (code & QK_RCTL) f(KC_RCTL);
 100:quantum/quantum.c ****     if (code & QK_RSFT) f(KC_RSFT);
 101:quantum/quantum.c ****     if (code & QK_RALT) f(KC_RALT);
 102:quantum/quantum.c ****     if (code & QK_RGUI) f(KC_RGUI);
 103:quantum/quantum.c **** }
  88               		.loc 1 103 0
  89 0042 DF91      		pop r29
  90 0044 CF91      		pop r28
  91               	.LVL6:
  92 0046 1F91      		pop r17
  93 0048 0F91      		pop r16
  94               	.LVL7:
  95 004a 0895      		ret
  96               	.LVL8:
  97               	.L21:
  99:quantum/quantum.c ****     if (code & QK_RSFT) f(KC_RSFT);
  98               		.loc 1 99 0
  99 004c 84EE      		ldi r24,lo8(-28)
 100 004e FE01      		movw r30,r28
 101 0050 0995      		icall
 102               	.LVL9:
 100:quantum/quantum.c ****     if (code & QK_RALT) f(KC_RALT);
 103               		.loc 1 100 0
 104 0052 85EE      		ldi r24,lo8(-27)
 105 0054 FE01      		movw r30,r28
 106 0056 0995      		icall
 107               	.LVL10:
 101:quantum/quantum.c ****     if (code & QK_RGUI) f(KC_RGUI);
 108               		.loc 1 101 0
 109 0058 86EE      		ldi r24,lo8(-26)
 110 005a FE01      		movw r30,r28
 111 005c 0995      		icall
 112               	.LVL11:
 102:quantum/quantum.c **** }
 113               		.loc 1 102 0
 114 005e 87EE      		ldi r24,lo8(-25)
 115 0060 FE01      		movw r30,r28
 116               	/* epilogue start */
 117               		.loc 1 103 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 102:quantum/quantum.c **** }
 124               		.loc 1 102 0
 125 006a 0994      		ijmp
 126               	.LVL14:
 127               		.cfi_endproc
 128               	.LFE19:
 130               		.section	.text.qk_register_weak_mods,"ax",@progbits
 132               	qk_register_weak_mods:
 133               	.LFB20:
 104:quantum/quantum.c **** 
 105:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 134               		.loc 1 105 0
 135               		.cfi_startproc
 136               	.LVL15:
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 106:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 141               		.loc 1 106 0
 142 0000 8770      		andi r24,lo8(7)
 143               	.LVL16:
 144 0002 91E0      		ldi r25,lo8(1)
 145 0004 00C0      		rjmp 2f
 146               		1:
 147 0006 990F      		lsl r25
 148               		2:
 149 0008 8A95      		dec r24
 150 000a 02F4      		brpl 1b
 151 000c 892F      		mov r24,r25
 152 000e 0E94 0000 		call add_weak_mods
 153               	.LVL17:
 107:quantum/quantum.c ****     send_keyboard_report();
 154               		.loc 1 107 0
 155 0012 0C94 0000 		jmp send_keyboard_report
 156               	.LVL18:
 157               		.cfi_endproc
 158               	.LFE20:
 160               		.section	.text.qk_register_mods,"ax",@progbits
 162               	qk_register_mods:
 163               	.LFB69:
 164               		.cfi_startproc
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 169 0000 0C94 0000 		jmp qk_register_weak_mods
 170               		.cfi_endproc
 171               	.LFE69:
 173               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 175               	qk_unregister_weak_mods:
 176               	.LFB21:
 108:quantum/quantum.c **** }
 109:quantum/quantum.c **** 
 110:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 177               		.loc 1 110 0
 178               		.cfi_startproc
 179               	.LVL19:
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
 111:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 184               		.loc 1 111 0
 185 0000 8770      		andi r24,lo8(7)
 186               	.LVL20:
 187 0002 91E0      		ldi r25,lo8(1)
 188 0004 00C0      		rjmp 2f
 189               		1:
 190 0006 990F      		lsl r25
 191               		2:
 192 0008 8A95      		dec r24
 193 000a 02F4      		brpl 1b
 194 000c 892F      		mov r24,r25
 195 000e 0E94 0000 		call del_weak_mods
 196               	.LVL21:
 112:quantum/quantum.c ****     send_keyboard_report();
 197               		.loc 1 112 0
 198 0012 0C94 0000 		jmp send_keyboard_report
 199               	.LVL22:
 200               		.cfi_endproc
 201               	.LFE21:
 203               		.section	.text.qk_unregister_mods,"ax",@progbits
 205               	qk_unregister_mods:
 206               	.LFB71:
 207               		.cfi_startproc
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 0 */
 211               	.L__stack_usage = 0
 212 0000 0C94 0000 		jmp qk_unregister_weak_mods
 213               		.cfi_endproc
 214               	.LFE71:
 216               		.section	.text.register_code16,"ax",@progbits
 217               	.global	register_code16
 219               	register_code16:
 220               	.LFB24:
 113:quantum/quantum.c **** }
 114:quantum/quantum.c **** 
 115:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 116:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 117:quantum/quantum.c ****     send_keyboard_report();
 118:quantum/quantum.c **** }
 119:quantum/quantum.c **** 
 120:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 121:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 122:quantum/quantum.c ****     send_keyboard_report();
 123:quantum/quantum.c **** }
 124:quantum/quantum.c **** 
 125:quantum/quantum.c **** void register_code16(uint16_t code) {
 221               		.loc 1 125 0
 222               		.cfi_startproc
 223               	.LVL23:
 224               		.loc 1 125 0
 225 0000 CF93      		push r28
 226               	.LCFI4:
 227               		.cfi_def_cfa_offset 3
 228               		.cfi_offset 28, -2
 229 0002 DF93      		push r29
 230               	.LCFI5:
 231               		.cfi_def_cfa_offset 4
 232               		.cfi_offset 29, -3
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 2 */
 236               	.L__stack_usage = 2
 237 0004 EC01      		movw r28,r24
 126:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 238               		.loc 1 126 0
 239 0006 805E      		subi r24,-32
 240 0008 9109      		sbc r25,__zero_reg__
 241               	.LVL24:
 242 000a 0897      		sbiw r24,8
 243 000c 00F0      		brlo .L27
 127:quantum/quantum.c ****         do_code16(code, qk_register_mods);
 128:quantum/quantum.c ****     } else {
 129:quantum/quantum.c ****         do_code16(code, qk_register_weak_mods);
 244               		.loc 1 129 0 discriminator 1
 245 000e 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 246 0010 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 126:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 247               		.loc 1 126 0 discriminator 1
 248 0012 2097      		sbiw r28,0
 249 0014 01F4      		brne .L30
 250               	.L27:
 127:quantum/quantum.c ****         do_code16(code, qk_register_mods);
 251               		.loc 1 127 0
 252 0016 60E0      		ldi r22,lo8(gs(qk_register_mods))
 253 0018 70E0      		ldi r23,hi8(gs(qk_register_mods))
 254               	.L30:
 255               		.loc 1 129 0
 256 001a CE01      		movw r24,r28
 257 001c 0E94 0000 		call do_code16
 258               	.LVL25:
 130:quantum/quantum.c ****     }
 131:quantum/quantum.c ****     register_code(code);
 259               		.loc 1 131 0
 260 0020 8C2F      		mov r24,r28
 261               	/* epilogue start */
 132:quantum/quantum.c **** }
 262               		.loc 1 132 0
 263 0022 DF91      		pop r29
 264 0024 CF91      		pop r28
 265               	.LVL26:
 131:quantum/quantum.c **** }
 266               		.loc 1 131 0
 267 0026 0C94 0000 		jmp register_code
 268               	.LVL27:
 269               		.cfi_endproc
 270               	.LFE24:
 272               		.section	.text.unregister_code16,"ax",@progbits
 273               	.global	unregister_code16
 275               	unregister_code16:
 276               	.LFB25:
 133:quantum/quantum.c **** 
 134:quantum/quantum.c **** void unregister_code16(uint16_t code) {
 277               		.loc 1 134 0
 278               		.cfi_startproc
 279               	.LVL28:
 280 0000 CF93      		push r28
 281               	.LCFI6:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 28, -2
 284 0002 DF93      		push r29
 285               	.LCFI7:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 29, -3
 288               	/* prologue: function */
 289               	/* frame size = 0 */
 290               	/* stack size = 2 */
 291               	.L__stack_usage = 2
 292 0004 EC01      		movw r28,r24
 135:quantum/quantum.c ****     unregister_code(code);
 293               		.loc 1 135 0
 294 0006 0E94 0000 		call unregister_code
 295               	.LVL29:
 136:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 296               		.loc 1 136 0
 297 000a CE01      		movw r24,r28
 298 000c 805E      		subi r24,-32
 299 000e 9109      		sbc r25,__zero_reg__
 300 0010 0897      		sbiw r24,8
 301 0012 00F0      		brlo .L32
 137:quantum/quantum.c ****         do_code16(code, qk_unregister_mods);
 138:quantum/quantum.c ****     } else {
 139:quantum/quantum.c ****         do_code16(code, qk_unregister_weak_mods);
 302               		.loc 1 139 0 discriminator 1
 303 0014 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 304 0016 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 136:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 305               		.loc 1 136 0 discriminator 1
 306 0018 2097      		sbiw r28,0
 307 001a 01F4      		brne .L34
 308               	.L32:
 137:quantum/quantum.c ****         do_code16(code, qk_unregister_mods);
 309               		.loc 1 137 0
 310 001c 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 311 001e 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 312               	.L34:
 313               		.loc 1 139 0
 314 0020 CE01      		movw r24,r28
 315               	/* epilogue start */
 140:quantum/quantum.c ****     }
 141:quantum/quantum.c **** }
 316               		.loc 1 141 0
 317 0022 DF91      		pop r29
 318 0024 CF91      		pop r28
 319               	.LVL30:
 139:quantum/quantum.c ****     }
 320               		.loc 1 139 0
 321 0026 0C94 0000 		jmp do_code16
 322               	.LVL31:
 323               		.cfi_endproc
 324               	.LFE25:
 326               		.section	.text.tap_code16,"ax",@progbits
 327               	.global	tap_code16
 329               	tap_code16:
 330               	.LFB26:
 142:quantum/quantum.c **** 
 143:quantum/quantum.c **** void tap_code16(uint16_t code) {
 331               		.loc 1 143 0
 332               		.cfi_startproc
 333               	.LVL32:
 334 0000 CF93      		push r28
 335               	.LCFI8:
 336               		.cfi_def_cfa_offset 3
 337               		.cfi_offset 28, -2
 338 0002 DF93      		push r29
 339               	.LCFI9:
 340               		.cfi_def_cfa_offset 4
 341               		.cfi_offset 29, -3
 342               	/* prologue: function */
 343               	/* frame size = 0 */
 344               	/* stack size = 2 */
 345               	.L__stack_usage = 2
 346 0004 EC01      		movw r28,r24
 144:quantum/quantum.c ****     register_code16(code);
 347               		.loc 1 144 0
 348 0006 0E94 0000 		call register_code16
 349               	.LVL33:
 145:quantum/quantum.c **** #if TAP_CODE_DELAY > 0
 146:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 147:quantum/quantum.c **** #endif
 148:quantum/quantum.c ****     unregister_code16(code);
 350               		.loc 1 148 0
 351 000a CE01      		movw r24,r28
 352               	/* epilogue start */
 149:quantum/quantum.c **** }
 353               		.loc 1 149 0
 354 000c DF91      		pop r29
 355 000e CF91      		pop r28
 356               	.LVL34:
 148:quantum/quantum.c **** }
 357               		.loc 1 148 0
 358 0010 0C94 0000 		jmp unregister_code16
 359               	.LVL35:
 360               		.cfi_endproc
 361               	.LFE26:
 363               		.section	.text.process_action_kb,"ax",@progbits
 364               		.weak	process_action_kb
 366               	process_action_kb:
 367               	.LFB27:
 150:quantum/quantum.c **** 
 151:quantum/quantum.c **** __attribute__((weak)) bool process_action_kb(keyrecord_t *record) { return true; }
 368               		.loc 1 151 0
 369               		.cfi_startproc
 370               	.LVL36:
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 0 */
 374               	.L__stack_usage = 0
 375               		.loc 1 151 0
 376 0000 81E0      		ldi r24,lo8(1)
 377               	.LVL37:
 378               	/* epilogue start */
 379 0002 0895      		ret
 380               		.cfi_endproc
 381               	.LFE27:
 383               		.section	.text.process_record_user,"ax",@progbits
 384               		.weak	process_record_user
 386               	process_record_user:
 387               	.LFB29:
 152:quantum/quantum.c **** 
 153:quantum/quantum.c **** __attribute__((weak)) bool process_record_kb(uint16_t keycode, keyrecord_t *record) { return proces
 154:quantum/quantum.c **** 
 155:quantum/quantum.c **** __attribute__((weak)) bool process_record_user(uint16_t keycode, keyrecord_t *record) { return true
 388               		.loc 1 155 0
 389               		.cfi_startproc
 390               	.LVL38:
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 395               		.loc 1 155 0
 396 0000 81E0      		ldi r24,lo8(1)
 397               	.LVL39:
 398               	/* epilogue start */
 399 0002 0895      		ret
 400               		.cfi_endproc
 401               	.LFE29:
 403               		.section	.text.process_record_kb,"ax",@progbits
 404               		.weak	process_record_kb
 406               	process_record_kb:
 407               	.LFB28:
 153:quantum/quantum.c **** 
 408               		.loc 1 153 0
 409               		.cfi_startproc
 410               	.LVL40:
 411               	/* prologue: function */
 412               	/* frame size = 0 */
 413               	/* stack size = 0 */
 414               	.L__stack_usage = 0
 153:quantum/quantum.c **** 
 415               		.loc 1 153 0
 416 0000 0C94 0000 		jmp process_record_user
 417               	.LVL41:
 418               		.cfi_endproc
 419               	.LFE28:
 421               		.section	.text.get_event_keycode,"ax",@progbits
 422               	.global	get_event_keycode
 424               	get_event_keycode:
 425               	.LFB32:
 156:quantum/quantum.c **** 
 157:quantum/quantum.c **** void reset_keyboard(void) {
 158:quantum/quantum.c ****     clear_keyboard();
 159:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 160:quantum/quantum.c ****     process_midi_all_notes_off();
 161:quantum/quantum.c **** #endif
 162:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 163:quantum/quantum.c **** #    ifndef NO_MUSIC_MODE
 164:quantum/quantum.c ****     music_all_notes_off();
 165:quantum/quantum.c **** #    endif
 166:quantum/quantum.c ****     uint16_t timer_start = timer_read();
 167:quantum/quantum.c ****     PLAY_SONG(goodbye_song);
 168:quantum/quantum.c ****     shutdown_user();
 169:quantum/quantum.c ****     while (timer_elapsed(timer_start) < 250) wait_ms(1);
 170:quantum/quantum.c ****     stop_all_notes();
 171:quantum/quantum.c **** #else
 172:quantum/quantum.c ****     shutdown_user();
 173:quantum/quantum.c ****     wait_ms(250);
 174:quantum/quantum.c **** #endif
 175:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 176:quantum/quantum.c ****     haptic_shutdown();
 177:quantum/quantum.c **** #endif
 178:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 179:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 180:quantum/quantum.c ****     *(uint16_t *)0x0800 = 0x7777;  // these two are a-star-specific
 181:quantum/quantum.c **** #endif
 182:quantum/quantum.c ****     bootloader_jump();
 183:quantum/quantum.c **** }
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 191:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record) { return get_event_keycode(record->event); }
 192:quantum/quantum.c **** 
 193:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 194:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 195:quantum/quantum.c ****  */
 196:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event) {
 426               		.loc 1 196 0
 427               		.cfi_startproc
 428 0000 1F93      		push r17
 429               	.LCFI10:
 430               		.cfi_def_cfa_offset 3
 431               		.cfi_offset 17, -2
 432 0002 CF93      		push r28
 433               	.LCFI11:
 434               		.cfi_def_cfa_offset 4
 435               		.cfi_offset 28, -3
 436 0004 DF93      		push r29
 437               	.LCFI12:
 438               		.cfi_def_cfa_offset 5
 439               		.cfi_offset 29, -4
 440 0006 00D0      		rcall .
 441 0008 00D0      		rcall .
 442 000a 1F92      		push __zero_reg__
 443               	.LCFI13:
 444               		.cfi_def_cfa_offset 10
 445 000c CDB7      		in r28,__SP_L__
 446 000e DEB7      		in r29,__SP_H__
 447               	.LCFI14:
 448               		.cfi_def_cfa_register 28
 449               	/* prologue: function */
 450               	/* frame size = 5 */
 451               	/* stack size = 8 */
 452               	.L__stack_usage = 8
 453 0010 4983      		std Y+1,r20
 454 0012 5A83      		std Y+2,r21
 455 0014 6B83      		std Y+3,r22
 197:quantum/quantum.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 198:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 199:quantum/quantum.c ****     if (!disable_action_cache) {
 456               		.loc 1 199 0
 457 0016 2091 0000 		lds r18,disable_action_cache
 458 001a 8981      		ldd r24,Y+1
 459 001c 9A81      		ldd r25,Y+2
 460 001e 2111      		cpse r18,__zero_reg__
 461 0020 00C0      		rjmp .L40
 462               	.LBB24:
 200:quantum/quantum.c ****         uint8_t layer;
 201:quantum/quantum.c **** 
 202:quantum/quantum.c ****         if (event.pressed) {
 463               		.loc 1 202 0
 464 0022 6623      		tst r22
 465 0024 01F0      		breq .L41
 203:quantum/quantum.c ****             layer = layer_switch_get_layer(event.key);
 466               		.loc 1 203 0
 467 0026 0E94 0000 		call layer_switch_get_layer
 468               	.LVL42:
 469 002a 182F      		mov r17,r24
 470               	.LVL43:
 204:quantum/quantum.c ****             update_source_layers_cache(event.key, layer);
 471               		.loc 1 204 0
 472 002c 682F      		mov r22,r24
 473 002e 8981      		ldd r24,Y+1
 474 0030 9A81      		ldd r25,Y+2
 475 0032 0E94 0000 		call update_source_layers_cache
 476               	.LVL44:
 477               	.L42:
 205:quantum/quantum.c ****         } else {
 206:quantum/quantum.c ****             layer = read_source_layers_cache(event.key);
 207:quantum/quantum.c ****         }
 208:quantum/quantum.c ****         return keymap_key_to_keycode(layer, event.key);
 478               		.loc 1 208 0
 479 0036 6981      		ldd r22,Y+1
 480 0038 7A81      		ldd r23,Y+2
 481 003a 812F      		mov r24,r17
 482               	.LVL45:
 483               	.L43:
 484               	/* epilogue start */
 485               	.LBE24:
 209:quantum/quantum.c ****     } else
 210:quantum/quantum.c **** #endif
 211:quantum/quantum.c ****         return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 212:quantum/quantum.c **** }
 486               		.loc 1 212 0
 487 003c 0F90      		pop __tmp_reg__
 488 003e 0F90      		pop __tmp_reg__
 489 0040 0F90      		pop __tmp_reg__
 490 0042 0F90      		pop __tmp_reg__
 491 0044 0F90      		pop __tmp_reg__
 492 0046 DF91      		pop r29
 493 0048 CF91      		pop r28
 494 004a 1F91      		pop r17
 211:quantum/quantum.c **** }
 495               		.loc 1 211 0
 496 004c 0C94 0000 		jmp keymap_key_to_keycode
 497               	.LVL46:
 498               	.L41:
 499               	.LBB25:
 206:quantum/quantum.c ****         }
 500               		.loc 1 206 0
 501 0050 0E94 0000 		call read_source_layers_cache
 502               	.LVL47:
 503 0054 182F      		mov r17,r24
 504               	.LVL48:
 505 0056 00C0      		rjmp .L42
 506               	.LVL49:
 507               	.L40:
 508               	.LBE25:
 211:quantum/quantum.c **** }
 509               		.loc 1 211 0
 510 0058 0E94 0000 		call layer_switch_get_layer
 511               	.LVL50:
 512 005c 6981      		ldd r22,Y+1
 513 005e 7A81      		ldd r23,Y+2
 514 0060 00C0      		rjmp .L43
 515               		.cfi_endproc
 516               	.LFE32:
 518               		.section	.text.get_record_keycode,"ax",@progbits
 519               	.global	get_record_keycode
 521               	get_record_keycode:
 522               	.LFB31:
 191:quantum/quantum.c **** 
 523               		.loc 1 191 0
 524               		.cfi_startproc
 525               	.LVL51:
 526               	/* prologue: function */
 527               	/* frame size = 0 */
 528               	/* stack size = 0 */
 529               	.L__stack_usage = 0
 530 0000 FC01      		movw r30,r24
 191:quantum/quantum.c **** 
 531               		.loc 1 191 0
 532 0002 4081      		ld r20,Z
 533 0004 5181      		ldd r21,Z+1
 534 0006 6281      		ldd r22,Z+2
 535 0008 7381      		ldd r23,Z+3
 536 000a 8481      		ldd r24,Z+4
 537               	.LVL52:
 538 000c 0C94 0000 		jmp get_event_keycode
 539               	.LVL53:
 540               		.cfi_endproc
 541               	.LFE31:
 543               		.section	.text.send_char,"ax",@progbits
 544               	.global	send_char
 546               	send_char:
 547               	.LFB38:
 213:quantum/quantum.c **** 
 214:quantum/quantum.c **** /* Main keycode processing function. Hands off handling to other functions,
 215:quantum/quantum.c ****  * then processes internal Quantum keycodes, then processes ACTIONs.
 216:quantum/quantum.c ****  */
 217:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 218:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****     // This is how you use actions here
 221:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 222:quantum/quantum.c ****     //   action_t action;
 223:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 224:quantum/quantum.c ****     //   process_action(record, action);
 225:quantum/quantum.c ****     //   return false;
 226:quantum/quantum.c ****     // }
 227:quantum/quantum.c **** 
 228:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 229:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) {
 230:quantum/quantum.c ****         velocikey_accelerate();
 231:quantum/quantum.c ****     }
 232:quantum/quantum.c **** #endif
 233:quantum/quantum.c **** 
 234:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 235:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 236:quantum/quantum.c **** #endif
 237:quantum/quantum.c **** 
 238:quantum/quantum.c ****     if (!(
 239:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 240:quantum/quantum.c ****             // Must run first to be able to mask key_up events.
 241:quantum/quantum.c ****             process_key_lock(&keycode, record) &&
 242:quantum/quantum.c **** #endif
 243:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 244:quantum/quantum.c ****             process_clicky(keycode, record) &&
 245:quantum/quantum.c **** #endif  // AUDIO_CLICKY
 246:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 247:quantum/quantum.c ****             process_haptic(keycode, record) &&
 248:quantum/quantum.c **** #endif  // HAPTIC_ENABLE
 249:quantum/quantum.c **** #if defined(RGB_MATRIX_ENABLE)
 250:quantum/quantum.c ****             process_rgb_matrix(keycode, record) &&
 251:quantum/quantum.c **** #endif
 252:quantum/quantum.c ****             process_record_kb(keycode, record) &&
 253:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 254:quantum/quantum.c ****             process_midi(keycode, record) &&
 255:quantum/quantum.c **** #endif
 256:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 257:quantum/quantum.c ****             process_audio(keycode, record) &&
 258:quantum/quantum.c **** #endif
 259:quantum/quantum.c **** #ifdef STENO_ENABLE
 260:quantum/quantum.c ****             process_steno(keycode, record) &&
 261:quantum/quantum.c **** #endif
 262:quantum/quantum.c **** #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC_M
 263:quantum/quantum.c ****             process_music(keycode, record) &&
 264:quantum/quantum.c **** #endif
 265:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 266:quantum/quantum.c ****             process_tap_dance(keycode, record) &&
 267:quantum/quantum.c **** #endif
 268:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 269:quantum/quantum.c ****             process_unicode_common(keycode, record) &&
 270:quantum/quantum.c **** #endif
 271:quantum/quantum.c **** #ifdef LEADER_ENABLE
 272:quantum/quantum.c ****             process_leader(keycode, record) &&
 273:quantum/quantum.c **** #endif
 274:quantum/quantum.c **** #ifdef COMBO_ENABLE
 275:quantum/quantum.c ****             process_combo(keycode, record) &&
 276:quantum/quantum.c **** #endif
 277:quantum/quantum.c **** #ifdef PRINTING_ENABLE
 278:quantum/quantum.c ****             process_printer(keycode, record) &&
 279:quantum/quantum.c **** #endif
 280:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 281:quantum/quantum.c ****             process_auto_shift(keycode, record) &&
 282:quantum/quantum.c **** #endif
 283:quantum/quantum.c **** #ifdef TERMINAL_ENABLE
 284:quantum/quantum.c ****             process_terminal(keycode, record) &&
 285:quantum/quantum.c **** #endif
 286:quantum/quantum.c **** #ifdef SPACE_CADET_ENABLE
 287:quantum/quantum.c ****             process_space_cadet(keycode, record) &&
 288:quantum/quantum.c **** #endif
 289:quantum/quantum.c ****             true)) {
 290:quantum/quantum.c ****         return false;
 291:quantum/quantum.c ****     }
 292:quantum/quantum.c **** 
 293:quantum/quantum.c ****     // Shift / paren setup
 294:quantum/quantum.c **** 
 295:quantum/quantum.c ****     switch (keycode) {
 296:quantum/quantum.c ****         case RESET:
 297:quantum/quantum.c ****             if (record->event.pressed) {
 298:quantum/quantum.c ****                 reset_keyboard();
 299:quantum/quantum.c ****             }
 300:quantum/quantum.c ****             return false;
 301:quantum/quantum.c ****         case DEBUG:
 302:quantum/quantum.c ****             if (record->event.pressed) {
 303:quantum/quantum.c ****                 debug_enable ^= 1;
 304:quantum/quantum.c ****                 if (debug_enable) {
 305:quantum/quantum.c ****                     print("DEBUG: enabled.\n");
 306:quantum/quantum.c ****                 } else {
 307:quantum/quantum.c ****                     print("DEBUG: disabled.\n");
 308:quantum/quantum.c ****                 }
 309:quantum/quantum.c ****             }
 310:quantum/quantum.c ****             return false;
 311:quantum/quantum.c ****         case EEPROM_RESET:
 312:quantum/quantum.c ****             if (record->event.pressed) {
 313:quantum/quantum.c ****                 eeconfig_init();
 314:quantum/quantum.c ****             }
 315:quantum/quantum.c ****             return false;
 316:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
 317:quantum/quantum.c ****         case FC_TOG:
 318:quantum/quantum.c ****             if (record->event.pressed) {
 319:quantum/quantum.c ****                 FAUXCLICKY_TOGGLE;
 320:quantum/quantum.c ****             }
 321:quantum/quantum.c ****             return false;
 322:quantum/quantum.c ****         case FC_ON:
 323:quantum/quantum.c ****             if (record->event.pressed) {
 324:quantum/quantum.c ****                 FAUXCLICKY_ON;
 325:quantum/quantum.c ****             }
 326:quantum/quantum.c ****             return false;
 327:quantum/quantum.c ****         case FC_OFF:
 328:quantum/quantum.c ****             if (record->event.pressed) {
 329:quantum/quantum.c ****                 FAUXCLICKY_OFF;
 330:quantum/quantum.c ****             }
 331:quantum/quantum.c ****             return false;
 332:quantum/quantum.c **** #endif
 333:quantum/quantum.c **** #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 334:quantum/quantum.c ****         case RGB_TOG:
 335:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 336:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 337:quantum/quantum.c ****             if (record->event.pressed) {
 338:quantum/quantum.c **** #    else
 339:quantum/quantum.c ****             if (!record->event.pressed) {
 340:quantum/quantum.c **** #    endif
 341:quantum/quantum.c ****                 rgblight_toggle();
 342:quantum/quantum.c ****             }
 343:quantum/quantum.c ****             return false;
 344:quantum/quantum.c ****         case RGB_MODE_FORWARD:
 345:quantum/quantum.c ****             if (record->event.pressed) {
 346:quantum/quantum.c ****                 uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT));
 347:quantum/quantum.c ****                 if (shifted) {
 348:quantum/quantum.c ****                     rgblight_step_reverse();
 349:quantum/quantum.c ****                 } else {
 350:quantum/quantum.c ****                     rgblight_step();
 351:quantum/quantum.c ****                 }
 352:quantum/quantum.c ****             }
 353:quantum/quantum.c ****             return false;
 354:quantum/quantum.c ****         case RGB_MODE_REVERSE:
 355:quantum/quantum.c ****             if (record->event.pressed) {
 356:quantum/quantum.c ****                 uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT));
 357:quantum/quantum.c ****                 if (shifted) {
 358:quantum/quantum.c ****                     rgblight_step();
 359:quantum/quantum.c ****                 } else {
 360:quantum/quantum.c ****                     rgblight_step_reverse();
 361:quantum/quantum.c ****                 }
 362:quantum/quantum.c ****             }
 363:quantum/quantum.c ****             return false;
 364:quantum/quantum.c ****         case RGB_HUI:
 365:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 366:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 367:quantum/quantum.c ****             if (record->event.pressed) {
 368:quantum/quantum.c **** #    else
 369:quantum/quantum.c ****             if (!record->event.pressed) {
 370:quantum/quantum.c **** #    endif
 371:quantum/quantum.c ****                 rgblight_increase_hue();
 372:quantum/quantum.c ****             }
 373:quantum/quantum.c ****             return false;
 374:quantum/quantum.c ****         case RGB_HUD:
 375:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 376:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 377:quantum/quantum.c ****             if (record->event.pressed) {
 378:quantum/quantum.c **** #    else
 379:quantum/quantum.c ****             if (!record->event.pressed) {
 380:quantum/quantum.c **** #    endif
 381:quantum/quantum.c ****                 rgblight_decrease_hue();
 382:quantum/quantum.c ****             }
 383:quantum/quantum.c ****             return false;
 384:quantum/quantum.c ****         case RGB_SAI:
 385:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 386:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 387:quantum/quantum.c ****             if (record->event.pressed) {
 388:quantum/quantum.c **** #    else
 389:quantum/quantum.c ****             if (!record->event.pressed) {
 390:quantum/quantum.c **** #    endif
 391:quantum/quantum.c ****                 rgblight_increase_sat();
 392:quantum/quantum.c ****             }
 393:quantum/quantum.c ****             return false;
 394:quantum/quantum.c ****         case RGB_SAD:
 395:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 396:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 397:quantum/quantum.c ****             if (record->event.pressed) {
 398:quantum/quantum.c **** #    else
 399:quantum/quantum.c ****             if (!record->event.pressed) {
 400:quantum/quantum.c **** #    endif
 401:quantum/quantum.c ****                 rgblight_decrease_sat();
 402:quantum/quantum.c ****             }
 403:quantum/quantum.c ****             return false;
 404:quantum/quantum.c ****         case RGB_VAI:
 405:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 406:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 407:quantum/quantum.c ****             if (record->event.pressed) {
 408:quantum/quantum.c **** #    else
 409:quantum/quantum.c ****             if (!record->event.pressed) {
 410:quantum/quantum.c **** #    endif
 411:quantum/quantum.c ****                 rgblight_increase_val();
 412:quantum/quantum.c ****             }
 413:quantum/quantum.c ****             return false;
 414:quantum/quantum.c ****         case RGB_VAD:
 415:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 416:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 417:quantum/quantum.c ****             if (record->event.pressed) {
 418:quantum/quantum.c **** #    else
 419:quantum/quantum.c ****             if (!record->event.pressed) {
 420:quantum/quantum.c **** #    endif
 421:quantum/quantum.c ****                 rgblight_decrease_val();
 422:quantum/quantum.c ****             }
 423:quantum/quantum.c ****             return false;
 424:quantum/quantum.c ****         case RGB_SPI:
 425:quantum/quantum.c ****             if (record->event.pressed) {
 426:quantum/quantum.c ****                 rgblight_increase_speed();
 427:quantum/quantum.c ****             }
 428:quantum/quantum.c ****             return false;
 429:quantum/quantum.c ****         case RGB_SPD:
 430:quantum/quantum.c ****             if (record->event.pressed) {
 431:quantum/quantum.c ****                 rgblight_decrease_speed();
 432:quantum/quantum.c ****             }
 433:quantum/quantum.c ****             return false;
 434:quantum/quantum.c ****         case RGB_MODE_PLAIN:
 435:quantum/quantum.c ****             if (record->event.pressed) {
 436:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 437:quantum/quantum.c ****             }
 438:quantum/quantum.c ****             return false;
 439:quantum/quantum.c ****         case RGB_MODE_BREATHE:
 440:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_BREATHING
 441:quantum/quantum.c ****             if (record->event.pressed) {
 442:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) && (rgblight_get_mode() < RGBL
 443:quantum/quantum.c ****                     rgblight_step();
 444:quantum/quantum.c ****                 } else {
 445:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_BREATHING);
 446:quantum/quantum.c ****                 }
 447:quantum/quantum.c ****             }
 448:quantum/quantum.c **** #    endif
 449:quantum/quantum.c ****             return false;
 450:quantum/quantum.c ****         case RGB_MODE_RAINBOW:
 451:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_RAINBOW_MOOD
 452:quantum/quantum.c ****             if (record->event.pressed) {
 453:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) && (rgblight_get_mode() < R
 454:quantum/quantum.c ****                     rgblight_step();
 455:quantum/quantum.c ****                 } else {
 456:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_RAINBOW_MOOD);
 457:quantum/quantum.c ****                 }
 458:quantum/quantum.c ****             }
 459:quantum/quantum.c **** #    endif
 460:quantum/quantum.c ****             return false;
 461:quantum/quantum.c ****         case RGB_MODE_SWIRL:
 462:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_RAINBOW_SWIRL
 463:quantum/quantum.c ****             if (record->event.pressed) {
 464:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) && (rgblight_get_mode() < 
 465:quantum/quantum.c ****                     rgblight_step();
 466:quantum/quantum.c ****                 } else {
 467:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_RAINBOW_SWIRL);
 468:quantum/quantum.c ****                 }
 469:quantum/quantum.c ****             }
 470:quantum/quantum.c **** #    endif
 471:quantum/quantum.c ****             return false;
 472:quantum/quantum.c ****         case RGB_MODE_SNAKE:
 473:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_SNAKE
 474:quantum/quantum.c ****             if (record->event.pressed) {
 475:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) && (rgblight_get_mode() < RGBLIGHT
 476:quantum/quantum.c ****                     rgblight_step();
 477:quantum/quantum.c ****                 } else {
 478:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_SNAKE);
 479:quantum/quantum.c ****                 }
 480:quantum/quantum.c ****             }
 481:quantum/quantum.c **** #    endif
 482:quantum/quantum.c ****             return false;
 483:quantum/quantum.c ****         case RGB_MODE_KNIGHT:
 484:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_KNIGHT
 485:quantum/quantum.c ****             if (record->event.pressed) {
 486:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) && (rgblight_get_mode() < RGBLIGH
 487:quantum/quantum.c ****                     rgblight_step();
 488:quantum/quantum.c ****                 } else {
 489:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_KNIGHT);
 490:quantum/quantum.c ****                 }
 491:quantum/quantum.c ****             }
 492:quantum/quantum.c **** #    endif
 493:quantum/quantum.c ****             return false;
 494:quantum/quantum.c ****         case RGB_MODE_XMAS:
 495:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_CHRISTMAS
 496:quantum/quantum.c ****             if (record->event.pressed) {
 497:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 498:quantum/quantum.c ****             }
 499:quantum/quantum.c **** #    endif
 500:quantum/quantum.c ****             return false;
 501:quantum/quantum.c ****         case RGB_MODE_GRADIENT:
 502:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_STATIC_GRADIENT
 503:quantum/quantum.c ****             if (record->event.pressed) {
 504:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) && (rgblight_get_mode() 
 505:quantum/quantum.c ****                     rgblight_step();
 506:quantum/quantum.c ****                 } else {
 507:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_STATIC_GRADIENT);
 508:quantum/quantum.c ****                 }
 509:quantum/quantum.c ****             }
 510:quantum/quantum.c **** #    endif
 511:quantum/quantum.c ****             return false;
 512:quantum/quantum.c ****         case RGB_MODE_RGBTEST:
 513:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_RGB_TEST
 514:quantum/quantum.c ****             if (record->event.pressed) {
 515:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 516:quantum/quantum.c ****             }
 517:quantum/quantum.c **** #    endif
 518:quantum/quantum.c ****             return false;
 519:quantum/quantum.c **** #endif  // defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 520:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 521:quantum/quantum.c ****         case VLK_TOG:
 522:quantum/quantum.c ****             if (record->event.pressed) {
 523:quantum/quantum.c ****                 velocikey_toggle();
 524:quantum/quantum.c ****             }
 525:quantum/quantum.c ****             return false;
 526:quantum/quantum.c **** #endif
 527:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
 528:quantum/quantum.c ****         case OUT_AUTO:
 529:quantum/quantum.c ****             if (record->event.pressed) {
 530:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 531:quantum/quantum.c ****             }
 532:quantum/quantum.c ****             return false;
 533:quantum/quantum.c ****         case OUT_USB:
 534:quantum/quantum.c ****             if (record->event.pressed) {
 535:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 536:quantum/quantum.c ****             }
 537:quantum/quantum.c ****             return false;
 538:quantum/quantum.c **** #    ifdef BLUETOOTH_ENABLE
 539:quantum/quantum.c ****         case OUT_BT:
 540:quantum/quantum.c ****             if (record->event.pressed) {
 541:quantum/quantum.c ****                 set_output(OUTPUT_BLUETOOTH);
 542:quantum/quantum.c ****             }
 543:quantum/quantum.c ****             return false;
 544:quantum/quantum.c **** #    endif
 545:quantum/quantum.c **** #endif
 546:quantum/quantum.c ****         case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_ALT_GUI:
 547:quantum/quantum.c ****         case MAGIC_SWAP_LCTL_LGUI ... MAGIC_TOGGLE_CTL_GUI:
 548:quantum/quantum.c ****             if (record->event.pressed) {
 549:quantum/quantum.c ****                 // MAGIC actions (BOOTMAGIC without the boot)
 550:quantum/quantum.c ****                 if (!eeconfig_is_enabled()) {
 551:quantum/quantum.c ****                     eeconfig_init();
 552:quantum/quantum.c ****                 }
 553:quantum/quantum.c ****                 /* keymap config */
 554:quantum/quantum.c ****                 keymap_config.raw = eeconfig_read_keymap();
 555:quantum/quantum.c ****                 switch (keycode) {
 556:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 557:quantum/quantum.c ****                         keymap_config.swap_control_capslock = true;
 558:quantum/quantum.c ****                         break;
 559:quantum/quantum.c ****                     case MAGIC_CAPSLOCK_TO_CONTROL:
 560:quantum/quantum.c ****                         keymap_config.capslock_to_control = true;
 561:quantum/quantum.c ****                         break;
 562:quantum/quantum.c ****                     case MAGIC_SWAP_LALT_LGUI:
 563:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = true;
 564:quantum/quantum.c ****                         break;
 565:quantum/quantum.c ****                     case MAGIC_SWAP_RALT_RGUI:
 566:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = true;
 567:quantum/quantum.c ****                         break;
 568:quantum/quantum.c ****                     case MAGIC_SWAP_LCTL_LGUI:
 569:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = true;
 570:quantum/quantum.c ****                         break;
 571:quantum/quantum.c ****                     case MAGIC_SWAP_RCTL_RGUI:
 572:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = true;
 573:quantum/quantum.c ****                         break;
 574:quantum/quantum.c ****                     case MAGIC_NO_GUI:
 575:quantum/quantum.c ****                         keymap_config.no_gui = true;
 576:quantum/quantum.c ****                         break;
 577:quantum/quantum.c ****                     case MAGIC_SWAP_GRAVE_ESC:
 578:quantum/quantum.c ****                         keymap_config.swap_grave_esc = true;
 579:quantum/quantum.c ****                         break;
 580:quantum/quantum.c ****                     case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 581:quantum/quantum.c ****                         keymap_config.swap_backslash_backspace = true;
 582:quantum/quantum.c ****                         break;
 583:quantum/quantum.c ****                     case MAGIC_HOST_NKRO:
 584:quantum/quantum.c ****                         keymap_config.nkro = true;
 585:quantum/quantum.c ****                         break;
 586:quantum/quantum.c ****                     case MAGIC_SWAP_ALT_GUI:
 587:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = keymap_config.swap_ralt_rgui = true;
 588:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 589:quantum/quantum.c ****                         PLAY_SONG(ag_swap_song);
 590:quantum/quantum.c **** #endif
 591:quantum/quantum.c ****                         break;
 592:quantum/quantum.c ****                     case MAGIC_SWAP_CTL_GUI:
 593:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = keymap_config.swap_rctl_rgui = true;
 594:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 595:quantum/quantum.c ****                         PLAY_SONG(cg_swap_song);
 596:quantum/quantum.c **** #endif
 597:quantum/quantum.c ****                         break;
 598:quantum/quantum.c ****                     case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 599:quantum/quantum.c ****                         keymap_config.swap_control_capslock = false;
 600:quantum/quantum.c ****                         break;
 601:quantum/quantum.c ****                     case MAGIC_UNCAPSLOCK_TO_CONTROL:
 602:quantum/quantum.c ****                         keymap_config.capslock_to_control = false;
 603:quantum/quantum.c ****                         break;
 604:quantum/quantum.c ****                     case MAGIC_UNSWAP_LALT_LGUI:
 605:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = false;
 606:quantum/quantum.c ****                         break;
 607:quantum/quantum.c ****                     case MAGIC_UNSWAP_RALT_RGUI:
 608:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = false;
 609:quantum/quantum.c ****                         break;
 610:quantum/quantum.c ****                     case MAGIC_UNSWAP_LCTL_LGUI:
 611:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = false;
 612:quantum/quantum.c ****                         break;
 613:quantum/quantum.c ****                     case MAGIC_UNSWAP_RCTL_RGUI:
 614:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = false;
 615:quantum/quantum.c ****                         break;
 616:quantum/quantum.c ****                     case MAGIC_UNNO_GUI:
 617:quantum/quantum.c ****                         keymap_config.no_gui = false;
 618:quantum/quantum.c ****                         break;
 619:quantum/quantum.c ****                     case MAGIC_UNSWAP_GRAVE_ESC:
 620:quantum/quantum.c ****                         keymap_config.swap_grave_esc = false;
 621:quantum/quantum.c ****                         break;
 622:quantum/quantum.c ****                     case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 623:quantum/quantum.c ****                         keymap_config.swap_backslash_backspace = false;
 624:quantum/quantum.c ****                         break;
 625:quantum/quantum.c ****                     case MAGIC_UNHOST_NKRO:
 626:quantum/quantum.c ****                         keymap_config.nkro = false;
 627:quantum/quantum.c ****                         break;
 628:quantum/quantum.c ****                     case MAGIC_UNSWAP_ALT_GUI:
 629:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = keymap_config.swap_ralt_rgui = false;
 630:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 631:quantum/quantum.c ****                         PLAY_SONG(ag_norm_song);
 632:quantum/quantum.c **** #endif
 633:quantum/quantum.c ****                         break;
 634:quantum/quantum.c ****                     case MAGIC_UNSWAP_CTL_GUI:
 635:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = keymap_config.swap_rctl_rgui = false;
 636:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 637:quantum/quantum.c ****                         PLAY_SONG(cg_norm_song);
 638:quantum/quantum.c **** #endif
 639:quantum/quantum.c ****                         break;
 640:quantum/quantum.c ****                     case MAGIC_TOGGLE_ALT_GUI:
 641:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = !keymap_config.swap_lalt_lgui;
 642:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = keymap_config.swap_lalt_lgui;
 643:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 644:quantum/quantum.c ****                         if (keymap_config.swap_ralt_rgui) {
 645:quantum/quantum.c ****                             PLAY_SONG(ag_swap_song);
 646:quantum/quantum.c ****                         } else {
 647:quantum/quantum.c ****                             PLAY_SONG(ag_norm_song);
 648:quantum/quantum.c ****                         }
 649:quantum/quantum.c **** #endif
 650:quantum/quantum.c ****                         break;
 651:quantum/quantum.c ****                     case MAGIC_TOGGLE_CTL_GUI:
 652:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = !keymap_config.swap_lctl_lgui;
 653:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = keymap_config.swap_lctl_lgui;
 654:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 655:quantum/quantum.c ****                         if (keymap_config.swap_rctl_rgui) {
 656:quantum/quantum.c ****                             PLAY_SONG(cg_swap_song);
 657:quantum/quantum.c ****                         } else {
 658:quantum/quantum.c ****                             PLAY_SONG(cg_norm_song);
 659:quantum/quantum.c ****                         }
 660:quantum/quantum.c **** #endif
 661:quantum/quantum.c ****                         break;
 662:quantum/quantum.c ****                     case MAGIC_TOGGLE_NKRO:
 663:quantum/quantum.c ****                         keymap_config.nkro = !keymap_config.nkro;
 664:quantum/quantum.c ****                         break;
 665:quantum/quantum.c ****                     default:
 666:quantum/quantum.c ****                         break;
 667:quantum/quantum.c ****                 }
 668:quantum/quantum.c ****                 eeconfig_update_keymap(keymap_config.raw);
 669:quantum/quantum.c ****                 clear_keyboard();  // clear to prevent stuck keys
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****                 return false;
 672:quantum/quantum.c ****             }
 673:quantum/quantum.c ****             break;
 674:quantum/quantum.c **** 
 675:quantum/quantum.c ****         case GRAVE_ESC: {
 676:quantum/quantum.c ****             uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT) | MOD_BIT(KC_L
 677:quantum/quantum.c **** 
 678:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 679:quantum/quantum.c ****             // if ALT is pressed, ESC is always sent
 680:quantum/quantum.c ****             // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 681:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 682:quantum/quantum.c ****                 shifted = 0;
 683:quantum/quantum.c ****             }
 684:quantum/quantum.c **** #endif
 685:quantum/quantum.c **** 
 686:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 687:quantum/quantum.c ****             // if CTRL is pressed, ESC is always sent
 688:quantum/quantum.c ****             // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 689:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 690:quantum/quantum.c ****                 shifted = 0;
 691:quantum/quantum.c ****             }
 692:quantum/quantum.c **** #endif
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 695:quantum/quantum.c ****             // if GUI is pressed, ESC is always sent
 696:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 697:quantum/quantum.c ****                 shifted = 0;
 698:quantum/quantum.c ****             }
 699:quantum/quantum.c **** #endif
 700:quantum/quantum.c **** 
 701:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 702:quantum/quantum.c ****             // if SHIFT is pressed, ESC is always sent
 703:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 704:quantum/quantum.c ****                 shifted = 0;
 705:quantum/quantum.c ****             }
 706:quantum/quantum.c **** #endif
 707:quantum/quantum.c **** 
 708:quantum/quantum.c ****             if (record->event.pressed) {
 709:quantum/quantum.c ****                 grave_esc_was_shifted = shifted;
 710:quantum/quantum.c ****                 add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 711:quantum/quantum.c ****             } else {
 712:quantum/quantum.c ****                 del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 713:quantum/quantum.c ****             }
 714:quantum/quantum.c **** 
 715:quantum/quantum.c ****             send_keyboard_report();
 716:quantum/quantum.c ****             return false;
 717:quantum/quantum.c ****         }
 718:quantum/quantum.c **** 
 719:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 720:quantum/quantum.c ****         case BL_BRTG: {
 721:quantum/quantum.c ****             if (record->event.pressed) {
 722:quantum/quantum.c ****                 backlight_toggle_breathing();
 723:quantum/quantum.c ****             }
 724:quantum/quantum.c ****             return false;
 725:quantum/quantum.c ****         }
 726:quantum/quantum.c **** #endif
 727:quantum/quantum.c ****     }
 728:quantum/quantum.c **** 
 729:quantum/quantum.c ****     return process_action_kb(record);
 730:quantum/quantum.c **** }
 731:quantum/quantum.c **** 
 732:quantum/quantum.c **** __attribute__((weak)) const bool ascii_to_shift_lut[128] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 733:quantum/quantum.c **** 
 734:quantum/quantum.c ****                                                                     0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1
 735:quantum/quantum.c **** 
 736:quantum/quantum.c **** __attribute__((weak)) const bool ascii_to_altgr_lut[128] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 737:quantum/quantum.c **** 
 738:quantum/quantum.c ****                                                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 739:quantum/quantum.c **** 
 740:quantum/quantum.c **** __attribute__((weak)) const uint8_t ascii_to_keycode_lut[128] PROGMEM = {// NUL   SOH      STX     
 741:quantum/quantum.c ****                                                                          XXXXXXX, XXXXXXX, XXXXXXX,
 742:quantum/quantum.c ****                                                                          // BS    TAB      LF      
 743:quantum/quantum.c ****                                                                          KC_BSPC, KC_TAB, KC_ENT, X
 744:quantum/quantum.c ****                                                                          // DLE   DC1      DC2     
 745:quantum/quantum.c ****                                                                          XXXXXXX, XXXXXXX, XXXXXXX,
 746:quantum/quantum.c ****                                                                          // CAN   EM       SUB     
 747:quantum/quantum.c ****                                                                          XXXXXXX, XXXXXXX, XXXXXXX,
 748:quantum/quantum.c **** 
 749:quantum/quantum.c ****                                                                          //       !        "       
 750:quantum/quantum.c ****                                                                          KC_SPC, KC_1, KC_QUOT, KC_
 751:quantum/quantum.c ****                                                                          // (     )        *       
 752:quantum/quantum.c ****                                                                          KC_9, KC_0, KC_8, KC_EQL, 
 753:quantum/quantum.c ****                                                                          // 0     1        2       
 754:quantum/quantum.c ****                                                                          KC_0, KC_1, KC_2, KC_3, KC
 755:quantum/quantum.c ****                                                                          // 8     9        :       
 756:quantum/quantum.c ****                                                                          KC_8, KC_9, KC_SCLN, KC_SC
 757:quantum/quantum.c ****                                                                          // @     A        B       
 758:quantum/quantum.c ****                                                                          KC_2, KC_A, KC_B, KC_C, KC
 759:quantum/quantum.c ****                                                                          // H     I        J       
 760:quantum/quantum.c ****                                                                          KC_H, KC_I, KC_J, KC_K, KC
 761:quantum/quantum.c ****                                                                          // P     Q        R       
 762:quantum/quantum.c ****                                                                          KC_P, KC_Q, KC_R, KC_S, KC
 763:quantum/quantum.c ****                                                                          // X     Y        Z       
 764:quantum/quantum.c ****                                                                          KC_X, KC_Y, KC_Z, KC_LBRC,
 765:quantum/quantum.c ****                                                                          // `     a        b       
 766:quantum/quantum.c ****                                                                          KC_GRV, KC_A, KC_B, KC_C, 
 767:quantum/quantum.c ****                                                                          // h     i        j       
 768:quantum/quantum.c ****                                                                          KC_H, KC_I, KC_J, KC_K, KC
 769:quantum/quantum.c ****                                                                          // p     q        r       
 770:quantum/quantum.c ****                                                                          KC_P, KC_Q, KC_R, KC_S, KC
 771:quantum/quantum.c ****                                                                          // x     y        z       
 772:quantum/quantum.c ****                                                                          KC_X, KC_Y, KC_Z, KC_LBRC,
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_string(const char *str) { send_string_with_delay(str, 0); }
 775:quantum/quantum.c **** 
 776:quantum/quantum.c **** void send_string_P(const char *str) { send_string_with_delay_P(str, 0); }
 777:quantum/quantum.c **** 
 778:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 779:quantum/quantum.c ****     while (1) {
 780:quantum/quantum.c ****         char ascii_code = *str;
 781:quantum/quantum.c ****         if (!ascii_code) break;
 782:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 783:quantum/quantum.c ****             // tap
 784:quantum/quantum.c ****             uint8_t keycode = *(++str);
 785:quantum/quantum.c ****             register_code(keycode);
 786:quantum/quantum.c ****             unregister_code(keycode);
 787:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 788:quantum/quantum.c ****             // down
 789:quantum/quantum.c ****             uint8_t keycode = *(++str);
 790:quantum/quantum.c ****             register_code(keycode);
 791:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 792:quantum/quantum.c ****             // up
 793:quantum/quantum.c ****             uint8_t keycode = *(++str);
 794:quantum/quantum.c ****             unregister_code(keycode);
 795:quantum/quantum.c ****         } else {
 796:quantum/quantum.c ****             send_char(ascii_code);
 797:quantum/quantum.c ****         }
 798:quantum/quantum.c ****         ++str;
 799:quantum/quantum.c ****         // interval
 800:quantum/quantum.c ****         {
 801:quantum/quantum.c ****             uint8_t ms = interval;
 802:quantum/quantum.c ****             while (ms--) wait_ms(1);
 803:quantum/quantum.c ****         }
 804:quantum/quantum.c ****     }
 805:quantum/quantum.c **** }
 806:quantum/quantum.c **** 
 807:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 808:quantum/quantum.c ****     while (1) {
 809:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 810:quantum/quantum.c ****         if (!ascii_code) break;
 811:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 812:quantum/quantum.c ****             // tap
 813:quantum/quantum.c ****             uint8_t keycode = pgm_read_byte(++str);
 814:quantum/quantum.c ****             register_code(keycode);
 815:quantum/quantum.c ****             unregister_code(keycode);
 816:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 817:quantum/quantum.c ****             // down
 818:quantum/quantum.c ****             uint8_t keycode = pgm_read_byte(++str);
 819:quantum/quantum.c ****             register_code(keycode);
 820:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 821:quantum/quantum.c ****             // up
 822:quantum/quantum.c ****             uint8_t keycode = pgm_read_byte(++str);
 823:quantum/quantum.c ****             unregister_code(keycode);
 824:quantum/quantum.c ****         } else {
 825:quantum/quantum.c ****             send_char(ascii_code);
 826:quantum/quantum.c ****         }
 827:quantum/quantum.c ****         ++str;
 828:quantum/quantum.c ****         // interval
 829:quantum/quantum.c ****         {
 830:quantum/quantum.c ****             uint8_t ms = interval;
 831:quantum/quantum.c ****             while (ms--) wait_ms(1);
 832:quantum/quantum.c ****         }
 833:quantum/quantum.c ****     }
 834:quantum/quantum.c **** }
 835:quantum/quantum.c **** 
 836:quantum/quantum.c **** void send_char(char ascii_code) {
 548               		.loc 1 836 0
 549               		.cfi_startproc
 550               	.LVL54:
 551 0000 1F93      		push r17
 552               	.LCFI15:
 553               		.cfi_def_cfa_offset 3
 554               		.cfi_offset 17, -2
 555 0002 CF93      		push r28
 556               	.LCFI16:
 557               		.cfi_def_cfa_offset 4
 558               		.cfi_offset 28, -3
 559 0004 DF93      		push r29
 560               	.LCFI17:
 561               		.cfi_def_cfa_offset 5
 562               		.cfi_offset 29, -4
 563               	/* prologue: function */
 564               	/* frame size = 0 */
 565               	/* stack size = 3 */
 566               	.L__stack_usage = 3
 567 0006 90E0      		ldi r25,0
 568               	.LVL55:
 569               	.LBB26:
 837:quantum/quantum.c ****     uint8_t keycode    = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 570               		.loc 1 837 0
 571 0008 FC01      		movw r30,r24
 572 000a E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 573 000c F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 574               	.LVL56:
 575               	/* #APP */
 576               	 ;  837 "quantum/quantum.c" 1
 577 000e 1491      		lpm r17, Z
 578               		
 579               	 ;  0 "" 2
 580               	.LVL57:
 581               	/* #NOAPP */
 582               	.LBE26:
 583               	.LBB27:
 838:quantum/quantum.c ****     bool    is_shifted = pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code]);
 584               		.loc 1 838 0
 585 0010 FC01      		movw r30,r24
 586               	.LVL58:
 587 0012 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 588 0014 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 589               	.LVL59:
 590               	/* #APP */
 591               	 ;  838 "quantum/quantum.c" 1
 592 0016 D491      		lpm r29, Z
 593               		
 594               	 ;  0 "" 2
 595               	.LVL60:
 596               	/* #NOAPP */
 597               	.LBE27:
 598               	.LBB28:
 839:quantum/quantum.c ****     bool    is_altgred = pgm_read_byte(&ascii_to_altgr_lut[(uint8_t)ascii_code]);
 599               		.loc 1 839 0
 600 0018 8050      		subi r24,lo8(-(ascii_to_altgr_lut))
 601 001a 9040      		sbci r25,hi8(-(ascii_to_altgr_lut))
 602               	.LVL61:
 603 001c FC01      		movw r30,r24
 604               	.LVL62:
 605               	/* #APP */
 606               	 ;  839 "quantum/quantum.c" 1
 607 001e C491      		lpm r28, Z
 608               		
 609               	 ;  0 "" 2
 610               	.LVL63:
 611               	/* #NOAPP */
 612               	.LBE28:
 840:quantum/quantum.c **** 
 841:quantum/quantum.c ****     if (is_shifted) {
 613               		.loc 1 841 0
 614 0020 DD23      		tst r29
 615 0022 01F0      		breq .L46
 842:quantum/quantum.c ****         register_code(KC_LSFT);
 616               		.loc 1 842 0
 617 0024 81EE      		ldi r24,lo8(-31)
 618               	.LVL64:
 619 0026 0E94 0000 		call register_code
 620               	.LVL65:
 621               	.L46:
 843:quantum/quantum.c ****     }
 844:quantum/quantum.c ****     if (is_altgred) {
 622               		.loc 1 844 0
 623 002a CC23      		tst r28
 624 002c 01F0      		breq .L47
 845:quantum/quantum.c ****         register_code(KC_RALT);
 625               		.loc 1 845 0
 626 002e 86EE      		ldi r24,lo8(-26)
 627 0030 0E94 0000 		call register_code
 628               	.LVL66:
 629               	.L47:
 846:quantum/quantum.c ****     }
 847:quantum/quantum.c ****     tap_code(keycode);
 630               		.loc 1 847 0
 631 0034 812F      		mov r24,r17
 632 0036 0E94 0000 		call tap_code
 633               	.LVL67:
 848:quantum/quantum.c ****     if (is_altgred) {
 634               		.loc 1 848 0
 635 003a CC23      		tst r28
 636 003c 01F0      		breq .L48
 849:quantum/quantum.c ****         unregister_code(KC_RALT);
 637               		.loc 1 849 0
 638 003e 86EE      		ldi r24,lo8(-26)
 639 0040 0E94 0000 		call unregister_code
 640               	.LVL68:
 641               	.L48:
 850:quantum/quantum.c ****     }
 851:quantum/quantum.c ****     if (is_shifted) {
 642               		.loc 1 851 0
 643 0044 DD23      		tst r29
 644 0046 01F0      		breq .L45
 852:quantum/quantum.c ****         unregister_code(KC_LSFT);
 645               		.loc 1 852 0
 646 0048 81EE      		ldi r24,lo8(-31)
 647               	/* epilogue start */
 853:quantum/quantum.c ****     }
 854:quantum/quantum.c **** }
 648               		.loc 1 854 0
 649 004a DF91      		pop r29
 650               	.LVL69:
 651 004c CF91      		pop r28
 652               	.LVL70:
 653 004e 1F91      		pop r17
 654               	.LVL71:
 852:quantum/quantum.c ****         unregister_code(KC_LSFT);
 655               		.loc 1 852 0
 656 0050 0C94 0000 		jmp unregister_code
 657               	.LVL72:
 658               	.L45:
 659               	/* epilogue start */
 660               		.loc 1 854 0
 661 0054 DF91      		pop r29
 662               	.LVL73:
 663 0056 CF91      		pop r28
 664               	.LVL74:
 665 0058 1F91      		pop r17
 666               	.LVL75:
 667 005a 0895      		ret
 668               		.cfi_endproc
 669               	.LFE38:
 671               		.section	.text.send_string_with_delay,"ax",@progbits
 672               	.global	send_string_with_delay
 674               	send_string_with_delay:
 675               	.LFB36:
 778:quantum/quantum.c ****     while (1) {
 676               		.loc 1 778 0
 677               		.cfi_startproc
 678               	.LVL76:
 679 0000 FF92      		push r15
 680               	.LCFI18:
 681               		.cfi_def_cfa_offset 3
 682               		.cfi_offset 15, -2
 683 0002 0F93      		push r16
 684               	.LCFI19:
 685               		.cfi_def_cfa_offset 4
 686               		.cfi_offset 16, -3
 687 0004 1F93      		push r17
 688               	.LCFI20:
 689               		.cfi_def_cfa_offset 5
 690               		.cfi_offset 17, -4
 691 0006 CF93      		push r28
 692               	.LCFI21:
 693               		.cfi_def_cfa_offset 6
 694               		.cfi_offset 28, -5
 695 0008 DF93      		push r29
 696               	.LCFI22:
 697               		.cfi_def_cfa_offset 7
 698               		.cfi_offset 29, -6
 699               	/* prologue: function */
 700               	/* frame size = 0 */
 701               	/* stack size = 5 */
 702               	.L__stack_usage = 5
 703 000a EC01      		movw r28,r24
 704 000c F62E      		mov r15,r22
 705               	.LVL77:
 706               	.L67:
 707               	.LBB29:
 780:quantum/quantum.c ****         if (!ascii_code) break;
 708               		.loc 1 780 0
 709 000e 8881      		ld r24,Y
 710               	.LVL78:
 781:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 711               		.loc 1 781 0
 712 0010 8823      		tst r24
 713 0012 01F0      		breq .L59
 714 0014 8E01      		movw r16,r28
 715 0016 0F5F      		subi r16,-1
 716 0018 1F4F      		sbci r17,-1
 782:quantum/quantum.c ****             // tap
 717               		.loc 1 782 0
 718 001a 8130      		cpi r24,lo8(1)
 719 001c 01F4      		brne .L61
 720               	.LVL79:
 721               	.LBB30:
 784:quantum/quantum.c ****             register_code(keycode);
 722               		.loc 1 784 0
 723 001e C981      		ldd r28,Y+1
 724               	.LVL80:
 785:quantum/quantum.c ****             unregister_code(keycode);
 725               		.loc 1 785 0
 726 0020 8C2F      		mov r24,r28
 727               	.LVL81:
 728 0022 0E94 0000 		call register_code
 729               	.LVL82:
 786:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 730               		.loc 1 786 0
 731 0026 8C2F      		mov r24,r28
 732               	.LVL83:
 733               	.L68:
 734               	.LBE30:
 735               	.LBB31:
 794:quantum/quantum.c ****         } else {
 736               		.loc 1 794 0
 737 0028 0E94 0000 		call unregister_code
 738               	.LVL84:
 739               	.LBE31:
 740 002c 00C0      		rjmp .L62
 741               	.LVL85:
 742               	.L61:
 787:quantum/quantum.c ****             // down
 743               		.loc 1 787 0
 744 002e 8230      		cpi r24,lo8(2)
 745 0030 01F4      		brne .L63
 746               	.LVL86:
 747               	.LBB32:
 790:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 748               		.loc 1 790 0
 749 0032 8981      		ldd r24,Y+1
 750               	.LVL87:
 751 0034 0E94 0000 		call register_code
 752               	.LVL88:
 753               	.L62:
 754               	.LBE32:
 798:quantum/quantum.c ****         // interval
 755               		.loc 1 798 0
 756 0038 E801      		movw r28,r16
 757 003a 2196      		adiw r28,1
 758               	.LVL89:
 759               	.LBB33:
 801:quantum/quantum.c ****             while (ms--) wait_ms(1);
 760               		.loc 1 801 0
 761 003c 8F2D      		mov r24,r15
 762               	.LVL90:
 763               	.L65:
 802:quantum/quantum.c ****         }
 764               		.loc 1 802 0 discriminator 1
 765               	.LVL91:
 766 003e 8150      		subi r24,1
 767 0040 00F0      		brcs .L67
 768               	.LBB34:
 769               	.LBB35:
 770               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 771               		.loc 2 187 0
 772 0042 EFE9      		ldi r30,lo8(3999)
 773 0044 FFE0      		ldi r31,hi8(3999)
 774 0046 3197      	1:	sbiw r30,1
 775 0048 01F4      		brne 1b
 776 004a 00C0      		rjmp .
 777 004c 0000      		nop
 778 004e 00C0      		rjmp .L65
 779               	.LVL92:
 780               	.L63:
 781               	.LBE35:
 782               	.LBE34:
 783               	.LBE33:
 791:quantum/quantum.c ****             // up
 784               		.loc 1 791 0
 785 0050 8330      		cpi r24,lo8(3)
 786 0052 01F4      		brne .L64
 787               	.LVL93:
 788               	.LBB36:
 794:quantum/quantum.c ****         } else {
 789               		.loc 1 794 0
 790 0054 8981      		ldd r24,Y+1
 791               	.LVL94:
 792 0056 00C0      		rjmp .L68
 793               	.LVL95:
 794               	.L64:
 795               	.LBE36:
 796:quantum/quantum.c ****         }
 796               		.loc 1 796 0
 797 0058 0E94 0000 		call send_char
 798               	.LVL96:
 799 005c 8E01      		movw r16,r28
 800 005e 00C0      		rjmp .L62
 801               	.LVL97:
 802               	.L59:
 803               	/* epilogue start */
 804               	.LBE29:
 805:quantum/quantum.c **** 
 805               		.loc 1 805 0
 806 0060 DF91      		pop r29
 807 0062 CF91      		pop r28
 808               	.LVL98:
 809 0064 1F91      		pop r17
 810 0066 0F91      		pop r16
 811 0068 FF90      		pop r15
 812               	.LVL99:
 813 006a 0895      		ret
 814               		.cfi_endproc
 815               	.LFE36:
 817               		.section	.text.send_string,"ax",@progbits
 818               	.global	send_string
 820               	send_string:
 821               	.LFB34:
 774:quantum/quantum.c **** 
 822               		.loc 1 774 0
 823               		.cfi_startproc
 824               	.LVL100:
 825               	/* prologue: function */
 826               	/* frame size = 0 */
 827               	/* stack size = 0 */
 828               	.L__stack_usage = 0
 774:quantum/quantum.c **** 
 829               		.loc 1 774 0
 830 0000 60E0      		ldi r22,0
 831 0002 0C94 0000 		jmp send_string_with_delay
 832               	.LVL101:
 833               		.cfi_endproc
 834               	.LFE34:
 836               		.section	.text.send_string_with_delay_P,"ax",@progbits
 837               	.global	send_string_with_delay_P
 839               	send_string_with_delay_P:
 840               	.LFB37:
 807:quantum/quantum.c ****     while (1) {
 841               		.loc 1 807 0
 842               		.cfi_startproc
 843               	.LVL102:
 844 0000 FF92      		push r15
 845               	.LCFI23:
 846               		.cfi_def_cfa_offset 3
 847               		.cfi_offset 15, -2
 848 0002 0F93      		push r16
 849               	.LCFI24:
 850               		.cfi_def_cfa_offset 4
 851               		.cfi_offset 16, -3
 852 0004 1F93      		push r17
 853               	.LCFI25:
 854               		.cfi_def_cfa_offset 5
 855               		.cfi_offset 17, -4
 856 0006 CF93      		push r28
 857               	.LCFI26:
 858               		.cfi_def_cfa_offset 6
 859               		.cfi_offset 28, -5
 860 0008 DF93      		push r29
 861               	.LCFI27:
 862               		.cfi_def_cfa_offset 7
 863               		.cfi_offset 29, -6
 864               	/* prologue: function */
 865               	/* frame size = 0 */
 866               	/* stack size = 5 */
 867               	.L__stack_usage = 5
 868 000a 8C01      		movw r16,r24
 869 000c F62E      		mov r15,r22
 870               	.LVL103:
 871               	.L78:
 872               	.LBB37:
 873               	.LBB38:
 809:quantum/quantum.c ****         if (!ascii_code) break;
 874               		.loc 1 809 0
 875 000e F801      		movw r30,r16
 876               	/* #APP */
 877               	 ;  809 "quantum/quantum.c" 1
 878 0010 8491      		lpm r24, Z
 879               		
 880               	 ;  0 "" 2
 881               	.LVL104:
 882               	/* #NOAPP */
 883               	.LBE38:
 810:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 884               		.loc 1 810 0
 885 0012 8823      		tst r24
 886 0014 01F0      		breq .L70
 887 0016 E801      		movw r28,r16
 888 0018 2196      		adiw r28,1
 811:quantum/quantum.c ****             // tap
 889               		.loc 1 811 0
 890 001a 8130      		cpi r24,lo8(1)
 891 001c 01F4      		brne .L72
 892               	.LVL105:
 893               	.LBB39:
 894               	.LBB40:
 813:quantum/quantum.c ****             register_code(keycode);
 895               		.loc 1 813 0
 896 001e FE01      		movw r30,r28
 897               	/* #APP */
 898               	 ;  813 "quantum/quantum.c" 1
 899 0020 1491      		lpm r17, Z
 900               		
 901               	 ;  0 "" 2
 902               	.LVL106:
 903               	/* #NOAPP */
 904               	.LBE40:
 814:quantum/quantum.c ****             unregister_code(keycode);
 905               		.loc 1 814 0
 906 0022 812F      		mov r24,r17
 907               	.LVL107:
 908 0024 0E94 0000 		call register_code
 909               	.LVL108:
 815:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 910               		.loc 1 815 0
 911 0028 812F      		mov r24,r17
 912               	.LVL109:
 913               	.L79:
 914               	.LBE39:
 915               	.LBB41:
 823:quantum/quantum.c ****         } else {
 916               		.loc 1 823 0
 917 002a 0E94 0000 		call unregister_code
 918               	.LVL110:
 919               	.LBE41:
 920 002e 00C0      		rjmp .L73
 921               	.LVL111:
 922               	.L72:
 816:quantum/quantum.c ****             // down
 923               		.loc 1 816 0
 924 0030 8230      		cpi r24,lo8(2)
 925 0032 01F4      		brne .L74
 926               	.LVL112:
 927               	.LBB43:
 928               	.LBB44:
 818:quantum/quantum.c ****             register_code(keycode);
 929               		.loc 1 818 0
 930 0034 FE01      		movw r30,r28
 931               	/* #APP */
 932               	 ;  818 "quantum/quantum.c" 1
 933 0036 8491      		lpm r24, Z
 934               		
 935               	 ;  0 "" 2
 936               	.LVL113:
 937               	/* #NOAPP */
 938               	.LBE44:
 819:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 939               		.loc 1 819 0
 940 0038 0E94 0000 		call register_code
 941               	.LVL114:
 942               	.L73:
 943               	.LBE43:
 827:quantum/quantum.c ****         // interval
 944               		.loc 1 827 0
 945 003c 8E01      		movw r16,r28
 946 003e 0F5F      		subi r16,-1
 947 0040 1F4F      		sbci r17,-1
 948               	.LVL115:
 949               	.LBB45:
 830:quantum/quantum.c ****             while (ms--) wait_ms(1);
 950               		.loc 1 830 0
 951 0042 8F2D      		mov r24,r15
 952               	.LVL116:
 953               	.L76:
 831:quantum/quantum.c ****         }
 954               		.loc 1 831 0 discriminator 1
 955               	.LVL117:
 956 0044 8150      		subi r24,1
 957 0046 00F0      		brcs .L78
 958               	.LBB46:
 959               	.LBB47:
 960               		.loc 2 187 0
 961 0048 EFE9      		ldi r30,lo8(3999)
 962 004a FFE0      		ldi r31,hi8(3999)
 963 004c 3197      	1:	sbiw r30,1
 964 004e 01F4      		brne 1b
 965 0050 00C0      		rjmp .
 966 0052 0000      		nop
 967 0054 00C0      		rjmp .L76
 968               	.LVL118:
 969               	.L74:
 970               	.LBE47:
 971               	.LBE46:
 972               	.LBE45:
 820:quantum/quantum.c ****             // up
 973               		.loc 1 820 0
 974 0056 8330      		cpi r24,lo8(3)
 975 0058 01F4      		brne .L75
 976               	.LVL119:
 977               	.LBB48:
 978               	.LBB42:
 822:quantum/quantum.c ****             unregister_code(keycode);
 979               		.loc 1 822 0
 980 005a FE01      		movw r30,r28
 981               	/* #APP */
 982               	 ;  822 "quantum/quantum.c" 1
 983 005c 8491      		lpm r24, Z
 984               		
 985               	 ;  0 "" 2
 986               	.LVL120:
 987               	/* #NOAPP */
 988 005e 00C0      		rjmp .L79
 989               	.LVL121:
 990               	.L75:
 991               	.LBE42:
 992               	.LBE48:
 825:quantum/quantum.c ****         }
 993               		.loc 1 825 0
 994 0060 0E94 0000 		call send_char
 995               	.LVL122:
 996 0064 E801      		movw r28,r16
 997 0066 00C0      		rjmp .L73
 998               	.LVL123:
 999               	.L70:
 1000               	/* epilogue start */
 1001               	.LBE37:
 834:quantum/quantum.c **** 
 1002               		.loc 1 834 0
 1003 0068 DF91      		pop r29
 1004 006a CF91      		pop r28
 1005 006c 1F91      		pop r17
 1006 006e 0F91      		pop r16
 1007               	.LVL124:
 1008 0070 FF90      		pop r15
 1009               	.LVL125:
 1010 0072 0895      		ret
 1011               		.cfi_endproc
 1012               	.LFE37:
 1014               		.section	.text.send_string_P,"ax",@progbits
 1015               	.global	send_string_P
 1017               	send_string_P:
 1018               	.LFB35:
 776:quantum/quantum.c **** 
 1019               		.loc 1 776 0
 1020               		.cfi_startproc
 1021               	.LVL126:
 1022               	/* prologue: function */
 1023               	/* frame size = 0 */
 1024               	/* stack size = 0 */
 1025               	.L__stack_usage = 0
 776:quantum/quantum.c **** 
 1026               		.loc 1 776 0
 1027 0000 60E0      		ldi r22,0
 1028 0002 0C94 0000 		jmp send_string_with_delay_P
 1029               	.LVL127:
 1030               		.cfi_endproc
 1031               	.LFE35:
 1033               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1034               	.global	set_single_persistent_default_layer
 1036               	set_single_persistent_default_layer:
 1037               	.LFB39:
 855:quantum/quantum.c **** 
 856:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1038               		.loc 1 856 0
 1039               		.cfi_startproc
 1040               	.LVL128:
 1041 0000 CF93      		push r28
 1042               	.LCFI28:
 1043               		.cfi_def_cfa_offset 3
 1044               		.cfi_offset 28, -2
 1045 0002 DF93      		push r29
 1046               	.LCFI29:
 1047               		.cfi_def_cfa_offset 4
 1048               		.cfi_offset 29, -3
 1049               	/* prologue: function */
 1050               	/* frame size = 0 */
 1051               	/* stack size = 2 */
 1052               	.L__stack_usage = 2
 857:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 858:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 859:quantum/quantum.c **** #endif
 860:quantum/quantum.c ****     eeconfig_update_default_layer(1U << default_layer);
 1053               		.loc 1 860 0
 1054 0004 C1E0      		ldi r28,lo8(1)
 1055 0006 D0E0      		ldi r29,0
 1056 0008 00C0      		rjmp 2f
 1057               		1:
 1058 000a CC0F      		lsl r28
 1059 000c DD1F      		rol r29
 1060               		2:
 1061 000e 8A95      		dec r24
 1062 0010 02F4      		brpl 1b
 1063 0012 8C2F      		mov r24,r28
 1064               	.LVL129:
 1065 0014 0E94 0000 		call eeconfig_update_default_layer
 1066               	.LVL130:
 861:quantum/quantum.c ****     default_layer_set(1U << default_layer);
 1067               		.loc 1 861 0
 1068 0018 BE01      		movw r22,r28
 1069 001a 90E0      		ldi r25,0
 1070 001c 80E0      		ldi r24,0
 1071               	/* epilogue start */
 862:quantum/quantum.c **** }
 1072               		.loc 1 862 0
 1073 001e DF91      		pop r29
 1074 0020 CF91      		pop r28
 861:quantum/quantum.c ****     default_layer_set(1U << default_layer);
 1075               		.loc 1 861 0
 1076 0022 0C94 0000 		jmp default_layer_set
 1077               	.LVL131:
 1078               		.cfi_endproc
 1079               	.LFE39:
 1081               		.section	.text.update_tri_layer_state,"ax",@progbits
 1082               	.global	update_tri_layer_state
 1084               	update_tri_layer_state:
 1085               	.LFB40:
 863:quantum/quantum.c **** 
 864:quantum/quantum.c **** layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t l
 1086               		.loc 1 864 0
 1087               		.cfi_startproc
 1088               	.LVL132:
 1089 0000 8F92      		push r8
 1090               	.LCFI30:
 1091               		.cfi_def_cfa_offset 3
 1092               		.cfi_offset 8, -2
 1093 0002 9F92      		push r9
 1094               	.LCFI31:
 1095               		.cfi_def_cfa_offset 4
 1096               		.cfi_offset 9, -3
 1097 0004 AF92      		push r10
 1098               	.LCFI32:
 1099               		.cfi_def_cfa_offset 5
 1100               		.cfi_offset 10, -4
 1101 0006 BF92      		push r11
 1102               	.LCFI33:
 1103               		.cfi_def_cfa_offset 6
 1104               		.cfi_offset 11, -5
 1105 0008 CF92      		push r12
 1106               	.LCFI34:
 1107               		.cfi_def_cfa_offset 7
 1108               		.cfi_offset 12, -6
 1109 000a DF92      		push r13
 1110               	.LCFI35:
 1111               		.cfi_def_cfa_offset 8
 1112               		.cfi_offset 13, -7
 1113 000c EF92      		push r14
 1114               	.LCFI36:
 1115               		.cfi_def_cfa_offset 9
 1116               		.cfi_offset 14, -8
 1117 000e FF92      		push r15
 1118               	.LCFI37:
 1119               		.cfi_def_cfa_offset 10
 1120               		.cfi_offset 15, -9
 1121 0010 0F93      		push r16
 1122               	.LCFI38:
 1123               		.cfi_def_cfa_offset 11
 1124               		.cfi_offset 16, -10
 1125 0012 1F93      		push r17
 1126               	.LCFI39:
 1127               		.cfi_def_cfa_offset 12
 1128               		.cfi_offset 17, -11
 1129               	/* prologue: function */
 1130               	/* frame size = 0 */
 1131               	/* stack size = 10 */
 1132               	.L__stack_usage = 10
 1133 0014 6B01      		movw r12,r22
 1134 0016 7C01      		movw r14,r24
 865:quantum/quantum.c ****     layer_state_t mask12 = (1UL << layer1) | (1UL << layer2);
 1135               		.loc 1 865 0
 1136 0018 81E0      		ldi r24,lo8(1)
 1137 001a 90E0      		ldi r25,0
 1138 001c A0E0      		ldi r26,0
 1139 001e B0E0      		ldi r27,0
 1140 0020 4C01      		movw r8,r24
 1141 0022 5D01      		movw r10,r26
 1142 0024 00C0      		rjmp 2f
 1143               		1:
 1144 0026 880C      		lsl r8
 1145 0028 991C      		rol r9
 1146 002a AA1C      		rol r10
 1147 002c BB1C      		rol r11
 1148               		2:
 1149 002e 4A95      		dec r20
 1150 0030 02F4      		brpl 1b
 1151 0032 B501      		movw r22,r10
 1152               	.LVL133:
 1153 0034 A401      		movw r20,r8
 1154               	.LVL134:
 1155 0036 4C01      		movw r8,r24
 1156 0038 5D01      		movw r10,r26
 1157 003a 00C0      		rjmp 2f
 1158               		1:
 1159 003c 880C      		lsl r8
 1160 003e 991C      		rol r9
 1161 0040 AA1C      		rol r10
 1162 0042 BB1C      		rol r11
 1163               		2:
 1164 0044 2A95      		dec r18
 1165 0046 02F4      		brpl 1b
 1166 0048 4829      		or r20,r8
 1167 004a 5929      		or r21,r9
 1168 004c 6A29      		or r22,r10
 1169 004e 7B29      		or r23,r11
 1170               	.LVL135:
 866:quantum/quantum.c ****     layer_state_t mask3  = 1UL << layer3;
 1171               		.loc 1 866 0
 1172 0050 00C0      		rjmp 2f
 1173               		1:
 1174 0052 880F      		lsl r24
 1175 0054 991F      		rol r25
 1176 0056 AA1F      		rol r26
 1177 0058 BB1F      		rol r27
 1178               		2:
 1179 005a 0A95      		dec r16
 1180 005c 02F4      		brpl 1b
 1181               	.LVL136:
 867:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1182               		.loc 1 867 0
 1183 005e 8A01      		movw r16,r20
 1184               	.LVL137:
 1185 0060 9B01      		movw r18,r22
 1186               	.LVL138:
 1187 0062 0C21      		and r16,r12
 1188 0064 1D21      		and r17,r13
 1189 0066 2E21      		and r18,r14
 1190 0068 3F21      		and r19,r15
 1191 006a 0417      		cp r16,r20
 1192 006c 1507      		cpc r17,r21
 1193 006e 2607      		cpc r18,r22
 1194 0070 3707      		cpc r19,r23
 1195 0072 01F4      		brne .L83
 1196               		.loc 1 867 0 is_stmt 0 discriminator 1
 1197 0074 8C29      		or r24,r12
 1198               	.LVL139:
 1199 0076 9D29      		or r25,r13
 1200 0078 AE29      		or r26,r14
 1201 007a BF29      		or r27,r15
 1202               	.L82:
 868:quantum/quantum.c **** }
 1203               		.loc 1 868 0 is_stmt 1
 1204 007c BC01      		movw r22,r24
 1205 007e CD01      		movw r24,r26
 1206               	/* epilogue start */
 1207 0080 1F91      		pop r17
 1208               	.LVL140:
 1209 0082 0F91      		pop r16
 1210               	.LVL141:
 1211 0084 FF90      		pop r15
 1212 0086 EF90      		pop r14
 1213 0088 DF90      		pop r13
 1214 008a CF90      		pop r12
 1215 008c BF90      		pop r11
 1216 008e AF90      		pop r10
 1217 0090 9F90      		pop r9
 1218 0092 8F90      		pop r8
 1219               	.LVL142:
 1220 0094 0895      		ret
 1221               	.LVL143:
 1222               	.L83:
 867:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1223               		.loc 1 867 0 discriminator 2
 1224 0096 8095      		com r24
 1225 0098 9095      		com r25
 1226 009a A095      		com r26
 1227 009c B095      		com r27
 1228               	.LVL144:
 1229 009e 8C21      		and r24,r12
 1230               	.LVL145:
 1231 00a0 9D21      		and r25,r13
 1232 00a2 AE21      		and r26,r14
 1233 00a4 BF21      		and r27,r15
 1234 00a6 00C0      		rjmp .L82
 1235               		.cfi_endproc
 1236               	.LFE40:
 1238               		.section	.text.update_tri_layer,"ax",@progbits
 1239               	.global	update_tri_layer
 1241               	update_tri_layer:
 1242               	.LFB41:
 869:quantum/quantum.c **** 
 870:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) { layer_state_set(update_tri_
 1243               		.loc 1 870 0
 1244               		.cfi_startproc
 1245               	.LVL146:
 1246 0000 0F93      		push r16
 1247               	.LCFI40:
 1248               		.cfi_def_cfa_offset 3
 1249               		.cfi_offset 16, -2
 1250               	/* prologue: function */
 1251               	/* frame size = 0 */
 1252               	/* stack size = 1 */
 1253               	.L__stack_usage = 1
 1254 0002 382F      		mov r19,r24
 1255 0004 262F      		mov r18,r22
 1256               		.loc 1 870 0
 1257 0006 6091 0000 		lds r22,layer_state
 1258 000a 7091 0000 		lds r23,layer_state+1
 1259 000e 8091 0000 		lds r24,layer_state+2
 1260 0012 9091 0000 		lds r25,layer_state+3
 1261               	.LVL147:
 1262 0016 042F      		mov r16,r20
 1263 0018 432F      		mov r20,r19
 1264               	.LVL148:
 1265 001a 0E94 0000 		call update_tri_layer_state
 1266               	.LVL149:
 1267               	/* epilogue start */
 1268 001e 0F91      		pop r16
 1269               	.LVL150:
 1270 0020 0C94 0000 		jmp layer_state_set
 1271               	.LVL151:
 1272               		.cfi_endproc
 1273               	.LFE41:
 1275               		.section	.text.tap_random_base64,"ax",@progbits
 1276               	.global	tap_random_base64
 1278               	tap_random_base64:
 1279               	.LFB42:
 871:quantum/quantum.c **** 
 872:quantum/quantum.c **** void tap_random_base64(void) {
 1280               		.loc 1 872 0
 1281               		.cfi_startproc
 1282 0000 CF93      		push r28
 1283               	.LCFI41:
 1284               		.cfi_def_cfa_offset 3
 1285               		.cfi_offset 28, -2
 1286 0002 DF93      		push r29
 1287               	.LCFI42:
 1288               		.cfi_def_cfa_offset 4
 1289               		.cfi_offset 29, -3
 1290               	/* prologue: function */
 1291               	/* frame size = 0 */
 1292               	/* stack size = 2 */
 1293               	.L__stack_usage = 2
 873:quantum/quantum.c **** #if defined(__AVR_ATmega32U4__)
 874:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1294               		.loc 1 874 0
 1295 0004 46B5      		in r20,0x26
 1296 0006 2091 8400 		lds r18,132
 1297 000a 3091 8500 		lds r19,132+1
 1298 000e C091 9400 		lds r28,148
 1299 0012 D091 9500 		lds r29,148+1
 1300 0016 8091 BE00 		lds r24,190
 1301 001a 9091 BF00 		lds r25,190+1
 1302 001e C20F      		add r28,r18
 1303 0020 C40F      		add r28,r20
 1304 0022 C80F      		add r28,r24
 1305 0024 CF73      		andi r28,lo8(63)
 1306               	.LVL152:
 875:quantum/quantum.c **** #else
 876:quantum/quantum.c ****     uint8_t key = rand() % 64;
 877:quantum/quantum.c **** #endif
 878:quantum/quantum.c ****     switch (key) {
 1307               		.loc 1 878 0
 1308 0026 CE33      		cpi r28,lo8(62)
 1309 0028 00F4      		brsh .L88
 1310 002a C533      		cpi r28,lo8(53)
 1311 002c 00F4      		brsh .L89
 1312 002e CA31      		cpi r28,lo8(26)
 1313 0030 00F0      		brlo .L87
 1314 0032 C433      		cpi r28,lo8(52)
 1315 0034 00F4      		brsh .L94
 879:quantum/quantum.c ****         case 0 ... 25:
 880:quantum/quantum.c ****             register_code(KC_LSFT);
 881:quantum/quantum.c ****             register_code(key + KC_A);
 882:quantum/quantum.c ****             unregister_code(key + KC_A);
 883:quantum/quantum.c ****             unregister_code(KC_LSFT);
 884:quantum/quantum.c ****             break;
 885:quantum/quantum.c ****         case 26 ... 51:
 886:quantum/quantum.c ****             register_code(key - 26 + KC_A);
 1316               		.loc 1 886 0
 1317 0036 C651      		subi r28,lo8(-(-22))
 1318               	.LVL153:
 1319               	.L97:
 887:quantum/quantum.c ****             unregister_code(key - 26 + KC_A);
 888:quantum/quantum.c ****             break;
 889:quantum/quantum.c ****         case 52:
 890:quantum/quantum.c ****             register_code(KC_0);
 891:quantum/quantum.c ****             unregister_code(KC_0);
 892:quantum/quantum.c ****             break;
 893:quantum/quantum.c ****         case 53 ... 61:
 894:quantum/quantum.c ****             register_code(key - 53 + KC_1);
 1320               		.loc 1 894 0
 1321 0038 8C2F      		mov r24,r28
 1322 003a 0E94 0000 		call register_code
 1323               	.LVL154:
 895:quantum/quantum.c ****             unregister_code(key - 53 + KC_1);
 1324               		.loc 1 895 0
 1325 003e 8C2F      		mov r24,r28
 1326 0040 00C0      		rjmp .L95
 1327               	.LVL155:
 1328               	.L88:
 878:quantum/quantum.c ****         case 0 ... 25:
 1329               		.loc 1 878 0
 1330 0042 CE33      		cpi r28,lo8(62)
 1331 0044 01F0      		breq .L92
 1332 0046 CF33      		cpi r28,lo8(63)
 1333 0048 01F0      		breq .L93
 1334               	.L87:
 880:quantum/quantum.c ****             register_code(key + KC_A);
 1335               		.loc 1 880 0
 1336 004a 81EE      		ldi r24,lo8(-31)
 1337 004c 0E94 0000 		call register_code
 1338               	.LVL156:
 881:quantum/quantum.c ****             unregister_code(key + KC_A);
 1339               		.loc 1 881 0
 1340 0050 CC5F      		subi r28,lo8(-(4))
 1341               	.LVL157:
 1342 0052 8C2F      		mov r24,r28
 1343 0054 0E94 0000 		call register_code
 1344               	.LVL158:
 882:quantum/quantum.c ****             unregister_code(KC_LSFT);
 1345               		.loc 1 882 0
 1346 0058 8C2F      		mov r24,r28
 1347               	.LVL159:
 1348               	.L96:
 896:quantum/quantum.c ****             break;
 897:quantum/quantum.c ****         case 62:
 898:quantum/quantum.c ****             register_code(KC_LSFT);
 899:quantum/quantum.c ****             register_code(KC_EQL);
 900:quantum/quantum.c ****             unregister_code(KC_EQL);
 1349               		.loc 1 900 0
 1350 005a 0E94 0000 		call unregister_code
 1351               	.LVL160:
 901:quantum/quantum.c ****             unregister_code(KC_LSFT);
 1352               		.loc 1 901 0
 1353 005e 81EE      		ldi r24,lo8(-31)
 1354 0060 00C0      		rjmp .L95
 1355               	.LVL161:
 1356               	.L94:
 890:quantum/quantum.c ****             unregister_code(KC_0);
 1357               		.loc 1 890 0
 1358 0062 87E2      		ldi r24,lo8(39)
 1359 0064 0E94 0000 		call register_code
 1360               	.LVL162:
 891:quantum/quantum.c ****             break;
 1361               		.loc 1 891 0
 1362 0068 87E2      		ldi r24,lo8(39)
 1363               	.LVL163:
 1364               	.L95:
 1365               	/* epilogue start */
 902:quantum/quantum.c ****             break;
 903:quantum/quantum.c ****         case 63:
 904:quantum/quantum.c ****             register_code(KC_SLSH);
 905:quantum/quantum.c ****             unregister_code(KC_SLSH);
 906:quantum/quantum.c ****             break;
 907:quantum/quantum.c ****     }
 908:quantum/quantum.c **** }
 1366               		.loc 1 908 0
 1367 006a DF91      		pop r29
 1368 006c CF91      		pop r28
 905:quantum/quantum.c ****             break;
 1369               		.loc 1 905 0
 1370 006e 0C94 0000 		jmp unregister_code
 1371               	.LVL164:
 1372               	.L89:
 894:quantum/quantum.c ****             unregister_code(key - 53 + KC_1);
 1373               		.loc 1 894 0
 1374 0072 C751      		subi r28,lo8(-(-23))
 1375               	.LVL165:
 1376 0074 00C0      		rjmp .L97
 1377               	.LVL166:
 1378               	.L92:
 898:quantum/quantum.c ****             register_code(KC_EQL);
 1379               		.loc 1 898 0
 1380 0076 81EE      		ldi r24,lo8(-31)
 1381 0078 0E94 0000 		call register_code
 1382               	.LVL167:
 899:quantum/quantum.c ****             unregister_code(KC_EQL);
 1383               		.loc 1 899 0
 1384 007c 8EE2      		ldi r24,lo8(46)
 1385 007e 0E94 0000 		call register_code
 1386               	.LVL168:
 900:quantum/quantum.c ****             unregister_code(KC_LSFT);
 1387               		.loc 1 900 0
 1388 0082 8EE2      		ldi r24,lo8(46)
 1389 0084 00C0      		rjmp .L96
 1390               	.L93:
 904:quantum/quantum.c ****             unregister_code(KC_SLSH);
 1391               		.loc 1 904 0
 1392 0086 88E3      		ldi r24,lo8(56)
 1393 0088 0E94 0000 		call register_code
 1394               	.LVL169:
 905:quantum/quantum.c ****             break;
 1395               		.loc 1 905 0
 1396 008c 88E3      		ldi r24,lo8(56)
 1397 008e 00C0      		rjmp .L95
 1398               		.cfi_endproc
 1399               	.LFE42:
 1401               		.section	.text.bootmagic_lite,"ax",@progbits
 1402               		.weak	bootmagic_lite
 1404               	bootmagic_lite:
 1405               	.LFB43:
 909:quantum/quantum.c **** 
 910:quantum/quantum.c **** __attribute__((weak)) void bootmagic_lite(void) {
 1406               		.loc 1 910 0
 1407               		.cfi_startproc
 1408               	/* prologue: function */
 1409               	/* frame size = 0 */
 1410               	/* stack size = 0 */
 1411               	.L__stack_usage = 0
 911:quantum/quantum.c ****     // The lite version of TMK's bootmagic based on Wilba.
 912:quantum/quantum.c ****     // 100% less potential for accidentally making the
 913:quantum/quantum.c ****     // keyboard do stupid things.
 914:quantum/quantum.c **** 
 915:quantum/quantum.c ****     // We need multiple scans because debouncing can't be turned off.
 916:quantum/quantum.c ****     matrix_scan();
 1412               		.loc 1 916 0
 1413 0000 0E94 0000 		call matrix_scan
 1414               	.LVL170:
 1415               	.LBB49:
 1416               	.LBB50:
 1417               		.loc 2 187 0
 1418 0004 8FE3      		ldi r24,lo8(-25537)
 1419 0006 9CE9      		ldi r25,hi8(-25537)
 1420 0008 0197      	1:	sbiw r24,1
 1421 000a 01F4      		brne 1b
 1422 000c 00C0      		rjmp .
 1423 000e 0000      		nop
 1424               	.LVL171:
 1425               	.LBE50:
 1426               	.LBE49:
 917:quantum/quantum.c **** #if defined(DEBOUNCING_DELAY) && DEBOUNCING_DELAY > 0
 918:quantum/quantum.c ****     wait_ms(DEBOUNCING_DELAY * 2);
 919:quantum/quantum.c **** #elif defined(DEBOUNCE) && DEBOUNCE > 0
 920:quantum/quantum.c ****     wait_ms(DEBOUNCE * 2);
 921:quantum/quantum.c **** #else
 922:quantum/quantum.c ****     wait_ms(30);
 923:quantum/quantum.c **** #endif
 924:quantum/quantum.c ****     matrix_scan();
 1427               		.loc 1 924 0
 1428 0010 0E94 0000 		call matrix_scan
 1429               	.LVL172:
 925:quantum/quantum.c **** 
 926:quantum/quantum.c ****     // If the Esc and space bar are held down on power up,
 927:quantum/quantum.c ****     // reset the EEPROM valid state and jump to bootloader.
 928:quantum/quantum.c ****     // Assumes Esc is at [0,0].
 929:quantum/quantum.c ****     // This isn't very generalized, but we need something that doesn't
 930:quantum/quantum.c ****     // rely on user's keymaps in firmware or EEPROM.
 931:quantum/quantum.c ****     if (matrix_get_row(BOOTMAGIC_LITE_ROW) & (1 << BOOTMAGIC_LITE_COLUMN)) {
 1430               		.loc 1 931 0
 1431 0014 80E0      		ldi r24,0
 1432 0016 0E94 0000 		call matrix_get_row
 1433               	.LVL173:
 1434 001a 80FF      		sbrs r24,0
 1435 001c 00C0      		rjmp .L98
 932:quantum/quantum.c ****         eeconfig_disable();
 1436               		.loc 1 932 0
 1437 001e 0E94 0000 		call eeconfig_disable
 1438               	.LVL174:
 933:quantum/quantum.c ****         // Jump to bootloader.
 934:quantum/quantum.c ****         bootloader_jump();
 1439               		.loc 1 934 0
 1440 0022 0C94 0000 		jmp bootloader_jump
 1441               	.LVL175:
 1442               	.L98:
 1443               	/* epilogue start */
 935:quantum/quantum.c ****     }
 936:quantum/quantum.c **** }
 1444               		.loc 1 936 0
 1445 0026 0895      		ret
 1446               		.cfi_endproc
 1447               	.LFE43:
 1449               		.section	.text.matrix_init_quantum,"ax",@progbits
 1450               	.global	matrix_init_quantum
 1452               	matrix_init_quantum:
 1453               	.LFB44:
 937:quantum/quantum.c **** 
 938:quantum/quantum.c **** void matrix_init_quantum() {
 1454               		.loc 1 938 0
 1455               		.cfi_startproc
 1456               	/* prologue: function */
 1457               	/* frame size = 0 */
 1458               	/* stack size = 0 */
 1459               	.L__stack_usage = 0
 939:quantum/quantum.c **** #ifdef BOOTMAGIC_LITE
 940:quantum/quantum.c ****     bootmagic_lite();
 941:quantum/quantum.c **** #endif
 942:quantum/quantum.c ****     if (!eeconfig_is_enabled()) {
 1460               		.loc 1 942 0
 1461 0000 0E94 0000 		call eeconfig_is_enabled
 1462               	.LVL176:
 1463 0004 8111      		cpse r24,__zero_reg__
 1464 0006 00C0      		rjmp .L101
 943:quantum/quantum.c ****         eeconfig_init();
 1465               		.loc 1 943 0
 1466 0008 0E94 0000 		call eeconfig_init
 1467               	.LVL177:
 1468               	.L101:
 944:quantum/quantum.c ****     }
 945:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
 946:quantum/quantum.c **** #    ifdef LED_MATRIX_ENABLE
 947:quantum/quantum.c ****     led_matrix_init();
 948:quantum/quantum.c **** #    else
 949:quantum/quantum.c ****     backlight_init_ports();
 950:quantum/quantum.c **** #    endif
 951:quantum/quantum.c **** #endif
 952:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 953:quantum/quantum.c ****     audio_init();
 954:quantum/quantum.c **** #endif
 955:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 956:quantum/quantum.c ****     rgb_matrix_init();
 957:quantum/quantum.c **** #endif
 958:quantum/quantum.c **** #ifdef ENCODER_ENABLE
 959:quantum/quantum.c ****     encoder_init();
 960:quantum/quantum.c **** #endif
 961:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 962:quantum/quantum.c ****     unicode_input_mode_init();
 963:quantum/quantum.c **** #endif
 964:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 965:quantum/quantum.c ****     haptic_init();
 966:quantum/quantum.c **** #endif
 967:quantum/quantum.c **** #ifdef OUTPUT_AUTO_ENABLE
 968:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 969:quantum/quantum.c **** #endif
 970:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
 971:quantum/quantum.c ****     dip_switch_init();
 972:quantum/quantum.c **** #endif
 973:quantum/quantum.c **** 
 974:quantum/quantum.c ****     matrix_init_kb();
 1469               		.loc 1 974 0
 1470 000c 0C94 0000 		jmp matrix_init_kb
 1471               	.LVL178:
 1472               		.cfi_endproc
 1473               	.LFE44:
 1475               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1476               	.global	matrix_scan_quantum
 1478               	matrix_scan_quantum:
 1479               	.LFB45:
 975:quantum/quantum.c **** }
 976:quantum/quantum.c **** 
 977:quantum/quantum.c **** void matrix_scan_quantum() {
 1480               		.loc 1 977 0
 1481               		.cfi_startproc
 1482               	/* prologue: function */
 1483               	/* frame size = 0 */
 1484               	/* stack size = 0 */
 1485               	.L__stack_usage = 0
 978:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 979:quantum/quantum.c ****     matrix_scan_music();
 980:quantum/quantum.c **** #endif
 981:quantum/quantum.c **** 
 982:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 983:quantum/quantum.c ****     matrix_scan_tap_dance();
 984:quantum/quantum.c **** #endif
 985:quantum/quantum.c **** 
 986:quantum/quantum.c **** #ifdef COMBO_ENABLE
 987:quantum/quantum.c ****     matrix_scan_combo();
 988:quantum/quantum.c **** #endif
 989:quantum/quantum.c **** 
 990:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE)
 991:quantum/quantum.c **** #    if defined(LED_MATRIX_ENABLE)
 992:quantum/quantum.c ****     led_matrix_task();
 993:quantum/quantum.c **** #    elif defined(BACKLIGHT_PIN)
 994:quantum/quantum.c ****     backlight_task();
 995:quantum/quantum.c **** #    endif
 996:quantum/quantum.c **** #endif
 997:quantum/quantum.c **** 
 998:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 999:quantum/quantum.c ****     rgb_matrix_task();
1000:quantum/quantum.c **** #endif
1001:quantum/quantum.c **** 
1002:quantum/quantum.c **** #ifdef ENCODER_ENABLE
1003:quantum/quantum.c ****     encoder_read();
1004:quantum/quantum.c **** #endif
1005:quantum/quantum.c **** 
1006:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
1007:quantum/quantum.c ****     haptic_task();
1008:quantum/quantum.c **** #endif
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
1011:quantum/quantum.c ****     dip_switch_read(false);
1012:quantum/quantum.c **** #endif
1013:quantum/quantum.c **** 
1014:quantum/quantum.c ****     matrix_scan_kb();
 1486               		.loc 1 1014 0
 1487 0000 0C94 0000 		jmp matrix_scan_kb
 1488               	.LVL179:
 1489               		.cfi_endproc
 1490               	.LFE45:
 1492               		.section	.text.backlight_init_ports,"ax",@progbits
 1493               		.weak	backlight_init_ports
 1495               	backlight_init_ports:
 1496               	.LFB65:
 1497               		.cfi_startproc
 1498               	/* prologue: function */
 1499               	/* frame size = 0 */
 1500               	/* stack size = 0 */
 1501               	.L__stack_usage = 0
 1502               	/* epilogue start */
 1503 0000 0895      		ret
 1504               		.cfi_endproc
 1505               	.LFE65:
 1507               		.section	.text.send_nibble,"ax",@progbits
 1508               	.global	send_nibble
 1510               	send_nibble:
 1511               	.LFB51:
1015:quantum/quantum.c **** }
1016:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && (defined(BACKLIGHT_PIN) || defined(BACKLIGHT_PINS))
1017:quantum/quantum.c **** 
1018:quantum/quantum.c **** // This logic is a bit complex, we support 3 setups:
1019:quantum/quantum.c **** //
1020:quantum/quantum.c **** //   1. Hardware PWM when backlight is wired to a PWM pin.
1021:quantum/quantum.c **** //      Depending on this pin, we use a different output compare unit.
1022:quantum/quantum.c **** //   2. Software PWM with hardware timers, but the used timer
1023:quantum/quantum.c **** //      depends on the Audio setup (Audio wins over Backlight).
1024:quantum/quantum.c **** //   3. Full software PWM, driven by the matrix scan, if both timers are used by Audio.
1025:quantum/quantum.c **** 
1026:quantum/quantum.c **** #    if (defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) || defined(__AVR_AT90USB1286__)
1027:quantum/quantum.c **** #        define HARDWARE_PWM
1028:quantum/quantum.c **** #        define ICRx ICR1
1029:quantum/quantum.c **** #        define TCCRxA TCCR1A
1030:quantum/quantum.c **** #        define TCCRxB TCCR1B
1031:quantum/quantum.c **** #        define TIMERx_OVF_vect TIMER1_OVF_vect
1032:quantum/quantum.c **** #        define TIMSKx TIMSK1
1033:quantum/quantum.c **** #        define TOIEx TOIE1
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** #        if BACKLIGHT_PIN == B5
1036:quantum/quantum.c **** #            define COMxx1 COM1A1
1037:quantum/quantum.c **** #            define OCRxx OCR1A
1038:quantum/quantum.c **** #        elif BACKLIGHT_PIN == B6
1039:quantum/quantum.c **** #            define COMxx1 COM1B1
1040:quantum/quantum.c **** #            define OCRxx OCR1B
1041:quantum/quantum.c **** #        elif BACKLIGHT_PIN == B7
1042:quantum/quantum.c **** #            define COMxx1 COM1C1
1043:quantum/quantum.c **** #            define OCRxx OCR1C
1044:quantum/quantum.c **** #        endif
1045:quantum/quantum.c **** #    elif (defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) || defined(__AVR_AT90USB1286_
1046:quantum/quantum.c **** #        define HARDWARE_PWM
1047:quantum/quantum.c **** #        define ICRx ICR3
1048:quantum/quantum.c **** #        define TCCRxA TCCR3A
1049:quantum/quantum.c **** #        define TCCRxB TCCR3B
1050:quantum/quantum.c **** #        define TIMERx_OVF_vect TIMER3_OVF_vect
1051:quantum/quantum.c **** #        define TIMSKx TIMSK3
1052:quantum/quantum.c **** #        define TOIEx TOIE3
1053:quantum/quantum.c **** 
1054:quantum/quantum.c **** #        if BACKLIGHT_PIN == C4
1055:quantum/quantum.c **** #            if (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
1056:quantum/quantum.c **** #                error This MCU has no C4 pin!
1057:quantum/quantum.c **** #            else
1058:quantum/quantum.c **** #                define COMxx1 COM3C1
1059:quantum/quantum.c **** #                define OCRxx OCR3C
1060:quantum/quantum.c **** #            endif
1061:quantum/quantum.c **** #        elif BACKLIGHT_PIN == C5
1062:quantum/quantum.c **** #            if (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
1063:quantum/quantum.c **** #                error This MCU has no C5 pin!
1064:quantum/quantum.c **** #            else
1065:quantum/quantum.c **** #                define COMxx1 COM3B1
1066:quantum/quantum.c **** #                define OCRxx OCR3B
1067:quantum/quantum.c **** #            endif
1068:quantum/quantum.c **** #        elif BACKLIGHT_PIN == C6
1069:quantum/quantum.c **** #            define COMxx1 COM3A1
1070:quantum/quantum.c **** #            define OCRxx OCR3A
1071:quantum/quantum.c **** #        endif
1072:quantum/quantum.c **** #    elif (defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__)) && (BACKLIGHT_PIN == B7 || B
1073:quantum/quantum.c **** #        define HARDWARE_PWM
1074:quantum/quantum.c **** #        define ICRx ICR1
1075:quantum/quantum.c **** #        define TCCRxA TCCR1A
1076:quantum/quantum.c **** #        define TCCRxB TCCR1B
1077:quantum/quantum.c **** #        define TIMERx_OVF_vect TIMER1_OVF_vect
1078:quantum/quantum.c **** #        define TIMSKx TIMSK1
1079:quantum/quantum.c **** #        define TOIEx TOIE1
1080:quantum/quantum.c **** 
1081:quantum/quantum.c **** #        if BACKLIGHT_PIN == B7
1082:quantum/quantum.c **** #            define COMxx1 COM1C1
1083:quantum/quantum.c **** #            define OCRxx OCR1C
1084:quantum/quantum.c **** #        elif BACKLIGHT_PIN == C5
1085:quantum/quantum.c **** #            define COMxx1 COM1B1
1086:quantum/quantum.c **** #            define OCRxx OCR1B
1087:quantum/quantum.c **** #        elif BACKLIGHT_PIN == C6
1088:quantum/quantum.c **** #            define COMxx1 COM1A1
1089:quantum/quantum.c **** #            define OCRxx OCR1A
1090:quantum/quantum.c **** #        endif
1091:quantum/quantum.c **** #    elif defined(__AVR_ATmega32A__) && (BACKLIGHT_PIN == D4 || BACKLIGHT_PIN == D5)
1092:quantum/quantum.c **** #        define HARDWARE_PWM
1093:quantum/quantum.c **** #        define ICRx ICR1
1094:quantum/quantum.c **** #        define TCCRxA TCCR1A
1095:quantum/quantum.c **** #        define TCCRxB TCCR1B
1096:quantum/quantum.c **** #        define TIMERx_OVF_vect TIMER1_OVF_vect
1097:quantum/quantum.c **** #        define TIMSKx TIMSK
1098:quantum/quantum.c **** #        define TOIEx TOIE1
1099:quantum/quantum.c **** 
1100:quantum/quantum.c **** #        if BACKLIGHT_PIN == D4
1101:quantum/quantum.c **** #            define COMxx1 COM1B1
1102:quantum/quantum.c **** #            define OCRxx OCR1B
1103:quantum/quantum.c **** #        elif BACKLIGHT_PIN == D5
1104:quantum/quantum.c **** #            define COMxx1 COM1A1
1105:quantum/quantum.c **** #            define OCRxx OCR1A
1106:quantum/quantum.c **** #        endif
1107:quantum/quantum.c **** #    elif defined(__AVR_ATmega328P__) && (BACKLIGHT_PIN == B1 || BACKLIGHT_PIN == B2)
1108:quantum/quantum.c **** #        define HARDWARE_PWM
1109:quantum/quantum.c **** #        define ICRx ICR1
1110:quantum/quantum.c **** #        define TCCRxA TCCR1A
1111:quantum/quantum.c **** #        define TCCRxB TCCR1B
1112:quantum/quantum.c **** #        define TIMERx_OVF_vect TIMER1_OVF_vect
1113:quantum/quantum.c **** #        define TIMSKx TIMSK1
1114:quantum/quantum.c **** #        define TOIEx TOIE1
1115:quantum/quantum.c **** 
1116:quantum/quantum.c **** #        if BACKLIGHT_PIN == B1
1117:quantum/quantum.c **** #            define COMxx1 COM1A1
1118:quantum/quantum.c **** #            define OCRxx OCR1A
1119:quantum/quantum.c **** #        elif BACKLIGHT_PIN == B2
1120:quantum/quantum.c **** #            define COMxx1 COM1B1
1121:quantum/quantum.c **** #            define OCRxx OCR1B
1122:quantum/quantum.c **** #        endif
1123:quantum/quantum.c **** #    else
1124:quantum/quantum.c **** #        if !defined(BACKLIGHT_CUSTOM_DRIVER)
1125:quantum/quantum.c **** #            if !defined(B5_AUDIO) && !defined(B6_AUDIO) && !defined(B7_AUDIO)
1126:quantum/quantum.c **** // Timer 1 is not in use by Audio feature, Backlight can use it
1127:quantum/quantum.c **** #                pragma message "Using hardware timer 1 with software PWM"
1128:quantum/quantum.c **** #                define HARDWARE_PWM
1129:quantum/quantum.c **** #                define BACKLIGHT_PWM_TIMER
1130:quantum/quantum.c **** #                define ICRx ICR1
1131:quantum/quantum.c **** #                define TCCRxA TCCR1A
1132:quantum/quantum.c **** #                define TCCRxB TCCR1B
1133:quantum/quantum.c **** #                define TIMERx_COMPA_vect TIMER1_COMPA_vect
1134:quantum/quantum.c **** #                define TIMERx_OVF_vect TIMER1_OVF_vect
1135:quantum/quantum.c **** #                if defined(__AVR_ATmega32A__)  // This MCU has only one TIMSK register
1136:quantum/quantum.c **** #                    define TIMSKx TIMSK
1137:quantum/quantum.c **** #                else
1138:quantum/quantum.c **** #                    define TIMSKx TIMSK1
1139:quantum/quantum.c **** #                endif
1140:quantum/quantum.c **** #                define TOIEx TOIE1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c **** #                define OCIExA OCIE1A
1143:quantum/quantum.c **** #                define OCRxx OCR1A
1144:quantum/quantum.c **** #            elif !defined(C6_AUDIO) && !defined(C5_AUDIO) && !defined(C4_AUDIO)
1145:quantum/quantum.c **** #                pragma message "Using hardware timer 3 with software PWM"
1146:quantum/quantum.c **** // Timer 3 is not in use by Audio feature, Backlight can use it
1147:quantum/quantum.c **** #                define HARDWARE_PWM
1148:quantum/quantum.c **** #                define BACKLIGHT_PWM_TIMER
1149:quantum/quantum.c **** #                define ICRx ICR1
1150:quantum/quantum.c **** #                define TCCRxA TCCR3A
1151:quantum/quantum.c **** #                define TCCRxB TCCR3B
1152:quantum/quantum.c **** #                define TIMERx_COMPA_vect TIMER3_COMPA_vect
1153:quantum/quantum.c **** #                define TIMERx_OVF_vect TIMER3_OVF_vect
1154:quantum/quantum.c **** #                define TIMSKx TIMSK3
1155:quantum/quantum.c **** #                define TOIEx TOIE3
1156:quantum/quantum.c **** 
1157:quantum/quantum.c **** #                define OCIExA OCIE3A
1158:quantum/quantum.c **** #                define OCRxx OCR3A
1159:quantum/quantum.c **** #            else
1160:quantum/quantum.c **** #                pragma message "Audio in use - using pure software PWM"
1161:quantum/quantum.c **** #                define NO_HARDWARE_PWM
1162:quantum/quantum.c **** #            endif
1163:quantum/quantum.c **** #        else
1164:quantum/quantum.c **** #            pragma message "Custom driver defined - using pure software PWM"
1165:quantum/quantum.c **** #            define NO_HARDWARE_PWM
1166:quantum/quantum.c **** #        endif
1167:quantum/quantum.c **** #    endif
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #    ifndef BACKLIGHT_ON_STATE
1170:quantum/quantum.c **** #        define BACKLIGHT_ON_STATE 0
1171:quantum/quantum.c **** #    endif
1172:quantum/quantum.c **** 
1173:quantum/quantum.c **** void backlight_on(uint8_t backlight_pin) {
1174:quantum/quantum.c **** #    if BACKLIGHT_ON_STATE == 0
1175:quantum/quantum.c ****     writePinLow(backlight_pin);
1176:quantum/quantum.c **** #    else
1177:quantum/quantum.c ****     writePinHigh(backlight_pin);
1178:quantum/quantum.c **** #    endif
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void backlight_off(uint8_t backlight_pin) {
1182:quantum/quantum.c **** #    if BACKLIGHT_ON_STATE == 0
1183:quantum/quantum.c ****     writePinHigh(backlight_pin);
1184:quantum/quantum.c **** #    else
1185:quantum/quantum.c ****     writePinLow(backlight_pin);
1186:quantum/quantum.c **** #    endif
1187:quantum/quantum.c **** }
1188:quantum/quantum.c **** 
1189:quantum/quantum.c **** #    if defined(NO_HARDWARE_PWM) || defined(BACKLIGHT_PWM_TIMER)  // pwm through software
1190:quantum/quantum.c **** 
1191:quantum/quantum.c **** // we support multiple backlight pins
1192:quantum/quantum.c **** #        ifndef BACKLIGHT_LED_COUNT
1193:quantum/quantum.c **** #            define BACKLIGHT_LED_COUNT 1
1194:quantum/quantum.c **** #        endif
1195:quantum/quantum.c **** 
1196:quantum/quantum.c **** #        if BACKLIGHT_LED_COUNT == 1
1197:quantum/quantum.c **** #            define BACKLIGHT_PIN_INIT \
1198:quantum/quantum.c ****                 { BACKLIGHT_PIN }
1199:quantum/quantum.c **** #        else
1200:quantum/quantum.c **** #            define BACKLIGHT_PIN_INIT BACKLIGHT_PINS
1201:quantum/quantum.c **** #        endif
1202:quantum/quantum.c **** 
1203:quantum/quantum.c **** #        define FOR_EACH_LED(x)                                 \
1204:quantum/quantum.c ****             for (uint8_t i = 0; i < BACKLIGHT_LED_COUNT; i++) { \
1205:quantum/quantum.c ****                 uint8_t backlight_pin = backlight_pins[i];      \
1206:quantum/quantum.c ****                 { x }                                           \
1207:quantum/quantum.c ****             }
1208:quantum/quantum.c **** 
1209:quantum/quantum.c **** static const uint8_t backlight_pins[BACKLIGHT_LED_COUNT] = BACKLIGHT_PIN_INIT;
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** #    else  // full hardware PWM
1212:quantum/quantum.c **** 
1213:quantum/quantum.c **** // we support only one backlight pin
1214:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
1215:quantum/quantum.c **** #        define FOR_EACH_LED(x) x
1216:quantum/quantum.c **** 
1217:quantum/quantum.c **** #    endif
1218:quantum/quantum.c **** 
1219:quantum/quantum.c **** #    ifdef NO_HARDWARE_PWM
1220:quantum/quantum.c **** __attribute__((weak)) void backlight_init_ports(void) {
1221:quantum/quantum.c ****     // Setup backlight pin as output and output to on state.
1222:quantum/quantum.c ****     FOR_EACH_LED(setPinOutput(backlight_pin); backlight_on(backlight_pin);)
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** #        ifdef BACKLIGHT_BREATHING
1225:quantum/quantum.c ****     if (is_backlight_breathing()) {
1226:quantum/quantum.c ****         breathing_enable();
1227:quantum/quantum.c ****     }
1228:quantum/quantum.c **** #        endif
1229:quantum/quantum.c **** }
1230:quantum/quantum.c **** 
1231:quantum/quantum.c **** __attribute__((weak)) void backlight_set(uint8_t level) {}
1232:quantum/quantum.c **** 
1233:quantum/quantum.c **** uint8_t backlight_tick = 0;
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** #        ifndef BACKLIGHT_CUSTOM_DRIVER
1236:quantum/quantum.c **** void backlight_task(void) {
1237:quantum/quantum.c ****     if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (
1238:quantum/quantum.c ****         FOR_EACH_LED(backlight_on(backlight_pin);)
1239:quantum/quantum.c ****     } else {
1240:quantum/quantum.c ****         FOR_EACH_LED(backlight_off(backlight_pin);)
1241:quantum/quantum.c ****     }
1242:quantum/quantum.c ****     backlight_tick = (backlight_tick + 1) % 16;
1243:quantum/quantum.c **** }
1244:quantum/quantum.c **** #        endif
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** #        ifdef BACKLIGHT_BREATHING
1247:quantum/quantum.c **** #            ifndef BACKLIGHT_CUSTOM_DRIVER
1248:quantum/quantum.c **** #                error "Backlight breathing only available with hardware PWM. Please disable."
1249:quantum/quantum.c **** #            endif
1250:quantum/quantum.c **** #        endif
1251:quantum/quantum.c **** 
1252:quantum/quantum.c **** #    else  // hardware pwm through timer
1253:quantum/quantum.c **** 
1254:quantum/quantum.c **** #        ifdef BACKLIGHT_PWM_TIMER
1255:quantum/quantum.c **** 
1256:quantum/quantum.c **** // The idea of software PWM assisted by hardware timers is the following
1257:quantum/quantum.c **** // we use the hardware timer in fast PWM mode like for hardware PWM, but
1258:quantum/quantum.c **** // instead of letting the Output Match Comparator control the led pin
1259:quantum/quantum.c **** // (which is not possible since the backlight is not wired to PWM pins on the
1260:quantum/quantum.c **** // CPU), we do the LED on/off by oursleves.
1261:quantum/quantum.c **** // The timer is setup to count up to 0xFFFF, and we set the Output Compare
1262:quantum/quantum.c **** // register to the current 16bits backlight level (after CIE correction).
1263:quantum/quantum.c **** // This means the CPU will trigger a compare match interrupt when the counter
1264:quantum/quantum.c **** // reaches the backlight level, where we turn off the LEDs,
1265:quantum/quantum.c **** // but also an overflow interrupt when the counter rolls back to 0,
1266:quantum/quantum.c **** // in which we're going to turn on the LEDs.
1267:quantum/quantum.c **** // The LED will then be on for OCRxx/0xFFFF time, adjusted every 244Hz.
1268:quantum/quantum.c **** 
1269:quantum/quantum.c **** // Triggered when the counter reaches the OCRx value
1270:quantum/quantum.c **** ISR(TIMERx_COMPA_vect) { FOR_EACH_LED(backlight_off(backlight_pin);) }
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** // Triggered when the counter reaches the TOP value
1273:quantum/quantum.c **** // this one triggers at F_CPU/65536 =~ 244 Hz
1274:quantum/quantum.c **** ISR(TIMERx_OVF_vect) {
1275:quantum/quantum.c **** #            ifdef BACKLIGHT_BREATHING
1276:quantum/quantum.c ****     if (is_breathing()) {
1277:quantum/quantum.c ****         breathing_task();
1278:quantum/quantum.c ****     }
1279:quantum/quantum.c **** #            endif
1280:quantum/quantum.c ****     // for very small values of OCRxx (or backlight level)
1281:quantum/quantum.c ****     // we can't guarantee this whole code won't execute
1282:quantum/quantum.c ****     // at the same time as the compare match interrupt
1283:quantum/quantum.c ****     // which means that we might turn on the leds while
1284:quantum/quantum.c ****     // trying to turn them off, leading to flickering
1285:quantum/quantum.c ****     // artifacts (especially while breathing, because breathing_task
1286:quantum/quantum.c ****     // takes many computation cycles).
1287:quantum/quantum.c ****     // so better not turn them on while the counter TOP is very low.
1288:quantum/quantum.c ****     if (OCRxx > 256) {
1289:quantum/quantum.c ****         FOR_EACH_LED(backlight_on(backlight_pin);)
1290:quantum/quantum.c ****     }
1291:quantum/quantum.c **** }
1292:quantum/quantum.c **** 
1293:quantum/quantum.c **** #        endif
1294:quantum/quantum.c **** 
1295:quantum/quantum.c **** #        define TIMER_TOP 0xFFFFU
1296:quantum/quantum.c **** 
1297:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
1298:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
1299:quantum/quantum.c ****     if (v <= 5243)     // if below 8% of max
1300:quantum/quantum.c ****         return v / 9;  // same as dividing by 900%
1301:quantum/quantum.c ****     else {
1302:quantum/quantum.c ****         uint32_t y = (((uint32_t)v + 10486) << 8) / (10486 + 0xFFFFUL);  // add 16% of max and comp
1303:quantum/quantum.c ****         // to get a useful result with integer division, we shift left in the expression above
1304:quantum/quantum.c ****         // and revert what we've done again after squaring.
1305:quantum/quantum.c ****         y = y * y * y >> 8;
1306:quantum/quantum.c ****         if (y > 0xFFFFUL)  // prevent overflow
1307:quantum/quantum.c ****             return 0xFFFFU;
1308:quantum/quantum.c ****         else
1309:quantum/quantum.c ****             return (uint16_t)y;
1310:quantum/quantum.c ****     }
1311:quantum/quantum.c **** }
1312:quantum/quantum.c **** 
1313:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
1314:quantum/quantum.c **** static inline void set_pwm(uint16_t val) { OCRxx = val; }
1315:quantum/quantum.c **** 
1316:quantum/quantum.c **** #        ifndef BACKLIGHT_CUSTOM_DRIVER
1317:quantum/quantum.c **** __attribute__((weak)) void backlight_set(uint8_t level) {
1318:quantum/quantum.c ****     if (level > BACKLIGHT_LEVELS) level = BACKLIGHT_LEVELS;
1319:quantum/quantum.c **** 
1320:quantum/quantum.c ****     if (level == 0) {
1321:quantum/quantum.c **** #            ifdef BACKLIGHT_PWM_TIMER
1322:quantum/quantum.c ****         if (OCRxx) {
1323:quantum/quantum.c ****             TIMSKx &= ~(_BV(OCIExA));
1324:quantum/quantum.c ****             TIMSKx &= ~(_BV(TOIEx));
1325:quantum/quantum.c ****             FOR_EACH_LED(backlight_off(backlight_pin);)
1326:quantum/quantum.c ****         }
1327:quantum/quantum.c **** #            else
1328:quantum/quantum.c ****         // Turn off PWM control on backlight pin
1329:quantum/quantum.c ****         TCCRxA &= ~(_BV(COMxx1));
1330:quantum/quantum.c **** #            endif
1331:quantum/quantum.c ****     } else {
1332:quantum/quantum.c **** #            ifdef BACKLIGHT_PWM_TIMER
1333:quantum/quantum.c ****         if (!OCRxx) {
1334:quantum/quantum.c ****             TIMSKx |= _BV(OCIExA);
1335:quantum/quantum.c ****             TIMSKx |= _BV(TOIEx);
1336:quantum/quantum.c ****         }
1337:quantum/quantum.c **** #            else
1338:quantum/quantum.c ****         // Turn on PWM control of backlight pin
1339:quantum/quantum.c ****         TCCRxA |= _BV(COMxx1);
1340:quantum/quantum.c **** #            endif
1341:quantum/quantum.c ****     }
1342:quantum/quantum.c ****     // Set the brightness
1343:quantum/quantum.c ****     set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1344:quantum/quantum.c **** }
1345:quantum/quantum.c **** 
1346:quantum/quantum.c **** void backlight_task(void) {}
1347:quantum/quantum.c **** #        endif  // BACKLIGHT_CUSTOM_DRIVER
1348:quantum/quantum.c **** 
1349:quantum/quantum.c **** #        ifdef BACKLIGHT_BREATHING
1350:quantum/quantum.c **** 
1351:quantum/quantum.c **** #            define BREATHING_NO_HALT 0
1352:quantum/quantum.c **** #            define BREATHING_HALT_OFF 1
1353:quantum/quantum.c **** #            define BREATHING_HALT_ON 2
1354:quantum/quantum.c **** #            define BREATHING_STEPS 128
1355:quantum/quantum.c **** 
1356:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1357:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1358:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1359:quantum/quantum.c **** 
1360:quantum/quantum.c **** #            ifdef BACKLIGHT_PWM_TIMER
1361:quantum/quantum.c **** static bool breathing = false;
1362:quantum/quantum.c **** 
1363:quantum/quantum.c **** bool is_breathing(void) { return breathing; }
1364:quantum/quantum.c **** 
1365:quantum/quantum.c **** #                define breathing_interrupt_enable() \
1366:quantum/quantum.c ****                     do {                             \
1367:quantum/quantum.c ****                         breathing = true;            \
1368:quantum/quantum.c ****                     } while (0)
1369:quantum/quantum.c **** #                define breathing_interrupt_disable() \
1370:quantum/quantum.c ****                     do {                              \
1371:quantum/quantum.c ****                         breathing = false;            \
1372:quantum/quantum.c ****                     } while (0)
1373:quantum/quantum.c **** #            else
1374:quantum/quantum.c **** 
1375:quantum/quantum.c **** bool is_breathing(void) { return !!(TIMSKx & _BV(TOIEx)); }
1376:quantum/quantum.c **** 
1377:quantum/quantum.c **** #                define breathing_interrupt_enable() \
1378:quantum/quantum.c ****                     do {                             \
1379:quantum/quantum.c ****                         TIMSKx |= _BV(TOIEx);        \
1380:quantum/quantum.c ****                     } while (0)
1381:quantum/quantum.c **** #                define breathing_interrupt_disable() \
1382:quantum/quantum.c ****                     do {                              \
1383:quantum/quantum.c ****                         TIMSKx &= ~_BV(TOIEx);        \
1384:quantum/quantum.c ****                     } while (0)
1385:quantum/quantum.c **** #            endif
1386:quantum/quantum.c **** 
1387:quantum/quantum.c **** #            define breathing_min()        \
1388:quantum/quantum.c ****                 do {                       \
1389:quantum/quantum.c ****                     breathing_counter = 0; \
1390:quantum/quantum.c ****                 } while (0)
1391:quantum/quantum.c **** #            define breathing_max()                                 \
1392:quantum/quantum.c ****                 do {                                                \
1393:quantum/quantum.c ****                     breathing_counter = breathing_period * 244 / 2; \
1394:quantum/quantum.c ****                 } while (0)
1395:quantum/quantum.c **** 
1396:quantum/quantum.c **** void breathing_enable(void) {
1397:quantum/quantum.c ****     breathing_counter = 0;
1398:quantum/quantum.c ****     breathing_halt = BREATHING_NO_HALT;
1399:quantum/quantum.c ****     breathing_interrupt_enable();
1400:quantum/quantum.c **** }
1401:quantum/quantum.c **** 
1402:quantum/quantum.c **** void breathing_pulse(void) {
1403:quantum/quantum.c ****     if (get_backlight_level() == 0)
1404:quantum/quantum.c ****         breathing_min();
1405:quantum/quantum.c ****     else
1406:quantum/quantum.c ****         breathing_max();
1407:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1408:quantum/quantum.c ****     breathing_interrupt_enable();
1409:quantum/quantum.c **** }
1410:quantum/quantum.c **** 
1411:quantum/quantum.c **** void breathing_disable(void) {
1412:quantum/quantum.c ****     breathing_interrupt_disable();
1413:quantum/quantum.c ****     // Restore backlight level
1414:quantum/quantum.c ****     backlight_set(get_backlight_level());
1415:quantum/quantum.c **** }
1416:quantum/quantum.c **** 
1417:quantum/quantum.c **** void breathing_self_disable(void) {
1418:quantum/quantum.c ****     if (get_backlight_level() == 0)
1419:quantum/quantum.c ****         breathing_halt = BREATHING_HALT_OFF;
1420:quantum/quantum.c ****     else
1421:quantum/quantum.c ****         breathing_halt = BREATHING_HALT_ON;
1422:quantum/quantum.c **** }
1423:quantum/quantum.c **** 
1424:quantum/quantum.c **** void breathing_toggle(void) {
1425:quantum/quantum.c ****     if (is_breathing())
1426:quantum/quantum.c ****         breathing_disable();
1427:quantum/quantum.c ****     else
1428:quantum/quantum.c ****         breathing_enable();
1429:quantum/quantum.c **** }
1430:quantum/quantum.c **** 
1431:quantum/quantum.c **** void breathing_period_set(uint8_t value) {
1432:quantum/quantum.c ****     if (!value) value = 1;
1433:quantum/quantum.c ****     breathing_period = value;
1434:quantum/quantum.c **** }
1435:quantum/quantum.c **** 
1436:quantum/quantum.c **** void breathing_period_default(void) { breathing_period_set(BREATHING_PERIOD); }
1437:quantum/quantum.c **** 
1438:quantum/quantum.c **** void breathing_period_inc(void) { breathing_period_set(breathing_period + 1); }
1439:quantum/quantum.c **** 
1440:quantum/quantum.c **** void breathing_period_dec(void) { breathing_period_set(breathing_period - 1); }
1441:quantum/quantum.c **** 
1442:quantum/quantum.c **** /* To generate breathing curve in python:
1443:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1444:quantum/quantum.c ****  */
1445:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1446:quantum/quantum.c **** 
1447:quantum/quantum.c **** // Use this before the cie_lightness function.
1448:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) { return v / BACKLIGHT_LEVELS * get_backlight_le
1449:quantum/quantum.c **** 
1450:quantum/quantum.c **** #            ifdef BACKLIGHT_PWM_TIMER
1451:quantum/quantum.c **** void breathing_task(void)
1452:quantum/quantum.c **** #            else
1453:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1454:quantum/quantum.c ****  * about 244 times per second.
1455:quantum/quantum.c ****  */
1456:quantum/quantum.c **** ISR(TIMERx_OVF_vect)
1457:quantum/quantum.c **** #            endif
1458:quantum/quantum.c **** {
1459:quantum/quantum.c ****     uint16_t interval = (uint16_t)breathing_period * 244 / BREATHING_STEPS;
1460:quantum/quantum.c ****     // resetting after one period to prevent ugly reset at overflow.
1461:quantum/quantum.c ****     breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1462:quantum/quantum.c ****     uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1463:quantum/quantum.c **** 
1464:quantum/quantum.c ****     if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) || ((breathing_ha
1465:quantum/quantum.c ****         breathing_interrupt_disable();
1466:quantum/quantum.c ****     }
1467:quantum/quantum.c **** 
1468:quantum/quantum.c ****     set_pwm(cie_lightness(scale_backlight((uint16_t)pgm_read_byte(&breathing_table[index]) * 0x0101
1469:quantum/quantum.c **** }
1470:quantum/quantum.c **** 
1471:quantum/quantum.c **** #        endif  // BACKLIGHT_BREATHING
1472:quantum/quantum.c **** 
1473:quantum/quantum.c **** __attribute__((weak)) void backlight_init_ports(void) {
1474:quantum/quantum.c ****     // Setup backlight pin as output and output to on state.
1475:quantum/quantum.c ****     FOR_EACH_LED(setPinOutput(backlight_pin); backlight_on(backlight_pin);)
1476:quantum/quantum.c **** 
1477:quantum/quantum.c ****     // I could write a wall of text here to explain... but TL;DW
1478:quantum/quantum.c ****     // Go read the ATmega32u4 datasheet.
1479:quantum/quantum.c ****     // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolut
1480:quantum/quantum.c **** 
1481:quantum/quantum.c **** #        ifdef BACKLIGHT_PWM_TIMER
1482:quantum/quantum.c ****     // TimerX setup, Fast PWM mode count to TOP set in ICRx
1483:quantum/quantum.c ****     TCCRxA = _BV(WGM11);  // = 0b00000010;
1484:quantum/quantum.c ****     // clock select clk/1
1485:quantum/quantum.c ****     TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10);  // = 0b00011001;
1486:quantum/quantum.c **** #        else  // hardware PWM
1487:quantum/quantum.c ****     // Pin PB7 = OCR1C (Timer 1, Channel C)
1488:quantum/quantum.c ****     // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1489:quantum/quantum.c ****     // (i.e. start high, go low when counter matches.)
1490:quantum/quantum.c ****     // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1491:quantum/quantum.c ****     // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1492:quantum/quantum.c **** 
1493:quantum/quantum.c ****     /*
1494:quantum/quantum.c ****     14.8.3:
1495:quantum/quantum.c ****     "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Settin
1496:quantum/quantum.c ****     "In fast PWM mode the counter is incremented until the counter value matches either one of the 
1497:quantum/quantum.c ****     */
1498:quantum/quantum.c ****     TCCRxA = _BV(COMxx1) | _BV(WGM11);             // = 0b00001010;
1499:quantum/quantum.c ****     TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10);  // = 0b00011001;
1500:quantum/quantum.c **** #        endif
1501:quantum/quantum.c ****     // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1502:quantum/quantum.c ****     ICRx = TIMER_TOP;
1503:quantum/quantum.c **** 
1504:quantum/quantum.c ****     backlight_init();
1505:quantum/quantum.c **** #        ifdef BACKLIGHT_BREATHING
1506:quantum/quantum.c ****     if (is_backlight_breathing()) {
1507:quantum/quantum.c ****         breathing_enable();
1508:quantum/quantum.c ****     }
1509:quantum/quantum.c **** #        endif
1510:quantum/quantum.c **** }
1511:quantum/quantum.c **** 
1512:quantum/quantum.c **** #    endif  // hardware backlight
1513:quantum/quantum.c **** 
1514:quantum/quantum.c **** #else  // no backlight
1515:quantum/quantum.c **** 
1516:quantum/quantum.c **** __attribute__((weak)) void backlight_init_ports(void) {}
1517:quantum/quantum.c **** 
1518:quantum/quantum.c **** __attribute__((weak)) void backlight_set(uint8_t level) {}
1519:quantum/quantum.c **** 
1520:quantum/quantum.c **** #endif  // backlight
1521:quantum/quantum.c **** 
1522:quantum/quantum.c **** #ifdef HD44780_ENABLED
1523:quantum/quantum.c **** #    include "hd44780.h"
1524:quantum/quantum.c **** #endif
1525:quantum/quantum.c **** 
1526:quantum/quantum.c **** // Functions for spitting out values
1527:quantum/quantum.c **** //
1528:quantum/quantum.c **** 
1529:quantum/quantum.c **** void send_dword(uint32_t number) {  // this might not actually work
1530:quantum/quantum.c ****     uint16_t word = (number >> 16);
1531:quantum/quantum.c ****     send_word(word);
1532:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1533:quantum/quantum.c **** }
1534:quantum/quantum.c **** 
1535:quantum/quantum.c **** void send_word(uint16_t number) {
1536:quantum/quantum.c ****     uint8_t byte = number >> 8;
1537:quantum/quantum.c ****     send_byte(byte);
1538:quantum/quantum.c ****     send_byte(number & 0xFF);
1539:quantum/quantum.c **** }
1540:quantum/quantum.c **** 
1541:quantum/quantum.c **** void send_byte(uint8_t number) {
1542:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1543:quantum/quantum.c ****     send_nibble(nibble);
1544:quantum/quantum.c ****     send_nibble(number & 0xF);
1545:quantum/quantum.c **** }
1546:quantum/quantum.c **** 
1547:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1512               		.loc 1 1547 0
 1513               		.cfi_startproc
 1514               	.LVL180:
 1515               		.loc 1 1547 0
 1516 0000 CF93      		push r28
 1517               	.LCFI43:
 1518               		.cfi_def_cfa_offset 3
 1519               		.cfi_offset 28, -2
 1520               	/* prologue: function */
 1521               	/* frame size = 0 */
 1522               	/* stack size = 1 */
 1523               	.L__stack_usage = 1
1548:quantum/quantum.c ****     switch (number) {
 1524               		.loc 1 1548 0
 1525 0002 8A30      		cpi r24,lo8(10)
 1526 0004 00F4      		brsh .L106
 1527 0006 8130      		cpi r24,lo8(1)
 1528 0008 00F0      		brlo .L110
1549:quantum/quantum.c ****         case 0:
1550:quantum/quantum.c ****             register_code(KC_0);
1551:quantum/quantum.c ****             unregister_code(KC_0);
1552:quantum/quantum.c ****             break;
1553:quantum/quantum.c ****         case 1 ... 9:
1554:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 1529               		.loc 1 1554 0
 1530 000a CDE1      		ldi r28,lo8(29)
 1531               	.L113:
1555:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1556:quantum/quantum.c ****             break;
1557:quantum/quantum.c ****         case 0xA ... 0xF:
1558:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1532               		.loc 1 1558 0
 1533 000c C80F      		add r28,r24
 1534 000e 8C2F      		mov r24,r28
 1535               	.LVL181:
 1536 0010 0E94 0000 		call register_code
 1537               	.LVL182:
1559:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1538               		.loc 1 1559 0
 1539 0014 8C2F      		mov r24,r28
 1540 0016 00C0      		rjmp .L112
 1541               	.LVL183:
 1542               	.L106:
1558:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1543               		.loc 1 1558 0
 1544 0018 CAEF      		ldi r28,lo8(-6)
1548:quantum/quantum.c ****         case 0:
 1545               		.loc 1 1548 0
 1546 001a 8031      		cpi r24,lo8(16)
 1547 001c 00F0      		brlo .L113
 1548               	/* epilogue start */
1560:quantum/quantum.c ****             break;
1561:quantum/quantum.c ****     }
1562:quantum/quantum.c **** }
 1549               		.loc 1 1562 0
 1550 001e CF91      		pop r28
 1551 0020 0895      		ret
 1552               	.L110:
1550:quantum/quantum.c ****             unregister_code(KC_0);
 1553               		.loc 1 1550 0
 1554 0022 87E2      		ldi r24,lo8(39)
 1555               	.LVL184:
 1556 0024 0E94 0000 		call register_code
 1557               	.LVL185:
1551:quantum/quantum.c ****             break;
 1558               		.loc 1 1551 0
 1559 0028 87E2      		ldi r24,lo8(39)
 1560               	.L112:
 1561               	/* epilogue start */
 1562               		.loc 1 1562 0
 1563 002a CF91      		pop r28
1559:quantum/quantum.c ****             break;
 1564               		.loc 1 1559 0
 1565 002c 0C94 0000 		jmp unregister_code
 1566               	.LVL186:
 1567               		.cfi_endproc
 1568               	.LFE51:
 1570               		.section	.text.send_byte,"ax",@progbits
 1571               	.global	send_byte
 1573               	send_byte:
 1574               	.LFB50:
1541:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1575               		.loc 1 1541 0
 1576               		.cfi_startproc
 1577               	.LVL187:
 1578 0000 CF93      		push r28
 1579               	.LCFI44:
 1580               		.cfi_def_cfa_offset 3
 1581               		.cfi_offset 28, -2
 1582               	/* prologue: function */
 1583               	/* frame size = 0 */
 1584               	/* stack size = 1 */
 1585               	.L__stack_usage = 1
 1586 0002 C82F      		mov r28,r24
 1587               	.LVL188:
1543:quantum/quantum.c ****     send_nibble(number & 0xF);
 1588               		.loc 1 1543 0
 1589 0004 8295      		swap r24
 1590               	.LVL189:
 1591 0006 8F70      		andi r24,lo8(15)
 1592 0008 0E94 0000 		call send_nibble
 1593               	.LVL190:
1544:quantum/quantum.c **** }
 1594               		.loc 1 1544 0
 1595 000c 8C2F      		mov r24,r28
 1596 000e 8F70      		andi r24,lo8(15)
 1597               	/* epilogue start */
1545:quantum/quantum.c **** 
 1598               		.loc 1 1545 0
 1599 0010 CF91      		pop r28
 1600               	.LVL191:
1544:quantum/quantum.c **** }
 1601               		.loc 1 1544 0
 1602 0012 0C94 0000 		jmp send_nibble
 1603               	.LVL192:
 1604               		.cfi_endproc
 1605               	.LFE50:
 1607               		.section	.text.send_word,"ax",@progbits
 1608               	.global	send_word
 1610               	send_word:
 1611               	.LFB49:
1535:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1612               		.loc 1 1535 0
 1613               		.cfi_startproc
 1614               	.LVL193:
 1615 0000 CF93      		push r28
 1616               	.LCFI45:
 1617               		.cfi_def_cfa_offset 3
 1618               		.cfi_offset 28, -2
 1619               	/* prologue: function */
 1620               	/* frame size = 0 */
 1621               	/* stack size = 1 */
 1622               	.L__stack_usage = 1
 1623 0002 C82F      		mov r28,r24
 1624               	.LVL194:
1537:quantum/quantum.c ****     send_byte(number & 0xFF);
 1625               		.loc 1 1537 0
 1626 0004 892F      		mov r24,r25
 1627               	.LVL195:
 1628 0006 0E94 0000 		call send_byte
 1629               	.LVL196:
1538:quantum/quantum.c **** }
 1630               		.loc 1 1538 0
 1631 000a 8C2F      		mov r24,r28
 1632               	/* epilogue start */
1539:quantum/quantum.c **** 
 1633               		.loc 1 1539 0
 1634 000c CF91      		pop r28
1538:quantum/quantum.c **** }
 1635               		.loc 1 1538 0
 1636 000e 0C94 0000 		jmp send_byte
 1637               	.LVL197:
 1638               		.cfi_endproc
 1639               	.LFE49:
 1641               		.section	.text.send_dword,"ax",@progbits
 1642               	.global	send_dword
 1644               	send_dword:
 1645               	.LFB48:
1529:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1646               		.loc 1 1529 0
 1647               		.cfi_startproc
 1648               	.LVL198:
 1649 0000 CF92      		push r12
 1650               	.LCFI46:
 1651               		.cfi_def_cfa_offset 3
 1652               		.cfi_offset 12, -2
 1653 0002 DF92      		push r13
 1654               	.LCFI47:
 1655               		.cfi_def_cfa_offset 4
 1656               		.cfi_offset 13, -3
 1657 0004 EF92      		push r14
 1658               	.LCFI48:
 1659               		.cfi_def_cfa_offset 5
 1660               		.cfi_offset 14, -4
 1661 0006 FF92      		push r15
 1662               	.LCFI49:
 1663               		.cfi_def_cfa_offset 6
 1664               		.cfi_offset 15, -5
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 4 */
 1668               	.L__stack_usage = 4
 1669 0008 6B01      		movw r12,r22
1531:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1670               		.loc 1 1531 0
 1671 000a 0E94 0000 		call send_word
 1672               	.LVL199:
1532:quantum/quantum.c **** }
 1673               		.loc 1 1532 0
 1674 000e C601      		movw r24,r12
 1675               	/* epilogue start */
1533:quantum/quantum.c **** 
 1676               		.loc 1 1533 0
 1677 0010 FF90      		pop r15
 1678 0012 EF90      		pop r14
 1679 0014 DF90      		pop r13
 1680 0016 CF90      		pop r12
1532:quantum/quantum.c **** }
 1681               		.loc 1 1532 0
 1682 0018 0C94 0000 		jmp send_word
 1683               	.LVL200:
 1684               		.cfi_endproc
 1685               	.LFE48:
 1687               		.section	.text.hex_to_keycode,"ax",@progbits
 1688               		.weak	hex_to_keycode
 1690               	hex_to_keycode:
 1691               	.LFB52:
1563:quantum/quantum.c **** 
1564:quantum/quantum.c **** __attribute__((weak)) uint16_t hex_to_keycode(uint8_t hex) {
 1692               		.loc 1 1564 0
 1693               		.cfi_startproc
 1694               	.LVL201:
 1695               	/* prologue: function */
 1696               	/* frame size = 0 */
 1697               	/* stack size = 0 */
 1698               	.L__stack_usage = 0
1565:quantum/quantum.c ****     hex = hex & 0xF;
 1699               		.loc 1 1565 0
 1700 0000 282F      		mov r18,r24
 1701 0002 2F70      		andi r18,lo8(15)
 1702               	.LVL202:
1566:quantum/quantum.c ****     if (hex == 0x0) {
 1703               		.loc 1 1566 0
 1704 0004 01F0      		breq .L120
 1705 0006 822F      		mov r24,r18
 1706 0008 90E0      		ldi r25,0
1567:quantum/quantum.c ****         return KC_0;
1568:quantum/quantum.c ****     } else if (hex < 0xA) {
 1707               		.loc 1 1568 0
 1708 000a 2A30      		cpi r18,lo8(10)
 1709 000c 00F4      		brsh .L119
1569:quantum/quantum.c ****         return KC_1 + (hex - 0x1);
 1710               		.loc 1 1569 0
 1711 000e 4D96      		adiw r24,29
 1712 0010 0895      		ret
 1713               	.L119:
1570:quantum/quantum.c ****     } else {
1571:quantum/quantum.c ****         return KC_A + (hex - 0xA);
 1714               		.loc 1 1571 0
 1715 0012 0697      		sbiw r24,6
 1716 0014 0895      		ret
 1717               	.L120:
1567:quantum/quantum.c ****     } else if (hex < 0xA) {
 1718               		.loc 1 1567 0
 1719 0016 87E2      		ldi r24,lo8(39)
 1720 0018 90E0      		ldi r25,0
 1721               	/* epilogue start */
1572:quantum/quantum.c ****     }
1573:quantum/quantum.c **** }
 1722               		.loc 1 1573 0
 1723 001a 0895      		ret
 1724               		.cfi_endproc
 1725               	.LFE52:
 1727               		.section	.text.api_send_unicode,"ax",@progbits
 1728               	.global	api_send_unicode
 1730               	api_send_unicode:
 1731               	.LFB53:
1574:quantum/quantum.c **** 
1575:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1732               		.loc 1 1575 0
 1733               		.cfi_startproc
 1734               	.LVL203:
 1735               	/* prologue: function */
 1736               	/* frame size = 0 */
 1737               	/* stack size = 0 */
 1738               	.L__stack_usage = 0
 1739               	/* epilogue start */
1576:quantum/quantum.c **** #ifdef API_ENABLE
1577:quantum/quantum.c ****     uint8_t chunk[4];
1578:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1579:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1580:quantum/quantum.c **** #endif
1581:quantum/quantum.c **** }
 1740               		.loc 1 1581 0
 1741 0000 0895      		ret
 1742               		.cfi_endproc
 1743               	.LFE53:
 1745               		.section	.text.led_set_user,"ax",@progbits
 1746               		.weak	led_set_user
 1748               	led_set_user:
 1749               	.LFB54:
1582:quantum/quantum.c **** 
1583:quantum/quantum.c **** __attribute__((weak)) void led_set_user(uint8_t usb_led) {}
 1750               		.loc 1 1583 0
 1751               		.cfi_startproc
 1752               	.LVL204:
 1753               	/* prologue: function */
 1754               	/* frame size = 0 */
 1755               	/* stack size = 0 */
 1756               	.L__stack_usage = 0
 1757               	/* epilogue start */
 1758               		.loc 1 1583 0
 1759 0000 0895      		ret
 1760               		.cfi_endproc
 1761               	.LFE54:
 1763               		.set	led_set_user.localalias.1,led_set_user
 1764               		.section	.text.backlight_set,"ax",@progbits
 1765               		.weak	backlight_set
 1767               	backlight_set:
 1768               	.LFB67:
 1769               		.cfi_startproc
 1770               	/* prologue: function */
 1771               	/* frame size = 0 */
 1772               	/* stack size = 0 */
 1773               	.L__stack_usage = 0
 1774               	/* epilogue start */
 1775 0000 0895      		ret
 1776               		.cfi_endproc
 1777               	.LFE67:
 1779               		.section	.text.led_set_kb,"ax",@progbits
 1780               		.weak	led_set_kb
 1782               	led_set_kb:
 1783               	.LFB55:
1584:quantum/quantum.c **** 
1585:quantum/quantum.c **** __attribute__((weak)) void led_set_kb(uint8_t usb_led) { led_set_user(usb_led); }
 1784               		.loc 1 1585 0
 1785               		.cfi_startproc
 1786               	.LVL205:
 1787               	/* prologue: function */
 1788               	/* frame size = 0 */
 1789               	/* stack size = 0 */
 1790               	.L__stack_usage = 0
 1791               		.loc 1 1585 0
 1792 0000 0C94 0000 		jmp led_set_user
 1793               	.LVL206:
 1794               		.cfi_endproc
 1795               	.LFE55:
 1797               		.section	.text.led_init_ports,"ax",@progbits
 1798               		.weak	led_init_ports
 1800               	led_init_ports:
 1801               	.LFB56:
1586:quantum/quantum.c **** 
1587:quantum/quantum.c **** __attribute__((weak)) void led_init_ports(void) {}
 1802               		.loc 1 1587 0
 1803               		.cfi_startproc
 1804               	/* prologue: function */
 1805               	/* frame size = 0 */
 1806               	/* stack size = 0 */
 1807               	.L__stack_usage = 0
 1808               	/* epilogue start */
 1809               		.loc 1 1587 0
 1810 0000 0895      		ret
 1811               		.cfi_endproc
 1812               	.LFE56:
 1814               		.section	.text.led_set,"ax",@progbits
 1815               		.weak	led_set
 1817               	led_set:
 1818               	.LFB57:
1588:quantum/quantum.c **** 
1589:quantum/quantum.c **** __attribute__((weak)) void led_set(uint8_t usb_led) {
 1819               		.loc 1 1589 0
 1820               		.cfi_startproc
 1821               	.LVL207:
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
 1824               	/* stack size = 0 */
 1825               	.L__stack_usage = 0
1590:quantum/quantum.c **** #if defined(BACKLIGHT_CAPS_LOCK) && defined(BACKLIGHT_ENABLE)
1591:quantum/quantum.c ****     // Use backlight as Caps Lock indicator
1592:quantum/quantum.c ****     uint8_t bl_toggle_lvl = 0;
1593:quantum/quantum.c **** 
1594:quantum/quantum.c ****     if (IS_LED_ON(usb_led, USB_LED_CAPS_LOCK) && !backlight_config.enable) {
1595:quantum/quantum.c ****         // Turning Caps Lock ON and backlight is disabled in config
1596:quantum/quantum.c ****         // Toggling backlight to the brightest level
1597:quantum/quantum.c ****         bl_toggle_lvl = BACKLIGHT_LEVELS;
1598:quantum/quantum.c ****     } else if (IS_LED_OFF(usb_led, USB_LED_CAPS_LOCK) && backlight_config.enable) {
1599:quantum/quantum.c ****         // Turning Caps Lock OFF and backlight is enabled in config
1600:quantum/quantum.c ****         // Toggling backlight and restoring config level
1601:quantum/quantum.c ****         bl_toggle_lvl = backlight_config.level;
1602:quantum/quantum.c ****     }
1603:quantum/quantum.c **** 
1604:quantum/quantum.c ****     // Set level without modify backlight_config to keep ability to restore state
1605:quantum/quantum.c ****     backlight_set(bl_toggle_lvl);
1606:quantum/quantum.c **** #endif
1607:quantum/quantum.c **** 
1608:quantum/quantum.c ****     led_set_kb(usb_led);
 1826               		.loc 1 1608 0
 1827 0000 0C94 0000 		jmp led_set_kb
 1828               	.LVL208:
 1829               		.cfi_endproc
 1830               	.LFE57:
 1832               		.section	.text.startup_user,"ax",@progbits
 1833               		.weak	startup_user
 1835               	startup_user:
 1836               	.LFB61:
 1837               		.cfi_startproc
 1838               	/* prologue: function */
 1839               	/* frame size = 0 */
 1840               	/* stack size = 0 */
 1841               	.L__stack_usage = 0
 1842               	/* epilogue start */
 1843 0000 0895      		ret
 1844               		.cfi_endproc
 1845               	.LFE61:
 1847               		.section	.text.shutdown_user,"ax",@progbits
 1848               		.weak	shutdown_user
 1850               	shutdown_user:
 1851               	.LFB63:
 1852               		.cfi_startproc
 1853               	/* prologue: function */
 1854               	/* frame size = 0 */
 1855               	/* stack size = 0 */
 1856               	.L__stack_usage = 0
 1857               	/* epilogue start */
 1858 0000 0895      		ret
 1859               		.cfi_endproc
 1860               	.LFE63:
 1862               		.section	.text.reset_keyboard,"ax",@progbits
 1863               	.global	reset_keyboard
 1865               	reset_keyboard:
 1866               	.LFB30:
 157:quantum/quantum.c ****     clear_keyboard();
 1867               		.loc 1 157 0
 1868               		.cfi_startproc
 1869               	/* prologue: function */
 1870               	/* frame size = 0 */
 1871               	/* stack size = 0 */
 1872               	.L__stack_usage = 0
 158:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1873               		.loc 1 158 0
 1874 0000 0E94 0000 		call clear_keyboard
 1875               	.LVL209:
 172:quantum/quantum.c ****     wait_ms(250);
 1876               		.loc 1 172 0
 1877 0004 0E94 0000 		call shutdown_user
 1878               	.LVL210:
 1879               	.LBB51:
 1880               	.LBB52:
 1881               		.loc 2 187 0
 1882 0008 2FEF      		ldi r18,lo8(799999)
 1883 000a 84E3      		ldi r24,hi8(799999)
 1884 000c 9CE0      		ldi r25,hlo8(799999)
 1885 000e 2150      	1:	subi r18,1
 1886 0010 8040      		sbci r24,0
 1887 0012 9040      		sbci r25,0
 1888 0014 01F4      		brne 1b
 1889 0016 00C0      		rjmp .
 1890 0018 0000      		nop
 1891               	.LVL211:
 1892               	.LBE52:
 1893               	.LBE51:
 180:quantum/quantum.c **** #endif
 1894               		.loc 1 180 0
 1895 001a 87E7      		ldi r24,lo8(119)
 1896 001c 97E7      		ldi r25,lo8(119)
 1897 001e 9093 0108 		sts 2048+1,r25
 1898 0022 8093 0008 		sts 2048,r24
 182:quantum/quantum.c **** }
 1899               		.loc 1 182 0
 1900 0026 0C94 0000 		jmp bootloader_jump
 1901               	.LVL212:
 1902               		.cfi_endproc
 1903               	.LFE30:
 1905               		.section	.text.process_record_quantum,"ax",@progbits
 1906               	.global	process_record_quantum
 1908               	process_record_quantum:
 1909               	.LFB33:
 217:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 1910               		.loc 1 217 0
 1911               		.cfi_startproc
 1912               	.LVL213:
 1913 0000 0F93      		push r16
 1914               	.LCFI50:
 1915               		.cfi_def_cfa_offset 3
 1916               		.cfi_offset 16, -2
 1917 0002 1F93      		push r17
 1918               	.LCFI51:
 1919               		.cfi_def_cfa_offset 4
 1920               		.cfi_offset 17, -3
 1921 0004 CF93      		push r28
 1922               	.LCFI52:
 1923               		.cfi_def_cfa_offset 5
 1924               		.cfi_offset 28, -4
 1925 0006 DF93      		push r29
 1926               	.LCFI53:
 1927               		.cfi_def_cfa_offset 6
 1928               		.cfi_offset 29, -5
 1929               	/* prologue: function */
 1930               	/* frame size = 0 */
 1931               	/* stack size = 4 */
 1932               	.L__stack_usage = 4
 1933 0008 8C01      		movw r16,r24
 218:quantum/quantum.c **** 
 1934               		.loc 1 218 0
 1935 000a 0E94 0000 		call get_record_keycode
 1936               	.LVL214:
 1937 000e EC01      		movw r28,r24
 1938               	.LVL215:
 252:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 1939               		.loc 1 252 0
 1940 0010 B801      		movw r22,r16
 1941 0012 0E94 0000 		call process_record_kb
 1942               	.LVL216:
 1943 0016 8823      		tst r24
 1944 0018 01F4      		brne .+2
 1945 001a 00C0      		rjmp .L130
 287:quantum/quantum.c **** #endif
 1946               		.loc 1 287 0 discriminator 2
 1947 001c B801      		movw r22,r16
 1948 001e CE01      		movw r24,r28
 1949 0020 0E94 0000 		call process_space_cadet
 1950               	.LVL217:
 252:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 1951               		.loc 1 252 0 discriminator 2
 1952 0024 8823      		tst r24
 1953 0026 01F4      		brne .+2
 1954 0028 00C0      		rjmp .L130
 295:quantum/quantum.c ****         case RESET:
 1955               		.loc 1 295 0
 1956 002a CB3C      		cpi r28,-53
 1957 002c 8CE5      		ldi r24,92
 1958 002e D807      		cpc r29,r24
 1959 0030 01F4      		brne .+2
 1960 0032 00C0      		rjmp .L135
 1961 0034 00F0      		brlo .+2
 1962 0036 00C0      		rjmp .L136
 1963 0038 C33C      		cpi r28,-61
 1964 003a ECE5      		ldi r30,92
 1965 003c DE07      		cpc r29,r30
 1966 003e 01F4      		brne .+2
 1967 0040 00C0      		rjmp .L137
 1968 0042 00F4      		brsh .L138
 1969 0044 C631      		cpi r28,22
 1970 0046 8CE5      		ldi r24,92
 1971 0048 D807      		cpc r29,r24
 1972 004a 00F4      		brsh .L139
 1973 004c C230      		cpi r28,2
 1974 004e 9CE5      		ldi r25,92
 1975 0050 D907      		cpc r29,r25
 1976 0052 00F0      		brlo .+2
 1977 0054 00C0      		rjmp .L140
 1978 0056 C115      		cp r28,__zero_reg__
 1979 0058 ECE5      		ldi r30,92
 1980 005a DE07      		cpc r29,r30
 1981 005c 01F4      		brne .+2
 1982 005e 00C0      		rjmp .L141
 1983 0060 C130      		cpi r28,1
 1984 0062 DC45      		sbci r29,92
 1985 0064 01F4      		brne .+2
 1986 0066 00C0      		rjmp .L142
 1987               	.L134:
 729:quantum/quantum.c **** }
 1988               		.loc 1 729 0
 1989 0068 C801      		movw r24,r16
 1990               	/* epilogue start */
 730:quantum/quantum.c **** 
 1991               		.loc 1 730 0
 1992 006a DF91      		pop r29
 1993 006c CF91      		pop r28
 1994               	.LVL218:
 1995 006e 1F91      		pop r17
 1996 0070 0F91      		pop r16
 1997               	.LVL219:
 729:quantum/quantum.c **** }
 1998               		.loc 1 729 0
 1999 0072 0C94 0000 		jmp process_action_kb
 2000               	.LVL220:
 2001               	.L139:
 295:quantum/quantum.c ****         case RESET:
 2002               		.loc 1 295 0
 2003 0076 C631      		cpi r28,22
 2004 0078 8CE5      		ldi r24,92
 2005 007a D807      		cpc r29,r24
 2006 007c 01F4      		brne .+2
 2007 007e 00C0      		rjmp .L143
 2008 0080 C23C      		cpi r28,-62
 2009 0082 DC45      		sbci r29,92
 2010 0084 01F4      		brne .L134
 337:quantum/quantum.c **** #    else
 2011               		.loc 1 337 0
 2012 0086 F801      		movw r30,r16
 2013 0088 8281      		ldd r24,Z+2
 2014 008a 8823      		tst r24
 2015 008c 01F4      		brne .+2
 2016 008e 00C0      		rjmp .L130
 341:quantum/quantum.c ****             }
 2017               		.loc 1 341 0
 2018 0090 0E94 0000 		call rgblight_toggle
 2019               	.LVL221:
 2020 0094 00C0      		rjmp .L130
 2021               	.L138:
 2022 0096 F801      		movw r30,r16
 2023 0098 8281      		ldd r24,Z+2
 295:quantum/quantum.c ****         case RESET:
 2024               		.loc 1 295 0
 2025 009a C73C      		cpi r28,-57
 2026 009c FCE5      		ldi r31,92
 2027 009e DF07      		cpc r29,r31
 2028 00a0 01F4      		brne .+2
 2029 00a2 00C0      		rjmp .L145
 2030 00a4 00F4      		brsh .L146
 2031 00a6 C53C      		cpi r28,-59
 2032 00a8 ECE5      		ldi r30,92
 2033 00aa DE07      		cpc r29,r30
 2034 00ac 01F4      		brne .+2
 2035 00ae 00C0      		rjmp .L147
 2036 00b0 00F4      		brsh .+2
 2037 00b2 00C0      		rjmp .L304
 377:quantum/quantum.c **** #    else
 2038               		.loc 1 377 0
 2039 00b4 8823      		tst r24
 2040 00b6 01F4      		brne .+2
 2041 00b8 00C0      		rjmp .L130
 381:quantum/quantum.c ****             }
 2042               		.loc 1 381 0
 2043 00ba 0E94 0000 		call rgblight_decrease_hue
 2044               	.LVL222:
 2045 00be 00C0      		rjmp .L130
 2046               	.L146:
 295:quantum/quantum.c ****         case RESET:
 2047               		.loc 1 295 0
 2048 00c0 C93C      		cpi r28,-55
 2049 00c2 9CE5      		ldi r25,92
 2050 00c4 D907      		cpc r29,r25
 2051 00c6 01F4      		brne .+2
 2052 00c8 00C0      		rjmp .L150
 2053 00ca 00F4      		brsh .+2
 2054 00cc 00C0      		rjmp .L305
 417:quantum/quantum.c **** #    else
 2055               		.loc 1 417 0
 2056 00ce 8823      		tst r24
 2057 00d0 01F4      		brne .+2
 2058 00d2 00C0      		rjmp .L130
 421:quantum/quantum.c ****             }
 2059               		.loc 1 421 0
 2060 00d4 0E94 0000 		call rgblight_decrease_val
 2061               	.LVL223:
 2062 00d8 00C0      		rjmp .L130
 2063               	.L136:
 295:quantum/quantum.c ****         case RESET:
 2064               		.loc 1 295 0
 2065 00da C33D      		cpi r28,-45
 2066 00dc FCE5      		ldi r31,92
 2067 00de DF07      		cpc r29,r31
 2068 00e0 01F4      		brne .+2
 2069 00e2 00C0      		rjmp .L153
 2070 00e4 00F4      		brsh .L154
 2071 00e6 F801      		movw r30,r16
 2072 00e8 8281      		ldd r24,Z+2
 2073 00ea CF3C      		cpi r28,-49
 2074 00ec FCE5      		ldi r31,92
 2075 00ee DF07      		cpc r29,r31
 2076 00f0 01F4      		brne .+2
 2077 00f2 00C0      		rjmp .L155
 2078 00f4 00F4      		brsh .L156
 2079 00f6 CD3C      		cpi r28,-51
 2080 00f8 ECE5      		ldi r30,92
 2081 00fa DE07      		cpc r29,r30
 2082 00fc 01F4      		brne .+2
 2083 00fe 00C0      		rjmp .L157
 2084 0100 00F4      		brsh .+2
 2085 0102 00C0      		rjmp .L306
 441:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) && (rgblight_get_mode() < RGBL
 2086               		.loc 1 441 0
 2087 0104 8823      		tst r24
 2088 0106 01F4      		brne .+2
 2089 0108 00C0      		rjmp .L130
 442:quantum/quantum.c ****                     rgblight_step();
 2090               		.loc 1 442 0
 2091 010a 0E94 0000 		call rgblight_get_mode
 2092               	.LVL224:
 2093 010e 8230      		cpi r24,lo8(2)
 2094 0110 00F0      		brlo .L171
 442:quantum/quantum.c ****                     rgblight_step();
 2095               		.loc 1 442 0 is_stmt 0 discriminator 1
 2096 0112 0E94 0000 		call rgblight_get_mode
 2097               	.LVL225:
 2098 0116 8530      		cpi r24,lo8(5)
 2099 0118 00F4      		brsh .+2
 2100 011a 00C0      		rjmp .L169
 2101               	.L171:
 445:quantum/quantum.c ****                 }
 2102               		.loc 1 445 0 is_stmt 1
 2103 011c 82E0      		ldi r24,lo8(2)
 2104 011e 00C0      		rjmp .L312
 2105               	.L156:
 295:quantum/quantum.c ****         case RESET:
 2106               		.loc 1 295 0
 2107 0120 C13D      		cpi r28,-47
 2108 0122 9CE5      		ldi r25,92
 2109 0124 D907      		cpc r29,r25
 2110 0126 01F4      		brne .+2
 2111 0128 00C0      		rjmp .L160
 2112 012a 00F4      		brsh .+2
 2113 012c 00C0      		rjmp .L307
 485:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) && (rgblight_get_mode() < RGBLIGH
 2114               		.loc 1 485 0
 2115 012e 8823      		tst r24
 2116 0130 01F4      		brne .+2
 2117 0132 00C0      		rjmp .L130
 486:quantum/quantum.c ****                     rgblight_step();
 2118               		.loc 1 486 0
 2119 0134 0E94 0000 		call rgblight_get_mode
 2120               	.LVL226:
 2121 0138 8531      		cpi r24,lo8(21)
 2122 013a 00F0      		brlo .L175
 486:quantum/quantum.c ****                     rgblight_step();
 2123               		.loc 1 486 0 is_stmt 0 discriminator 1
 2124 013c 0E94 0000 		call rgblight_get_mode
 2125               	.LVL227:
 2126 0140 8731      		cpi r24,lo8(23)
 2127 0142 00F4      		brsh .+2
 2128 0144 00C0      		rjmp .L169
 2129               	.L175:
 489:quantum/quantum.c ****                 }
 2130               		.loc 1 489 0 is_stmt 1
 2131 0146 85E1      		ldi r24,lo8(21)
 2132 0148 00C0      		rjmp .L312
 2133               	.L154:
 295:quantum/quantum.c ****         case RESET:
 2134               		.loc 1 295 0
 2135 014a CD3D      		cpi r28,-35
 2136 014c FCE5      		ldi r31,92
 2137 014e DF07      		cpc r29,r31
 2138 0150 01F4      		brne .+2
 2139 0152 00C0      		rjmp .L163
 2140 0154 00F4      		brsh .L164
 2141 0156 C53D      		cpi r28,-43
 2142 0158 9CE5      		ldi r25,92
 2143 015a D907      		cpc r29,r25
 2144 015c 01F4      		brne .+2
 2145 015e 00C0      		rjmp .L165
 2146 0160 00F4      		brsh .+2
 2147 0162 00C0      		rjmp .L166
 2148 0164 CC3D      		cpi r28,-36
 2149 0166 DC45      		sbci r29,92
 2150 0168 01F0      		breq .+2
 2151 016a 00C0      		rjmp .L134
 529:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 2152               		.loc 1 529 0
 2153 016c F801      		movw r30,r16
 2154 016e 8281      		ldd r24,Z+2
 2155 0170 8823      		tst r24
 2156 0172 01F4      		brne .+2
 2157 0174 00C0      		rjmp .L130
 530:quantum/quantum.c ****             }
 2158               		.loc 1 530 0
 2159 0176 80E0      		ldi r24,0
 2160               	.L313:
 535:quantum/quantum.c ****             }
 2161               		.loc 1 535 0
 2162 0178 0E94 0000 		call set_output
 2163               	.LVL228:
 2164 017c 00C0      		rjmp .L130
 2165               	.L164:
 295:quantum/quantum.c ****         case RESET:
 2166               		.loc 1 295 0
 2167 017e CE3D      		cpi r28,-34
 2168 0180 8CE5      		ldi r24,92
 2169 0182 D807      		cpc r29,r24
 2170 0184 01F4      		brne .+2
 2171 0186 00C0      		rjmp .L168
 2172 0188 CE01      		movw r24,r28
 2173 018a 8A5F      		subi r24,-6
 2174 018c 9C45      		sbci r25,92
 2175 018e 0797      		sbiw r24,7
 2176 0190 00F0      		brlo .+2
 2177 0192 00C0      		rjmp .L134
 2178               	.L140:
 548:quantum/quantum.c ****                 // MAGIC actions (BOOTMAGIC without the boot)
 2179               		.loc 1 548 0
 2180 0194 F801      		movw r30,r16
 2181 0196 8281      		ldd r24,Z+2
 2182 0198 8823      		tst r24
 2183 019a 01F4      		brne .+2
 2184 019c 00C0      		rjmp .L134
 550:quantum/quantum.c ****                     eeconfig_init();
 2185               		.loc 1 550 0
 2186 019e 0E94 0000 		call eeconfig_is_enabled
 2187               	.LVL229:
 2188 01a2 8111      		cpse r24,__zero_reg__
 2189 01a4 00C0      		rjmp .L177
 551:quantum/quantum.c ****                 }
 2190               		.loc 1 551 0
 2191 01a6 0E94 0000 		call eeconfig_init
 2192               	.LVL230:
 2193               	.L177:
 554:quantum/quantum.c ****                 switch (keycode) {
 2194               		.loc 1 554 0
 2195 01aa 0E94 0000 		call eeconfig_read_keymap
 2196               	.LVL231:
 2197 01ae 9093 0000 		sts keymap_config+1,r25
 2198 01b2 8093 0000 		sts keymap_config,r24
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2199               		.loc 1 555 0
 2200 01b6 CF30      		cpi r28,15
 2201 01b8 FCE5      		ldi r31,92
 2202 01ba DF07      		cpc r29,r31
 2203 01bc 01F4      		brne .+2
 2204 01be 00C0      		rjmp .L179
 2205 01c0 00F0      		brlo .+2
 2206 01c2 00C0      		rjmp .L180
 2207 01c4 C830      		cpi r28,8
 2208 01c6 9CE5      		ldi r25,92
 2209 01c8 D907      		cpc r29,r25
 2210 01ca 01F4      		brne .+2
 2211 01cc 00C0      		rjmp .L181
 2212 01ce 00F0      		brlo .+2
 2213 01d0 00C0      		rjmp .L182
 2214 01d2 C430      		cpi r28,4
 2215 01d4 FCE5      		ldi r31,92
 2216 01d6 DF07      		cpc r29,r31
 2217 01d8 01F4      		brne .+2
 2218 01da 00C0      		rjmp .L183
 2219 01dc 00F0      		brlo .+2
 2220 01de 00C0      		rjmp .L184
 2221 01e0 C230      		cpi r28,2
 2222 01e2 9CE5      		ldi r25,92
 2223 01e4 D907      		cpc r29,r25
 2224 01e6 01F4      		brne .+2
 2225 01e8 00C0      		rjmp .L185
 560:quantum/quantum.c ****                         break;
 2226               		.loc 1 560 0
 2227 01ea 8091 0000 		lds r24,keymap_config
 2228 01ee 8260      		ori r24,lo8(1<<1)
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2229               		.loc 1 555 0
 2230 01f0 C330      		cpi r28,3
 2231 01f2 DC45      		sbci r29,92
 2232 01f4 01F4      		brne .+2
 2233 01f6 00C0      		rjmp .L310
 2234               	.L178:
 668:quantum/quantum.c ****                 clear_keyboard();  // clear to prevent stuck keys
 2235               		.loc 1 668 0
 2236 01f8 8091 0000 		lds r24,keymap_config
 2237 01fc 9091 0000 		lds r25,keymap_config+1
 2238 0200 0E94 0000 		call eeconfig_update_keymap
 2239               	.LVL232:
 669:quantum/quantum.c **** 
 2240               		.loc 1 669 0
 2241 0204 0E94 0000 		call clear_keyboard
 2242               	.LVL233:
 671:quantum/quantum.c ****             }
 2243               		.loc 1 671 0
 2244 0208 00C0      		rjmp .L130
 2245               	.L141:
 297:quantum/quantum.c ****                 reset_keyboard();
 2246               		.loc 1 297 0
 2247 020a F801      		movw r30,r16
 2248 020c 8281      		ldd r24,Z+2
 2249 020e 8111      		cpse r24,__zero_reg__
 298:quantum/quantum.c ****             }
 2250               		.loc 1 298 0
 2251 0210 0E94 0000 		call reset_keyboard
 2252               	.LVL234:
 2253               	.L130:
 730:quantum/quantum.c **** 
 2254               		.loc 1 730 0
 2255 0214 80E0      		ldi r24,0
 2256               	/* epilogue start */
 2257 0216 DF91      		pop r29
 2258 0218 CF91      		pop r28
 2259               	.LVL235:
 2260 021a 1F91      		pop r17
 2261 021c 0F91      		pop r16
 2262               	.LVL236:
 2263 021e 0895      		ret
 2264               	.LVL237:
 2265               	.L142:
 302:quantum/quantum.c ****                 debug_enable ^= 1;
 2266               		.loc 1 302 0
 2267 0220 F801      		movw r30,r16
 2268 0222 8281      		ldd r24,Z+2
 2269 0224 8823      		tst r24
 2270 0226 01F0      		breq .L130
 303:quantum/quantum.c ****                 if (debug_enable) {
 2271               		.loc 1 303 0
 2272 0228 9091 0000 		lds r25,debug_config
 2273 022c 892F      		mov r24,r25
 2274 022e 8E7F      		andi r24,~(1<<0)
 2275 0230 90FF      		sbrs r25,0
 2276 0232 8160      		ori r24,1<<0
 2277 0234 8093 0000 		sts debug_config,r24
 2278 0238 00C0      		rjmp .L130
 2279               	.L168:
 312:quantum/quantum.c ****                 eeconfig_init();
 2280               		.loc 1 312 0
 2281 023a F801      		movw r30,r16
 2282 023c 8281      		ldd r24,Z+2
 2283 023e 8823      		tst r24
 2284 0240 01F0      		breq .L130
 313:quantum/quantum.c ****             }
 2285               		.loc 1 313 0
 2286 0242 0E94 0000 		call eeconfig_init
 2287               	.LVL238:
 2288 0246 00C0      		rjmp .L130
 2289               	.L137:
 345:quantum/quantum.c ****                 uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT));
 2290               		.loc 1 345 0
 2291 0248 F801      		movw r30,r16
 2292 024a 8281      		ldd r24,Z+2
 2293 024c 8823      		tst r24
 2294 024e 01F0      		breq .L130
 2295               	.LBB53:
 346:quantum/quantum.c ****                 if (shifted) {
 2296               		.loc 1 346 0
 2297 0250 0E94 0000 		call get_mods
 2298               	.LVL239:
 2299 0254 8272      		andi r24,lo8(34)
 2300               	.LVL240:
 347:quantum/quantum.c ****                     rgblight_step_reverse();
 2301               		.loc 1 347 0
 2302 0256 01F0      		breq .L169
 2303               	.LVL241:
 2304               	.L170:
 348:quantum/quantum.c ****                 } else {
 2305               		.loc 1 348 0
 2306 0258 0E94 0000 		call rgblight_step_reverse
 2307               	.LVL242:
 2308 025c 00C0      		rjmp .L130
 2309               	.L304:
 2310               	.LBE53:
 355:quantum/quantum.c ****                 uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT));
 2311               		.loc 1 355 0
 2312 025e 8823      		tst r24
 2313 0260 01F0      		breq .L130
 2314               	.LBB54:
 356:quantum/quantum.c ****                 if (shifted) {
 2315               		.loc 1 356 0
 2316 0262 0E94 0000 		call get_mods
 2317               	.LVL243:
 2318 0266 8272      		andi r24,lo8(34)
 2319               	.LVL244:
 357:quantum/quantum.c ****                     rgblight_step();
 2320               		.loc 1 357 0
 2321 0268 01F0      		breq .L170
 2322               	.LVL245:
 2323               	.L169:
 2324               	.LBE54:
 2325               	.LBB55:
 350:quantum/quantum.c ****                 }
 2326               		.loc 1 350 0
 2327 026a 0E94 0000 		call rgblight_step
 2328               	.LVL246:
 2329 026e 00C0      		rjmp .L130
 2330               	.L147:
 2331               	.LBE55:
 367:quantum/quantum.c **** #    else
 2332               		.loc 1 367 0
 2333 0270 8823      		tst r24
 2334 0272 01F0      		breq .L130
 371:quantum/quantum.c ****             }
 2335               		.loc 1 371 0
 2336 0274 0E94 0000 		call rgblight_increase_hue
 2337               	.LVL247:
 2338 0278 00C0      		rjmp .L130
 2339               	.L145:
 387:quantum/quantum.c **** #    else
 2340               		.loc 1 387 0
 2341 027a 8823      		tst r24
 2342 027c 01F0      		breq .L130
 391:quantum/quantum.c ****             }
 2343               		.loc 1 391 0
 2344 027e 0E94 0000 		call rgblight_increase_sat
 2345               	.LVL248:
 2346 0282 00C0      		rjmp .L130
 2347               	.L305:
 397:quantum/quantum.c **** #    else
 2348               		.loc 1 397 0
 2349 0284 8823      		tst r24
 2350 0286 01F0      		breq .L130
 401:quantum/quantum.c ****             }
 2351               		.loc 1 401 0
 2352 0288 0E94 0000 		call rgblight_decrease_sat
 2353               	.LVL249:
 2354 028c 00C0      		rjmp .L130
 2355               	.L150:
 407:quantum/quantum.c **** #    else
 2356               		.loc 1 407 0
 2357 028e 8823      		tst r24
 2358 0290 01F4      		brne .+2
 2359 0292 00C0      		rjmp .L130
 411:quantum/quantum.c ****             }
 2360               		.loc 1 411 0
 2361 0294 0E94 0000 		call rgblight_increase_val
 2362               	.LVL250:
 2363 0298 00C0      		rjmp .L130
 2364               	.L135:
 425:quantum/quantum.c ****                 rgblight_increase_speed();
 2365               		.loc 1 425 0
 2366 029a F801      		movw r30,r16
 2367 029c 8281      		ldd r24,Z+2
 2368 029e 8823      		tst r24
 2369 02a0 01F4      		brne .+2
 2370 02a2 00C0      		rjmp .L130
 426:quantum/quantum.c ****             }
 2371               		.loc 1 426 0
 2372 02a4 0E94 0000 		call rgblight_increase_speed
 2373               	.LVL251:
 2374 02a8 00C0      		rjmp .L130
 2375               	.L306:
 430:quantum/quantum.c ****                 rgblight_decrease_speed();
 2376               		.loc 1 430 0
 2377 02aa 8823      		tst r24
 2378 02ac 01F4      		brne .+2
 2379 02ae 00C0      		rjmp .L130
 431:quantum/quantum.c ****             }
 2380               		.loc 1 431 0
 2381 02b0 0E94 0000 		call rgblight_decrease_speed
 2382               	.LVL252:
 2383 02b4 00C0      		rjmp .L130
 2384               	.L157:
 435:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 2385               		.loc 1 435 0
 2386 02b6 8823      		tst r24
 2387 02b8 01F4      		brne .+2
 2388 02ba 00C0      		rjmp .L130
 436:quantum/quantum.c ****             }
 2389               		.loc 1 436 0
 2390 02bc 81E0      		ldi r24,lo8(1)
 2391               	.L312:
 445:quantum/quantum.c ****                 }
 2392               		.loc 1 445 0
 2393 02be 0E94 0000 		call rgblight_mode
 2394               	.LVL253:
 2395 02c2 00C0      		rjmp .L130
 2396               	.L155:
 452:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) && (rgblight_get_mode() < R
 2397               		.loc 1 452 0
 2398 02c4 8823      		tst r24
 2399 02c6 01F4      		brne .+2
 2400 02c8 00C0      		rjmp .L130
 453:quantum/quantum.c ****                     rgblight_step();
 2401               		.loc 1 453 0
 2402 02ca 0E94 0000 		call rgblight_get_mode
 2403               	.LVL254:
 2404 02ce 8630      		cpi r24,lo8(6)
 2405 02d0 00F0      		brlo .L172
 453:quantum/quantum.c ****                     rgblight_step();
 2406               		.loc 1 453 0 is_stmt 0 discriminator 1
 2407 02d2 0E94 0000 		call rgblight_get_mode
 2408               	.LVL255:
 2409 02d6 8830      		cpi r24,lo8(8)
 2410 02d8 00F0      		brlo .L169
 2411               	.L172:
 456:quantum/quantum.c ****                 }
 2412               		.loc 1 456 0 is_stmt 1
 2413 02da 86E0      		ldi r24,lo8(6)
 2414 02dc 00C0      		rjmp .L312
 2415               	.L307:
 463:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) && (rgblight_get_mode() < 
 2416               		.loc 1 463 0
 2417 02de 8823      		tst r24
 2418 02e0 01F4      		brne .+2
 2419 02e2 00C0      		rjmp .L130
 464:quantum/quantum.c ****                     rgblight_step();
 2420               		.loc 1 464 0
 2421 02e4 0E94 0000 		call rgblight_get_mode
 2422               	.LVL256:
 2423 02e8 8930      		cpi r24,lo8(9)
 2424 02ea 00F0      		brlo .L173
 464:quantum/quantum.c ****                     rgblight_step();
 2425               		.loc 1 464 0 is_stmt 0 discriminator 1
 2426 02ec 0E94 0000 		call rgblight_get_mode
 2427               	.LVL257:
 2428 02f0 8E30      		cpi r24,lo8(14)
 2429 02f2 00F4      		brsh .+2
 2430 02f4 00C0      		rjmp .L169
 2431               	.L173:
 467:quantum/quantum.c ****                 }
 2432               		.loc 1 467 0 is_stmt 1
 2433 02f6 89E0      		ldi r24,lo8(9)
 2434 02f8 00C0      		rjmp .L312
 2435               	.L160:
 474:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) && (rgblight_get_mode() < RGBLIGHT
 2436               		.loc 1 474 0
 2437 02fa 8823      		tst r24
 2438 02fc 01F4      		brne .+2
 2439 02fe 00C0      		rjmp .L130
 475:quantum/quantum.c ****                     rgblight_step();
 2440               		.loc 1 475 0
 2441 0300 0E94 0000 		call rgblight_get_mode
 2442               	.LVL258:
 2443 0304 8F30      		cpi r24,lo8(15)
 2444 0306 00F0      		brlo .L174
 475:quantum/quantum.c ****                     rgblight_step();
 2445               		.loc 1 475 0 is_stmt 0 discriminator 1
 2446 0308 0E94 0000 		call rgblight_get_mode
 2447               	.LVL259:
 2448 030c 8431      		cpi r24,lo8(20)
 2449 030e 00F4      		brsh .+2
 2450 0310 00C0      		rjmp .L169
 2451               	.L174:
 478:quantum/quantum.c ****                 }
 2452               		.loc 1 478 0 is_stmt 1
 2453 0312 8FE0      		ldi r24,lo8(15)
 2454 0314 00C0      		rjmp .L312
 2455               	.L153:
 496:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 2456               		.loc 1 496 0
 2457 0316 F801      		movw r30,r16
 2458 0318 8281      		ldd r24,Z+2
 2459 031a 8823      		tst r24
 2460 031c 01F4      		brne .+2
 2461 031e 00C0      		rjmp .L130
 497:quantum/quantum.c ****             }
 2462               		.loc 1 497 0
 2463 0320 88E1      		ldi r24,lo8(24)
 2464 0322 00C0      		rjmp .L312
 2465               	.L166:
 503:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) && (rgblight_get_mode() 
 2466               		.loc 1 503 0
 2467 0324 F801      		movw r30,r16
 2468 0326 8281      		ldd r24,Z+2
 2469 0328 8823      		tst r24
 2470 032a 01F4      		brne .+2
 2471 032c 00C0      		rjmp .L130
 504:quantum/quantum.c ****                     rgblight_step();
 2472               		.loc 1 504 0
 2473 032e 0E94 0000 		call rgblight_get_mode
 2474               	.LVL260:
 2475 0332 8931      		cpi r24,lo8(25)
 2476 0334 00F0      		brlo .L176
 504:quantum/quantum.c ****                     rgblight_step();
 2477               		.loc 1 504 0 is_stmt 0 discriminator 1
 2478 0336 0E94 0000 		call rgblight_get_mode
 2479               	.LVL261:
 2480 033a 8232      		cpi r24,lo8(34)
 2481 033c 00F4      		brsh .+2
 2482 033e 00C0      		rjmp .L169
 2483               	.L176:
 507:quantum/quantum.c ****                 }
 2484               		.loc 1 507 0 is_stmt 1
 2485 0340 89E1      		ldi r24,lo8(25)
 2486 0342 00C0      		rjmp .L312
 2487               	.L165:
 514:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 2488               		.loc 1 514 0
 2489 0344 F801      		movw r30,r16
 2490 0346 8281      		ldd r24,Z+2
 2491 0348 8823      		tst r24
 2492 034a 01F4      		brne .+2
 2493 034c 00C0      		rjmp .L130
 515:quantum/quantum.c ****             }
 2494               		.loc 1 515 0
 2495 034e 83E2      		ldi r24,lo8(35)
 2496 0350 00C0      		rjmp .L312
 2497               	.L163:
 534:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 2498               		.loc 1 534 0
 2499 0352 F801      		movw r30,r16
 2500 0354 8281      		ldd r24,Z+2
 2501 0356 8823      		tst r24
 2502 0358 01F4      		brne .+2
 2503 035a 00C0      		rjmp .L130
 535:quantum/quantum.c ****             }
 2504               		.loc 1 535 0
 2505 035c 82E0      		ldi r24,lo8(2)
 2506 035e 00C0      		rjmp .L313
 2507               	.L184:
 575:quantum/quantum.c ****                         break;
 2508               		.loc 1 575 0
 2509 0360 8091 0000 		lds r24,keymap_config
 2510 0364 8061      		ori r24,lo8(1<<4)
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2511               		.loc 1 555 0
 2512 0366 C630      		cpi r28,6
 2513 0368 FCE5      		ldi r31,92
 2514 036a DF07      		cpc r29,r31
 2515 036c 01F4      		brne .+2
 2516 036e 00C0      		rjmp .L310
 2517 0370 00F4      		brsh .+2
 2518 0372 00C0      		rjmp .L308
 578:quantum/quantum.c ****                         break;
 2519               		.loc 1 578 0
 2520 0374 8091 0000 		lds r24,keymap_config
 2521 0378 8062      		ori r24,lo8(1<<5)
 2522 037a 00C0      		rjmp .L310
 2523               	.L182:
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2524               		.loc 1 555 0
 2525 037c CB30      		cpi r28,11
 2526 037e 9CE5      		ldi r25,92
 2527 0380 D907      		cpc r29,r25
 2528 0382 01F4      		brne .+2
 2529 0384 00C0      		rjmp .L190
 2530 0386 00F4      		brsh .L191
 2531 0388 C930      		cpi r28,9
 2532 038a FCE5      		ldi r31,92
 2533 038c DF07      		cpc r29,r31
 2534 038e 01F4      		brne .+2
 2535 0390 00C0      		rjmp .L192
 2536 0392 CA30      		cpi r28,10
 2537 0394 DC45      		sbci r29,92
 2538 0396 01F0      		breq .+2
 2539 0398 00C0      		rjmp .L178
 587:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2540               		.loc 1 587 0
 2541 039a 8091 0000 		lds r24,keymap_config
 2542 039e 8860      		ori r24,lo8(8)
 2543 03a0 00C0      		rjmp .L316
 2544               	.L191:
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2545               		.loc 1 555 0
 2546 03a2 CD30      		cpi r28,13
 2547 03a4 9CE5      		ldi r25,92
 2548 03a6 D907      		cpc r29,r25
 2549 03a8 01F4      		brne .+2
 2550 03aa 00C0      		rjmp .L194
 602:quantum/quantum.c ****                         break;
 2551               		.loc 1 602 0
 2552 03ac 8091 0000 		lds r24,keymap_config
 2553 03b0 8D7F      		andi r24,lo8(~(1<<1))
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2554               		.loc 1 555 0
 2555 03b2 CE30      		cpi r28,14
 2556 03b4 DC45      		sbci r29,92
 2557 03b6 00F4      		brsh .+2
 2558 03b8 00C0      		rjmp .L310
 608:quantum/quantum.c ****                         break;
 2559               		.loc 1 608 0
 2560 03ba 8091 0000 		lds r24,keymap_config
 2561 03be 877F      		andi r24,lo8(~(1<<3))
 2562 03c0 00C0      		rjmp .L310
 2563               	.L180:
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2564               		.loc 1 555 0
 2565 03c2 CA3F      		cpi r28,-6
 2566 03c4 FCE5      		ldi r31,92
 2567 03c6 DF07      		cpc r29,r31
 2568 03c8 01F4      		brne .+2
 2569 03ca 00C0      		rjmp .L197
 2570 03cc 00F4      		brsh .L198
 2571 03ce C231      		cpi r28,18
 2572 03d0 9CE5      		ldi r25,92
 2573 03d2 D907      		cpc r29,r25
 2574 03d4 01F4      		brne .+2
 2575 03d6 00C0      		rjmp .L199
 2576 03d8 00F4      		brsh .L200
 2577 03da C031      		cpi r28,16
 2578 03dc FCE5      		ldi r31,92
 2579 03de DF07      		cpc r29,r31
 2580 03e0 01F4      		brne .+2
 2581 03e2 00C0      		rjmp .L201
 2582 03e4 C131      		cpi r28,17
 2583 03e6 DC45      		sbci r29,92
 2584 03e8 01F0      		breq .+2
 2585 03ea 00C0      		rjmp .L178
 623:quantum/quantum.c ****                         break;
 2586               		.loc 1 623 0
 2587 03ec 8091 0000 		lds r24,keymap_config
 2588 03f0 8F7B      		andi r24,lo8(~(1<<6))
 2589 03f2 00C0      		rjmp .L310
 2590               	.L200:
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2591               		.loc 1 555 0
 2592 03f4 C431      		cpi r28,20
 2593 03f6 9CE5      		ldi r25,92
 2594 03f8 D907      		cpc r29,r25
 2595 03fa 01F4      		brne .+2
 2596 03fc 00C0      		rjmp .L203
 2597 03fe 00F4      		brsh .+2
 2598 0400 00C0      		rjmp .L204
 2599 0402 C531      		cpi r28,21
 2600 0404 DC45      		sbci r29,92
 2601 0406 01F0      		breq .+2
 2602 0408 00C0      		rjmp .L178
 641:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = keymap_config.swap_lalt_lgui;
 2603               		.loc 1 641 0
 2604 040a 8091 0000 		lds r24,keymap_config
 2605 040e 82FB      		bst r24,2
 2606 0410 9927      		clr r25
 2607 0412 90F9      		bld r25,0
 2608 0414 21E0      		ldi r18,lo8(1)
 2609 0416 9227      		eor r25,r18
 2610 0418 90FB      		bst r25,0
 2611 041a 82F9      		bld r24,2
 642:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2612               		.loc 1 642 0
 2613 041c 90FB      		bst r25,0
 2614 041e 83F9      		bld r24,3
 2615 0420 00C0      		rjmp .L310
 2616               	.L198:
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2617               		.loc 1 555 0
 2618 0422 CD3F      		cpi r28,-3
 2619 0424 8CE5      		ldi r24,92
 2620 0426 D807      		cpc r29,r24
 2621 0428 01F4      		brne .+2
 2622 042a 00C0      		rjmp .L206
 2623 042c 00F4      		brsh .L207
 2624 042e CB3F      		cpi r28,-5
 2625 0430 ECE5      		ldi r30,92
 2626 0432 DE07      		cpc r29,r30
 2627 0434 01F0      		breq .L208
 611:quantum/quantum.c ****                         break;
 2628               		.loc 1 611 0
 2629 0436 8091 0000 		lds r24,keymap_config+1
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2630               		.loc 1 555 0
 2631 043a CC3F      		cpi r28,-4
 2632 043c DC45      		sbci r29,92
 2633 043e 01F0      		breq .+2
 2634 0440 00C0      		rjmp .L178
 2635               	.L315:
 635:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2636               		.loc 1 635 0
 2637 0442 8E7F      		andi r24,lo8(~(1<<0))
 2638 0444 00C0      		rjmp .L311
 2639               	.L207:
 555:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2640               		.loc 1 555 0
 2641 0446 CF3F      		cpi r28,-1
 2642 0448 8CE5      		ldi r24,92
 2643 044a D807      		cpc r29,r24
 2644 044c 01F4      		brne .+2
 2645 044e 00C0      		rjmp .L210
 2646 0450 00F0      		brlo .L211
 2647 0452 C115      		cp r28,__zero_reg__
 2648 0454 DD45      		sbci r29,93
 2649 0456 01F0      		breq .+2
 2650 0458 00C0      		rjmp .L178
 652:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = keymap_config.swap_lctl_lgui;
 2651               		.loc 1 652 0
 2652 045a 8091 0000 		lds r24,keymap_config+1
 2653 045e 982F      		mov r25,r24
 2654 0460 9095      		com r25
 2655 0462 9170      		andi r25,lo8(1)
 2656 0464 8E7F      		andi r24,lo8(-2)
 653:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2657               		.loc 1 653 0
 2658 0466 892B      		or r24,r25
 2659 0468 90FB      		bst r25,0
 2660 046a 81F9      		bld r24,1
 2661 046c 00C0      		rjmp .L311
 2662               	.L185:
 557:quantum/quantum.c ****                         break;
 2663               		.loc 1 557 0
 2664 046e 8091 0000 		lds r24,keymap_config
 2665 0472 8160      		ori r24,lo8(1<<0)
 2666               	.L310:
 663:quantum/quantum.c ****                         break;
 2667               		.loc 1 663 0
 2668 0474 8093 0000 		sts keymap_config,r24
 664:quantum/quantum.c ****                     default:
 2669               		.loc 1 664 0
 2670 0478 00C0      		rjmp .L178
 2671               	.L183:
 563:quantum/quantum.c ****                         break;
 2672               		.loc 1 563 0
 2673 047a 8091 0000 		lds r24,keymap_config
 2674               	.L316:
 587:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2675               		.loc 1 587 0
 2676 047e 8460      		ori r24,lo8(1<<2)
 2677 0480 00C0      		rjmp .L310
 2678               	.L308:
 566:quantum/quantum.c ****                         break;
 2679               		.loc 1 566 0
 2680 0482 8091 0000 		lds r24,keymap_config
 2681 0486 8860      		ori r24,lo8(1<<3)
 2682 0488 00C0      		rjmp .L310
 2683               	.L197:
 569:quantum/quantum.c ****                         break;
 2684               		.loc 1 569 0
 2685 048a 8091 0000 		lds r24,keymap_config+1
 2686               	.L314:
 593:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2687               		.loc 1 593 0
 2688 048e 8160      		ori r24,lo8(1<<0)
 2689 0490 00C0      		rjmp .L311
 2690               	.L208:
 572:quantum/quantum.c ****                         break;
 2691               		.loc 1 572 0
 2692 0492 8091 0000 		lds r24,keymap_config+1
 2693 0496 8260      		ori r24,lo8(1<<1)
 2694               	.L311:
 653:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2695               		.loc 1 653 0
 2696 0498 8093 0000 		sts keymap_config+1,r24
 661:quantum/quantum.c ****                     case MAGIC_TOGGLE_NKRO:
 2697               		.loc 1 661 0
 2698 049c 00C0      		rjmp .L178
 2699               	.L181:
 581:quantum/quantum.c ****                         break;
 2700               		.loc 1 581 0
 2701 049e 8091 0000 		lds r24,keymap_config
 2702 04a2 8064      		ori r24,lo8(1<<6)
 2703 04a4 00C0      		rjmp .L310
 2704               	.L192:
 584:quantum/quantum.c ****                         break;
 2705               		.loc 1 584 0
 2706 04a6 8091 0000 		lds r24,keymap_config
 2707 04aa 8068      		ori r24,lo8(1<<7)
 2708 04ac 00C0      		rjmp .L310
 2709               	.L211:
 593:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2710               		.loc 1 593 0
 2711 04ae 8091 0000 		lds r24,keymap_config+1
 2712 04b2 8260      		ori r24,lo8(2)
 2713 04b4 00C0      		rjmp .L314
 2714               	.L190:
 599:quantum/quantum.c ****                         break;
 2715               		.loc 1 599 0
 2716 04b6 8091 0000 		lds r24,keymap_config
 2717 04ba 8E7F      		andi r24,lo8(~(1<<0))
 2718 04bc 00C0      		rjmp .L310
 2719               	.L194:
 605:quantum/quantum.c ****                         break;
 2720               		.loc 1 605 0
 2721 04be 8091 0000 		lds r24,keymap_config
 2722               	.L317:
 629:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2723               		.loc 1 629 0
 2724 04c2 8B7F      		andi r24,lo8(~(1<<2))
 2725 04c4 00C0      		rjmp .L310
 2726               	.L206:
 614:quantum/quantum.c ****                         break;
 2727               		.loc 1 614 0
 2728 04c6 8091 0000 		lds r24,keymap_config+1
 2729 04ca 8D7F      		andi r24,lo8(~(1<<1))
 2730 04cc 00C0      		rjmp .L311
 2731               	.L179:
 617:quantum/quantum.c ****                         break;
 2732               		.loc 1 617 0
 2733 04ce 8091 0000 		lds r24,keymap_config
 2734 04d2 8F7E      		andi r24,lo8(~(1<<4))
 2735 04d4 00C0      		rjmp .L310
 2736               	.L201:
 620:quantum/quantum.c ****                         break;
 2737               		.loc 1 620 0
 2738 04d6 8091 0000 		lds r24,keymap_config
 2739 04da 8F7D      		andi r24,lo8(~(1<<5))
 2740 04dc 00C0      		rjmp .L310
 2741               	.L199:
 626:quantum/quantum.c ****                         break;
 2742               		.loc 1 626 0
 2743 04de 8091 0000 		lds r24,keymap_config
 2744 04e2 8F77      		andi r24,lo8(~(1<<7))
 2745 04e4 00C0      		rjmp .L310
 2746               	.L204:
 629:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2747               		.loc 1 629 0
 2748 04e6 8091 0000 		lds r24,keymap_config
 2749 04ea 877F      		andi r24,lo8(-9)
 2750 04ec 00C0      		rjmp .L317
 2751               	.L210:
 635:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2752               		.loc 1 635 0
 2753 04ee 8091 0000 		lds r24,keymap_config+1
 2754 04f2 8D7F      		andi r24,lo8(-3)
 2755 04f4 00C0      		rjmp .L315
 2756               	.L203:
 663:quantum/quantum.c ****                         break;
 2757               		.loc 1 663 0
 2758 04f6 9091 0000 		lds r25,keymap_config
 2759 04fa 892F      		mov r24,r25
 2760 04fc 97FB      		bst r25,7
 2761 04fe 87F9      		bld r24,7
 2762 0500 8058      		subi r24,0x80
 2763 0502 00C0      		rjmp .L310
 2764               	.L143:
 2765               	.LBB56:
 676:quantum/quantum.c **** 
 2766               		.loc 1 676 0
 2767 0504 0E94 0000 		call get_mods
 2768               	.LVL262:
 708:quantum/quantum.c ****                 grave_esc_was_shifted = shifted;
 2769               		.loc 1 708 0
 2770 0508 F801      		movw r30,r16
 2771 050a 9281      		ldd r25,Z+2
 2772 050c 9923      		tst r25
 2773 050e 01F0      		breq .L213
 676:quantum/quantum.c **** 
 2774               		.loc 1 676 0
 2775 0510 8A7A      		andi r24,lo8(-86)
 2776               	.LVL263:
 709:quantum/quantum.c ****                 add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 2777               		.loc 1 709 0
 2778 0512 91E0      		ldi r25,lo8(1)
 2779 0514 01F4      		brne .L214
 2780 0516 90E0      		ldi r25,0
 2781               	.L214:
 2782 0518 9093 0000 		sts grave_esc_was_shifted,r25
 710:quantum/quantum.c ****             } else {
 2783               		.loc 1 710 0
 2784 051c 8111      		cpse r24,__zero_reg__
 2785 051e 00C0      		rjmp .L218
 2786 0520 89E2      		ldi r24,lo8(41)
 2787               	.LVL264:
 2788               	.L215:
 710:quantum/quantum.c ****             } else {
 2789               		.loc 1 710 0 is_stmt 0 discriminator 4
 2790 0522 0E94 0000 		call add_key
 2791               	.LVL265:
 2792               	.L216:
 715:quantum/quantum.c ****             return false;
 2793               		.loc 1 715 0 is_stmt 1
 2794 0526 0E94 0000 		call send_keyboard_report
 2795               	.LVL266:
 716:quantum/quantum.c ****         }
 2796               		.loc 1 716 0
 2797 052a 00C0      		rjmp .L130
 2798               	.LVL267:
 2799               	.L218:
 710:quantum/quantum.c ****             } else {
 2800               		.loc 1 710 0
 2801 052c 85E3      		ldi r24,lo8(53)
 2802               	.LVL268:
 2803 052e 00C0      		rjmp .L215
 2804               	.LVL269:
 2805               	.L213:
 712:quantum/quantum.c ****             }
 2806               		.loc 1 712 0
 2807 0530 8091 0000 		lds r24,grave_esc_was_shifted
 2808               	.LVL270:
 2809 0534 8111      		cpse r24,__zero_reg__
 2810 0536 00C0      		rjmp .L219
 2811 0538 89E2      		ldi r24,lo8(41)
 2812               	.L217:
 712:quantum/quantum.c ****             }
 2813               		.loc 1 712 0 is_stmt 0 discriminator 4
 2814 053a 0E94 0000 		call del_key
 2815               	.LVL271:
 2816 053e 00C0      		rjmp .L216
 2817               	.L219:
 712:quantum/quantum.c ****             }
 2818               		.loc 1 712 0
 2819 0540 85E3      		ldi r24,lo8(53)
 2820 0542 00C0      		rjmp .L217
 2821               	.LBE56:
 2822               		.cfi_endproc
 2823               	.LFE33:
 2825               		.weak	ascii_to_keycode_lut
 2826               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2829               	ascii_to_keycode_lut:
 2830 0000 00        		.byte	0
 2831 0001 00        		.byte	0
 2832 0002 00        		.byte	0
 2833 0003 00        		.byte	0
 2834 0004 00        		.byte	0
 2835 0005 00        		.byte	0
 2836 0006 00        		.byte	0
 2837 0007 00        		.byte	0
 2838 0008 2A        		.byte	42
 2839 0009 2B        		.byte	43
 2840 000a 28        		.byte	40
 2841 000b 00        		.byte	0
 2842 000c 00        		.byte	0
 2843 000d 00        		.byte	0
 2844 000e 00        		.byte	0
 2845 000f 00        		.byte	0
 2846 0010 00        		.byte	0
 2847 0011 00        		.byte	0
 2848 0012 00        		.byte	0
 2849 0013 00        		.byte	0
 2850 0014 00        		.byte	0
 2851 0015 00        		.byte	0
 2852 0016 00        		.byte	0
 2853 0017 00        		.byte	0
 2854 0018 00        		.byte	0
 2855 0019 00        		.byte	0
 2856 001a 00        		.byte	0
 2857 001b 29        		.byte	41
 2858 001c 00        		.byte	0
 2859 001d 00        		.byte	0
 2860 001e 00        		.byte	0
 2861 001f 00        		.byte	0
 2862 0020 2C        		.byte	44
 2863 0021 1E        		.byte	30
 2864 0022 34        		.byte	52
 2865 0023 20        		.byte	32
 2866 0024 21        		.byte	33
 2867 0025 22        		.byte	34
 2868 0026 24        		.byte	36
 2869 0027 34        		.byte	52
 2870 0028 26        		.byte	38
 2871 0029 27        		.byte	39
 2872 002a 25        		.byte	37
 2873 002b 2E        		.byte	46
 2874 002c 36        		.byte	54
 2875 002d 2D        		.byte	45
 2876 002e 37        		.byte	55
 2877 002f 38        		.byte	56
 2878 0030 27        		.byte	39
 2879 0031 1E        		.byte	30
 2880 0032 1F        		.byte	31
 2881 0033 20        		.byte	32
 2882 0034 21        		.byte	33
 2883 0035 22        		.byte	34
 2884 0036 23        		.byte	35
 2885 0037 24        		.byte	36
 2886 0038 25        		.byte	37
 2887 0039 26        		.byte	38
 2888 003a 33        		.byte	51
 2889 003b 33        		.byte	51
 2890 003c 36        		.byte	54
 2891 003d 2E        		.byte	46
 2892 003e 37        		.byte	55
 2893 003f 38        		.byte	56
 2894 0040 1F        		.byte	31
 2895 0041 04        		.byte	4
 2896 0042 05        		.byte	5
 2897 0043 06        		.byte	6
 2898 0044 07        		.byte	7
 2899 0045 08        		.byte	8
 2900 0046 09        		.byte	9
 2901 0047 0A        		.byte	10
 2902 0048 0B        		.byte	11
 2903 0049 0C        		.byte	12
 2904 004a 0D        		.byte	13
 2905 004b 0E        		.byte	14
 2906 004c 0F        		.byte	15
 2907 004d 10        		.byte	16
 2908 004e 11        		.byte	17
 2909 004f 12        		.byte	18
 2910 0050 13        		.byte	19
 2911 0051 14        		.byte	20
 2912 0052 15        		.byte	21
 2913 0053 16        		.byte	22
 2914 0054 17        		.byte	23
 2915 0055 18        		.byte	24
 2916 0056 19        		.byte	25
 2917 0057 1A        		.byte	26
 2918 0058 1B        		.byte	27
 2919 0059 1C        		.byte	28
 2920 005a 1D        		.byte	29
 2921 005b 2F        		.byte	47
 2922 005c 31        		.byte	49
 2923 005d 30        		.byte	48
 2924 005e 23        		.byte	35
 2925 005f 2D        		.byte	45
 2926 0060 35        		.byte	53
 2927 0061 04        		.byte	4
 2928 0062 05        		.byte	5
 2929 0063 06        		.byte	6
 2930 0064 07        		.byte	7
 2931 0065 08        		.byte	8
 2932 0066 09        		.byte	9
 2933 0067 0A        		.byte	10
 2934 0068 0B        		.byte	11
 2935 0069 0C        		.byte	12
 2936 006a 0D        		.byte	13
 2937 006b 0E        		.byte	14
 2938 006c 0F        		.byte	15
 2939 006d 10        		.byte	16
 2940 006e 11        		.byte	17
 2941 006f 12        		.byte	18
 2942 0070 13        		.byte	19
 2943 0071 14        		.byte	20
 2944 0072 15        		.byte	21
 2945 0073 16        		.byte	22
 2946 0074 17        		.byte	23
 2947 0075 18        		.byte	24
 2948 0076 19        		.byte	25
 2949 0077 1A        		.byte	26
 2950 0078 1B        		.byte	27
 2951 0079 1C        		.byte	28
 2952 007a 1D        		.byte	29
 2953 007b 2F        		.byte	47
 2954 007c 31        		.byte	49
 2955 007d 30        		.byte	48
 2956 007e 35        		.byte	53
 2957 007f 4C        		.byte	76
 2958               		.weak	ascii_to_altgr_lut
 2959               		.section	.progmem.data.ascii_to_altgr_lut,"a",@progbits
 2962               	ascii_to_altgr_lut:
 2963 0000 0000 0000 		.zero	128
 2963      0000 0000 
 2963      0000 0000 
 2963      0000 0000 
 2963      0000 0000 
 2964               		.weak	ascii_to_shift_lut
 2965               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2968               	ascii_to_shift_lut:
 2969 0000 00        		.byte	0
 2970 0001 00        		.byte	0
 2971 0002 00        		.byte	0
 2972 0003 00        		.byte	0
 2973 0004 00        		.byte	0
 2974 0005 00        		.byte	0
 2975 0006 00        		.byte	0
 2976 0007 00        		.byte	0
 2977 0008 00        		.byte	0
 2978 0009 00        		.byte	0
 2979 000a 00        		.byte	0
 2980 000b 00        		.byte	0
 2981 000c 00        		.byte	0
 2982 000d 00        		.byte	0
 2983 000e 00        		.byte	0
 2984 000f 00        		.byte	0
 2985 0010 00        		.byte	0
 2986 0011 00        		.byte	0
 2987 0012 00        		.byte	0
 2988 0013 00        		.byte	0
 2989 0014 00        		.byte	0
 2990 0015 00        		.byte	0
 2991 0016 00        		.byte	0
 2992 0017 00        		.byte	0
 2993 0018 00        		.byte	0
 2994 0019 00        		.byte	0
 2995 001a 00        		.byte	0
 2996 001b 00        		.byte	0
 2997 001c 00        		.byte	0
 2998 001d 00        		.byte	0
 2999 001e 00        		.byte	0
 3000 001f 00        		.byte	0
 3001 0020 00        		.byte	0
 3002 0021 01        		.byte	1
 3003 0022 01        		.byte	1
 3004 0023 01        		.byte	1
 3005 0024 01        		.byte	1
 3006 0025 01        		.byte	1
 3007 0026 01        		.byte	1
 3008 0027 00        		.byte	0
 3009 0028 01        		.byte	1
 3010 0029 01        		.byte	1
 3011 002a 01        		.byte	1
 3012 002b 01        		.byte	1
 3013 002c 00        		.byte	0
 3014 002d 00        		.byte	0
 3015 002e 00        		.byte	0
 3016 002f 00        		.byte	0
 3017 0030 00        		.byte	0
 3018 0031 00        		.byte	0
 3019 0032 00        		.byte	0
 3020 0033 00        		.byte	0
 3021 0034 00        		.byte	0
 3022 0035 00        		.byte	0
 3023 0036 00        		.byte	0
 3024 0037 00        		.byte	0
 3025 0038 00        		.byte	0
 3026 0039 00        		.byte	0
 3027 003a 01        		.byte	1
 3028 003b 00        		.byte	0
 3029 003c 01        		.byte	1
 3030 003d 00        		.byte	0
 3031 003e 01        		.byte	1
 3032 003f 01        		.byte	1
 3033 0040 01        		.byte	1
 3034 0041 01        		.byte	1
 3035 0042 01        		.byte	1
 3036 0043 01        		.byte	1
 3037 0044 01        		.byte	1
 3038 0045 01        		.byte	1
 3039 0046 01        		.byte	1
 3040 0047 01        		.byte	1
 3041 0048 01        		.byte	1
 3042 0049 01        		.byte	1
 3043 004a 01        		.byte	1
 3044 004b 01        		.byte	1
 3045 004c 01        		.byte	1
 3046 004d 01        		.byte	1
 3047 004e 01        		.byte	1
 3048 004f 01        		.byte	1
 3049 0050 01        		.byte	1
 3050 0051 01        		.byte	1
 3051 0052 01        		.byte	1
 3052 0053 01        		.byte	1
 3053 0054 01        		.byte	1
 3054 0055 01        		.byte	1
 3055 0056 01        		.byte	1
 3056 0057 01        		.byte	1
 3057 0058 01        		.byte	1
 3058 0059 01        		.byte	1
 3059 005a 01        		.byte	1
 3060 005b 00        		.byte	0
 3061 005c 00        		.byte	0
 3062 005d 00        		.byte	0
 3063 005e 01        		.byte	1
 3064 005f 01        		.byte	1
 3065 0060 00        		.byte	0
 3066 0061 00        		.byte	0
 3067 0062 00        		.byte	0
 3068 0063 00        		.byte	0
 3069 0064 00        		.byte	0
 3070 0065 00        		.byte	0
 3071 0066 00        		.byte	0
 3072 0067 00        		.byte	0
 3073 0068 00        		.byte	0
 3074 0069 00        		.byte	0
 3075 006a 00        		.byte	0
 3076 006b 00        		.byte	0
 3077 006c 00        		.byte	0
 3078 006d 00        		.byte	0
 3079 006e 00        		.byte	0
 3080 006f 00        		.byte	0
 3081 0070 00        		.byte	0
 3082 0071 00        		.byte	0
 3083 0072 00        		.byte	0
 3084 0073 00        		.byte	0
 3085 0074 00        		.byte	0
 3086 0075 00        		.byte	0
 3087 0076 00        		.byte	0
 3088 0077 00        		.byte	0
 3089 0078 00        		.byte	0
 3090 0079 00        		.byte	0
 3091 007a 00        		.byte	0
 3092 007b 01        		.byte	1
 3093 007c 01        		.byte	1
 3094 007d 01        		.byte	1
 3095 007e 01        		.byte	1
 3096 007f 00        		.byte	0
 3097               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 3100               	grave_esc_was_shifted:
 3101 0000 00        		.zero	1
 3102               		.text
 3103               	.Letext0:
 3104               		.file 3 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdint.h"
 3105               		.file 4 "/usr/local/Cellar/avr-gcc@7/7.4.0/lib/avr-gcc/7/gcc/avr/7.4.0/include/stddef.h"
 3106               		.file 5 "tmk_core/common/keyboard.h"
 3107               		.file 6 "tmk_core/common/action.h"
 3108               		.file 7 "tmk_core/common/report.h"
 3109               		.file 8 "tmk_core/common/host.h"
 3110               		.file 9 "tmk_core/common/debug.h"
 3111               		.file 10 "quantum/keycode_config.h"
 3112               		.file 11 "tmk_core/common/keycode.h"
 3113               		.file 12 "quantum/quantum_keycodes.h"
 3114               		.file 13 "quantum/keymap.h"
 3115               		.file 14 "quantum/rgblight.h"
 3116               		.file 15 "./quantum/color.h"
 3117               		.file 16 "tmk_core/common/action_layer.h"
 3118               		.file 17 "tmk_core/common/timer.h"
 3119               		.file 18 "tmk_core/common/action_util.h"
 3120               		.file 19 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdlib.h"
 3121               		.file 20 "quantum/quantum.h"
 3122               		.file 21 "tmk_core/protocol/lufa/outputselect.h"
 3123               		.file 22 "tmk_core/common/backlight.h"
 3124               		.file 23 "tmk_core/common/eeconfig.h"
 3125               		.file 24 "tmk_core/common/matrix.h"
 3126               		.file 25 "tmk_core/common/bootloader.h"
 3127               		.file 26 "quantum/process_keycode/process_space_cadet.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
/var/tmp//cc8EwVcp.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//cc8EwVcp.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//cc8EwVcp.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//cc8EwVcp.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//cc8EwVcp.s:6      *ABS*:0000000000000001 __zero_reg__
/var/tmp//cc8EwVcp.s:12     .text.do_code16:0000000000000000 do_code16
/var/tmp//cc8EwVcp.s:132    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
/var/tmp//cc8EwVcp.s:162    .text.qk_register_mods:0000000000000000 qk_register_mods
/var/tmp//cc8EwVcp.s:175    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
/var/tmp//cc8EwVcp.s:205    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
/var/tmp//cc8EwVcp.s:219    .text.register_code16:0000000000000000 register_code16
/var/tmp//cc8EwVcp.s:275    .text.unregister_code16:0000000000000000 unregister_code16
/var/tmp//cc8EwVcp.s:329    .text.tap_code16:0000000000000000 tap_code16
/var/tmp//cc8EwVcp.s:366    .text.process_action_kb:0000000000000000 process_action_kb
/var/tmp//cc8EwVcp.s:386    .text.process_record_user:0000000000000000 process_record_user
/var/tmp//cc8EwVcp.s:406    .text.process_record_kb:0000000000000000 process_record_kb
/var/tmp//cc8EwVcp.s:424    .text.get_event_keycode:0000000000000000 get_event_keycode
/var/tmp//cc8EwVcp.s:521    .text.get_record_keycode:0000000000000000 get_record_keycode
/var/tmp//cc8EwVcp.s:546    .text.send_char:0000000000000000 send_char
/var/tmp//cc8EwVcp.s:2829   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
/var/tmp//cc8EwVcp.s:2968   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
/var/tmp//cc8EwVcp.s:2962   .progmem.data.ascii_to_altgr_lut:0000000000000000 ascii_to_altgr_lut
/var/tmp//cc8EwVcp.s:674    .text.send_string_with_delay:0000000000000000 send_string_with_delay
/var/tmp//cc8EwVcp.s:820    .text.send_string:0000000000000000 send_string
/var/tmp//cc8EwVcp.s:839    .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
/var/tmp//cc8EwVcp.s:1017   .text.send_string_P:0000000000000000 send_string_P
/var/tmp//cc8EwVcp.s:1036   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
/var/tmp//cc8EwVcp.s:1084   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
/var/tmp//cc8EwVcp.s:1241   .text.update_tri_layer:0000000000000000 update_tri_layer
/var/tmp//cc8EwVcp.s:1278   .text.tap_random_base64:0000000000000000 tap_random_base64
/var/tmp//cc8EwVcp.s:1404   .text.bootmagic_lite:0000000000000000 bootmagic_lite
/var/tmp//cc8EwVcp.s:1452   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/tmp//cc8EwVcp.s:1478   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/tmp//cc8EwVcp.s:1495   .text.backlight_init_ports:0000000000000000 backlight_init_ports
/var/tmp//cc8EwVcp.s:1510   .text.send_nibble:0000000000000000 send_nibble
/var/tmp//cc8EwVcp.s:1573   .text.send_byte:0000000000000000 send_byte
/var/tmp//cc8EwVcp.s:1610   .text.send_word:0000000000000000 send_word
/var/tmp//cc8EwVcp.s:1644   .text.send_dword:0000000000000000 send_dword
/var/tmp//cc8EwVcp.s:1690   .text.hex_to_keycode:0000000000000000 hex_to_keycode
/var/tmp//cc8EwVcp.s:1730   .text.api_send_unicode:0000000000000000 api_send_unicode
/var/tmp//cc8EwVcp.s:1748   .text.led_set_user:0000000000000000 led_set_user
/var/tmp//cc8EwVcp.s:1748   .text.led_set_user:0000000000000000 led_set_user.localalias.1
/var/tmp//cc8EwVcp.s:1767   .text.backlight_set:0000000000000000 backlight_set
/var/tmp//cc8EwVcp.s:1782   .text.led_set_kb:0000000000000000 led_set_kb
/var/tmp//cc8EwVcp.s:1800   .text.led_init_ports:0000000000000000 led_init_ports
/var/tmp//cc8EwVcp.s:1817   .text.led_set:0000000000000000 led_set
/var/tmp//cc8EwVcp.s:1835   .text.startup_user:0000000000000000 startup_user
/var/tmp//cc8EwVcp.s:1850   .text.shutdown_user:0000000000000000 shutdown_user
/var/tmp//cc8EwVcp.s:1865   .text.reset_keyboard:0000000000000000 reset_keyboard
/var/tmp//cc8EwVcp.s:1908   .text.process_record_quantum:0000000000000000 process_record_quantum
/var/tmp//cc8EwVcp.s:3100   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
keymap_key_to_keycode
read_source_layers_cache
tap_code
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan
matrix_get_row
eeconfig_disable
bootloader_jump
eeconfig_is_enabled
eeconfig_init
matrix_init_kb
matrix_scan_kb
clear_keyboard
process_space_cadet
rgblight_toggle
rgblight_decrease_hue
rgblight_decrease_val
rgblight_get_mode
set_output
eeconfig_read_keymap
keymap_config
eeconfig_update_keymap
debug_config
get_mods
rgblight_step_reverse
rgblight_step
rgblight_increase_hue
rgblight_increase_sat
rgblight_decrease_sat
rgblight_increase_val
rgblight_increase_speed
rgblight_decrease_speed
rgblight_mode
add_key
del_key
__do_clear_bss

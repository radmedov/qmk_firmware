   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB106:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #    include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #    include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #    include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  48:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  49:tmk_core/common/action.c **** #endif
  50:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  51:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** /** \brief Called to execute an action.
  54:tmk_core/common/action.c ****  *
  55:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  56:tmk_core/common/action.c ****  */
  57:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 57 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  58:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  59:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  60:tmk_core/common/action.c ****         dprint("EVENT: ");
  61:tmk_core/common/action.c ****         debug_event(event);
  62:tmk_core/common/action.c ****         dprintln();
  63:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  64:tmk_core/common/action.c ****         retro_tapping_counter++;
  65:tmk_core/common/action.c **** #endif
  66:tmk_core/common/action.c ****     }
  67:tmk_core/common/action.c **** 
  68:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  69:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  70:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  71:tmk_core/common/action.c ****     }
  72:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  73:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c ****     fauxclicky_check();
  76:tmk_core/common/action.c **** #endif
  77:tmk_core/common/action.c **** 
  78:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  79:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  80:tmk_core/common/action.c ****         process_hand_swap(&event);
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c **** #endif
  83:tmk_core/common/action.c **** 
  84:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  48               		.loc 1 84 0
  49 001e 1E82      		std Y+6,__zero_reg__
  50 0020 1D82      		std Y+5,__zero_reg__
  51 0022 85E0      		ldi r24,lo8(5)
  52 0024 FE01      		movw r30,r28
  53 0026 3796      		adiw r30,7
  54 0028 DE01      		movw r26,r28
  55 002a 1196      		adiw r26,1
  56               		0:
  57 002c 0190      		ld r0,Z+
  58 002e 0D92      		st X+,r0
  59 0030 8A95      		dec r24
  60 0032 01F4      		brne 0b
  85:tmk_core/common/action.c **** 
  86:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  87:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  88:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  89:tmk_core/common/action.c ****     }
  90:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  91:tmk_core/common/action.c ****         clear_oneshot_mods();
  92:tmk_core/common/action.c ****     }
  93:tmk_core/common/action.c **** #endif
  94:tmk_core/common/action.c **** 
  95:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  96:tmk_core/common/action.c ****     action_tapping_process(record);
  61               		.loc 1 96 0
  62 0034 4981      		ldd r20,Y+1
  63               	.LVL1:
  64 0036 5A81      		ldd r21,Y+2
  65               	.LVL2:
  66 0038 6B81      		ldd r22,Y+3
  67 003a 7C81      		ldd r23,Y+4
  68 003c 8D81      		ldd r24,Y+5
  69 003e 9E81      		ldd r25,Y+6
  70               	/* epilogue start */
  97:tmk_core/common/action.c **** #else
  98:tmk_core/common/action.c ****     process_record(&record);
  99:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 100:tmk_core/common/action.c ****         dprint("processed: ");
 101:tmk_core/common/action.c ****         debug_record(record);
 102:tmk_core/common/action.c ****         dprintln();
 103:tmk_core/common/action.c ****     }
 104:tmk_core/common/action.c **** #endif
 105:tmk_core/common/action.c **** }
  71               		.loc 1 105 0
  72 0040 2B96      		adiw r28,11
  73 0042 0FB6      		in __tmp_reg__,__SREG__
  74 0044 F894      		cli
  75 0046 DEBF      		out __SP_H__,r29
  76 0048 0FBE      		out __SREG__,__tmp_reg__
  77 004a CDBF      		out __SP_L__,r28
  78 004c DF91      		pop r29
  79 004e CF91      		pop r28
  96:tmk_core/common/action.c **** #else
  80               		.loc 1 96 0
  81 0050 0C94 0000 		jmp action_tapping_process
  82               	.LVL3:
  83               		.cfi_endproc
  84               	.LFE106:
  86               		.section	.text.process_record_quantum,"ax",@progbits
  87               		.weak	process_record_quantum
  89               	process_record_quantum:
  90               	.LFB108:
 106:tmk_core/common/action.c **** 
 107:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 108:tmk_core/common/action.c **** bool swap_hands = false;
 109:tmk_core/common/action.c **** bool swap_held  = false;
 110:tmk_core/common/action.c **** 
 111:tmk_core/common/action.c **** /** \brief Process Hand Swap
 112:tmk_core/common/action.c ****  *
 113:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 114:tmk_core/common/action.c ****  */
 115:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 116:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 117:tmk_core/common/action.c **** 
 118:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 119:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 120:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 121:tmk_core/common/action.c **** 
 122:tmk_core/common/action.c ****     if (do_swap) {
 123:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 124:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 125:tmk_core/common/action.c ****     } else {
 126:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 127:tmk_core/common/action.c ****     }
 128:tmk_core/common/action.c **** }
 129:tmk_core/common/action.c **** #endif
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 132:tmk_core/common/action.c **** bool disable_action_cache = false;
 133:tmk_core/common/action.c **** 
 134:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 135:tmk_core/common/action.c ****     disable_action_cache = true;
 136:tmk_core/common/action.c ****     process_record(record);
 137:tmk_core/common/action.c ****     disable_action_cache = false;
 138:tmk_core/common/action.c **** }
 139:tmk_core/common/action.c **** #else
 140:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 141:tmk_core/common/action.c **** #endif
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  91               		.loc 1 143 0
  92               		.cfi_startproc
  93               	.LVL4:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  98               		.loc 1 143 0
  99 0000 81E0      		ldi r24,lo8(1)
 100               	.LVL5:
 101               	/* epilogue start */
 102 0002 0895      		ret
 103               		.cfi_endproc
 104               	.LFE108:
 106               		.section	.text.process_record_tap_hint,"ax",@progbits
 107               	.global	process_record_tap_hint
 109               	process_record_tap_hint:
 110               	.LFB109:
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 146:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 147:tmk_core/common/action.c ****  *
 148:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 149:tmk_core/common/action.c ****  */
 150:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 111               		.loc 1 150 0
 112               		.cfi_startproc
 113               	.LVL6:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
 151:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 118               		.loc 1 151 0
 119 0000 FC01      		movw r30,r24
 120 0002 8081      		ld r24,Z
 121 0004 9181      		ldd r25,Z+1
 122               	.LVL7:
 123 0006 0C94 0000 		jmp layer_switch_get_action
 124               	.LVL8:
 125               		.cfi_endproc
 126               	.LFE109:
 128               		.section	.text.register_code,"ax",@progbits
 129               	.global	register_code
 131               	register_code:
 132               	.LFB112:
 152:tmk_core/common/action.c **** 
 153:tmk_core/common/action.c ****     switch (action.kind.id) {
 154:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 155:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:tmk_core/common/action.c ****             switch (action.swap.code) {
 157:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:tmk_core/common/action.c ****                 default:
 159:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:tmk_core/common/action.c ****                     swap_held  = true;
 161:tmk_core/common/action.c ****             }
 162:tmk_core/common/action.c ****             break;
 163:tmk_core/common/action.c **** #    endif
 164:tmk_core/common/action.c ****     }
 165:tmk_core/common/action.c **** }
 166:tmk_core/common/action.c **** #endif
 167:tmk_core/common/action.c **** 
 168:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:tmk_core/common/action.c ****  *
 170:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:tmk_core/common/action.c ****  */
 172:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 173:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 174:tmk_core/common/action.c ****         return;
 175:tmk_core/common/action.c ****     }
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:tmk_core/common/action.c ****     dprint("ACTION: ");
 181:tmk_core/common/action.c ****     debug_action(action);
 182:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 183:tmk_core/common/action.c ****     dprint(" layer_state: ");
 184:tmk_core/common/action.c ****     layer_debug();
 185:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 186:tmk_core/common/action.c ****     default_layer_debug();
 187:tmk_core/common/action.c **** #endif
 188:tmk_core/common/action.c ****     dprintln();
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c ****     process_action(record, action);
 191:tmk_core/common/action.c **** }
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 194:tmk_core/common/action.c ****  *
 195:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 196:tmk_core/common/action.c ****  */
 197:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 198:tmk_core/common/action.c ****     keyevent_t event = record->event;
 199:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 200:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 201:tmk_core/common/action.c **** #endif
 202:tmk_core/common/action.c **** 
 203:tmk_core/common/action.c ****     if (event.pressed) {
 204:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 205:tmk_core/common/action.c ****         clear_weak_mods();
 206:tmk_core/common/action.c ****     }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 209:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 210:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 211:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 212:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 213:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 214:tmk_core/common/action.c ****     }
 215:tmk_core/common/action.c **** #endif
 216:tmk_core/common/action.c **** 
 217:tmk_core/common/action.c ****     switch (action.kind.id) {
 218:tmk_core/common/action.c ****         /* Key and Mods */
 219:tmk_core/common/action.c ****         case ACT_LMODS:
 220:tmk_core/common/action.c ****         case ACT_RMODS: {
 221:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 222:tmk_core/common/action.c ****             if (event.pressed) {
 223:tmk_core/common/action.c ****                 if (mods) {
 224:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 226:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 227:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 228:tmk_core/common/action.c ****                         add_mods(mods);
 229:tmk_core/common/action.c ****                     } else {
 230:tmk_core/common/action.c ****                         add_weak_mods(mods);
 231:tmk_core/common/action.c ****                     }
 232:tmk_core/common/action.c ****                     send_keyboard_report();
 233:tmk_core/common/action.c ****                 }
 234:tmk_core/common/action.c ****                 register_code(action.key.code);
 235:tmk_core/common/action.c ****             } else {
 236:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 237:tmk_core/common/action.c ****                 if (mods) {
 238:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:tmk_core/common/action.c ****                         del_mods(mods);
 240:tmk_core/common/action.c ****                     } else {
 241:tmk_core/common/action.c ****                         del_weak_mods(mods);
 242:tmk_core/common/action.c ****                     }
 243:tmk_core/common/action.c ****                     send_keyboard_report();
 244:tmk_core/common/action.c ****                 }
 245:tmk_core/common/action.c ****             }
 246:tmk_core/common/action.c ****         } break;
 247:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 248:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 249:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 250:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 251:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 252:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 253:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 254:tmk_core/common/action.c ****                     // Oneshot modifier
 255:tmk_core/common/action.c ****                     if (event.pressed) {
 256:tmk_core/common/action.c ****                         if (tap_count == 0) {
 257:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 258:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 259:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 260:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 261:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 263:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 264:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 265:tmk_core/common/action.c ****                             clear_oneshot_mods();
 266:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 267:tmk_core/common/action.c ****                             register_mods(mods);
 268:tmk_core/common/action.c **** #        endif
 269:tmk_core/common/action.c ****                         } else {
 270:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 271:tmk_core/common/action.c ****                         }
 272:tmk_core/common/action.c ****                     } else {
 273:tmk_core/common/action.c ****                         if (tap_count == 0) {
 274:tmk_core/common/action.c ****                             clear_oneshot_mods();
 275:tmk_core/common/action.c ****                             unregister_mods(mods);
 276:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 277:tmk_core/common/action.c ****                             // Retain Oneshot mods
 278:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 279:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 280:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 281:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 282:tmk_core/common/action.c ****                                 unregister_mods(mods);
 283:tmk_core/common/action.c ****                             }
 284:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 285:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 286:tmk_core/common/action.c **** #        endif
 287:tmk_core/common/action.c ****                         } else {
 288:tmk_core/common/action.c ****                             clear_oneshot_mods();
 289:tmk_core/common/action.c ****                             unregister_mods(mods);
 290:tmk_core/common/action.c ****                         }
 291:tmk_core/common/action.c ****                     }
 292:tmk_core/common/action.c ****                     break;
 293:tmk_core/common/action.c **** #    endif
 294:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 295:tmk_core/common/action.c ****                     if (event.pressed) {
 296:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 297:tmk_core/common/action.c ****                             register_mods(mods);
 298:tmk_core/common/action.c ****                         }
 299:tmk_core/common/action.c ****                     } else {
 300:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 301:tmk_core/common/action.c ****                             unregister_mods(mods);
 302:tmk_core/common/action.c ****                         }
 303:tmk_core/common/action.c ****                     }
 304:tmk_core/common/action.c ****                     break;
 305:tmk_core/common/action.c ****                 default:
 306:tmk_core/common/action.c ****                     if (event.pressed) {
 307:tmk_core/common/action.c ****                         if (tap_count > 0) {
 308:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 309:tmk_core/common/action.c ****                             if (record->tap.interrupted) {
 310:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 311:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 312:tmk_core/common/action.c ****                                 record->tap.count = 0;
 313:tmk_core/common/action.c ****                                 register_mods(mods);
 314:tmk_core/common/action.c ****                             } else
 315:tmk_core/common/action.c **** #    endif
 316:tmk_core/common/action.c ****                             {
 317:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 318:tmk_core/common/action.c ****                                 register_code(action.key.code);
 319:tmk_core/common/action.c ****                             }
 320:tmk_core/common/action.c ****                         } else {
 321:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 322:tmk_core/common/action.c ****                             register_mods(mods);
 323:tmk_core/common/action.c ****                         }
 324:tmk_core/common/action.c ****                     } else {
 325:tmk_core/common/action.c ****                         if (tap_count > 0) {
 326:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 327:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 328:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 329:tmk_core/common/action.c ****                             }
 330:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 331:tmk_core/common/action.c ****                         } else {
 332:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 333:tmk_core/common/action.c ****                             unregister_mods(mods);
 334:tmk_core/common/action.c ****                         }
 335:tmk_core/common/action.c ****                     }
 336:tmk_core/common/action.c ****                     break;
 337:tmk_core/common/action.c ****             }
 338:tmk_core/common/action.c ****         } break;
 339:tmk_core/common/action.c **** #endif
 340:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 341:tmk_core/common/action.c ****         /* other HID usage */
 342:tmk_core/common/action.c ****         case ACT_USAGE:
 343:tmk_core/common/action.c ****             switch (action.usage.page) {
 344:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 345:tmk_core/common/action.c ****                     if (event.pressed) {
 346:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 347:tmk_core/common/action.c ****                     } else {
 348:tmk_core/common/action.c ****                         host_system_send(0);
 349:tmk_core/common/action.c ****                     }
 350:tmk_core/common/action.c ****                     break;
 351:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 352:tmk_core/common/action.c ****                     if (event.pressed) {
 353:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 354:tmk_core/common/action.c ****                     } else {
 355:tmk_core/common/action.c ****                         host_consumer_send(0);
 356:tmk_core/common/action.c ****                     }
 357:tmk_core/common/action.c ****                     break;
 358:tmk_core/common/action.c ****             }
 359:tmk_core/common/action.c ****             break;
 360:tmk_core/common/action.c **** #endif
 361:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 362:tmk_core/common/action.c ****         /* Mouse key */
 363:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 364:tmk_core/common/action.c ****             if (event.pressed) {
 365:tmk_core/common/action.c ****                 switch (action.key.code) {
 366:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 367:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 368:tmk_core/common/action.c ****                         break;
 369:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 370:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 371:tmk_core/common/action.c ****                         break;
 372:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 373:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 374:tmk_core/common/action.c ****                         break;
 375:tmk_core/common/action.c ****                     default:
 376:tmk_core/common/action.c ****                         break;
 377:tmk_core/common/action.c ****                 }
 378:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 379:tmk_core/common/action.c ****                 mousekey_send();
 380:tmk_core/common/action.c ****             } else {
 381:tmk_core/common/action.c ****                 switch (action.key.code) {
 382:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 383:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 384:tmk_core/common/action.c ****                         break;
 385:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 386:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 389:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 390:tmk_core/common/action.c ****                         break;
 391:tmk_core/common/action.c ****                     default:
 392:tmk_core/common/action.c ****                         break;
 393:tmk_core/common/action.c ****                 }
 394:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 395:tmk_core/common/action.c ****                 mousekey_send();
 396:tmk_core/common/action.c ****             }
 397:tmk_core/common/action.c ****             break;
 398:tmk_core/common/action.c **** #endif
 399:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 400:tmk_core/common/action.c ****         case ACT_LAYER:
 401:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 402:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 403:tmk_core/common/action.c ****                 if (!event.pressed) {
 404:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 405:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 406:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 407:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 408:tmk_core/common/action.c ****                         case OP_BIT_AND:
 409:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 410:tmk_core/common/action.c ****                             break;
 411:tmk_core/common/action.c ****                         case OP_BIT_OR:
 412:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 413:tmk_core/common/action.c ****                             break;
 414:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 415:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 416:tmk_core/common/action.c ****                             break;
 417:tmk_core/common/action.c ****                         case OP_BIT_SET:
 418:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 419:tmk_core/common/action.c ****                             break;
 420:tmk_core/common/action.c ****                     }
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 424:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 425:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 426:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 427:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 428:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 429:tmk_core/common/action.c ****                         case OP_BIT_AND:
 430:tmk_core/common/action.c ****                             layer_and(bits | mask);
 431:tmk_core/common/action.c ****                             break;
 432:tmk_core/common/action.c ****                         case OP_BIT_OR:
 433:tmk_core/common/action.c ****                             layer_or(bits | mask);
 434:tmk_core/common/action.c ****                             break;
 435:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 436:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 437:tmk_core/common/action.c ****                             break;
 438:tmk_core/common/action.c ****                         case OP_BIT_SET:
 439:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 440:tmk_core/common/action.c ****                             break;
 441:tmk_core/common/action.c ****                     }
 442:tmk_core/common/action.c ****                 }
 443:tmk_core/common/action.c ****             }
 444:tmk_core/common/action.c ****             break;
 445:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 446:tmk_core/common/action.c ****             if (event.pressed) {
 447:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 448:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 449:tmk_core/common/action.c ****             } else {
 450:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 451:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 452:tmk_core/common/action.c ****             }
 453:tmk_core/common/action.c ****             break;
 454:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 455:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 456:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 457:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 458:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 459:tmk_core/common/action.c ****                     /* tap toggle */
 460:tmk_core/common/action.c ****                     if (event.pressed) {
 461:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 462:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 463:tmk_core/common/action.c ****                         }
 464:tmk_core/common/action.c ****                     } else {
 465:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 466:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 467:tmk_core/common/action.c ****                         }
 468:tmk_core/common/action.c ****                     }
 469:tmk_core/common/action.c ****                     break;
 470:tmk_core/common/action.c ****                 case OP_ON_OFF:
 471:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_OFF_ON:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 475:tmk_core/common/action.c ****                     break;
 476:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 477:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 478:tmk_core/common/action.c ****                     break;
 479:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 480:tmk_core/common/action.c ****                 case OP_ONESHOT:
 481:tmk_core/common/action.c ****                     // Oneshot modifier
 482:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 483:tmk_core/common/action.c ****                     do_release_oneshot = false;
 484:tmk_core/common/action.c ****                     if (event.pressed) {
 485:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 486:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 487:tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 489:tmk_core/common/action.c ****                             break;
 490:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 491:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 492:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 493:tmk_core/common/action.c ****                         }
 494:tmk_core/common/action.c ****                     } else {
 495:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 496:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 497:tmk_core/common/action.c ****                             reset_oneshot_layer();
 498:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 499:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 500:tmk_core/common/action.c ****                         } else {
 501:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 502:tmk_core/common/action.c ****                         }
 503:tmk_core/common/action.c ****                     }
 504:tmk_core/common/action.c **** #            else
 505:tmk_core/common/action.c ****                     if (event.pressed) {
 506:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 510:tmk_core/common/action.c ****                         if (tap_count > 1) {
 511:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 512:tmk_core/common/action.c ****                         }
 513:tmk_core/common/action.c ****                     }
 514:tmk_core/common/action.c **** #            endif
 515:tmk_core/common/action.c ****                     break;
 516:tmk_core/common/action.c **** #        endif
 517:tmk_core/common/action.c ****                 default:
 518:tmk_core/common/action.c ****                     /* tap key */
 519:tmk_core/common/action.c ****                     if (event.pressed) {
 520:tmk_core/common/action.c ****                         if (tap_count > 0) {
 521:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 522:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 523:tmk_core/common/action.c ****                         } else {
 524:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 525:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 526:tmk_core/common/action.c ****                         }
 527:tmk_core/common/action.c ****                     } else {
 528:tmk_core/common/action.c ****                         if (tap_count > 0) {
 529:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 530:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 531:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 532:tmk_core/common/action.c ****                             } else {
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 534:tmk_core/common/action.c ****                             }
 535:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 536:tmk_core/common/action.c ****                         } else {
 537:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 538:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 539:tmk_core/common/action.c ****                         }
 540:tmk_core/common/action.c ****                     }
 541:tmk_core/common/action.c ****                     break;
 542:tmk_core/common/action.c ****             }
 543:tmk_core/common/action.c ****             break;
 544:tmk_core/common/action.c **** #    endif
 545:tmk_core/common/action.c **** #endif
 546:tmk_core/common/action.c ****             /* Extentions */
 547:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 548:tmk_core/common/action.c ****         case ACT_MACRO:
 549:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 550:tmk_core/common/action.c ****             break;
 551:tmk_core/common/action.c **** #endif
 552:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 553:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 554:tmk_core/common/action.c ****             if (!event.pressed) {
 555:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 556:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 557:tmk_core/common/action.c ****                         backlight_increase();
 558:tmk_core/common/action.c ****                         break;
 559:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 560:tmk_core/common/action.c ****                         backlight_decrease();
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 563:tmk_core/common/action.c ****                         backlight_toggle();
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 566:tmk_core/common/action.c ****                         backlight_step();
 567:tmk_core/common/action.c ****                         break;
 568:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 569:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 570:tmk_core/common/action.c ****                         break;
 571:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 572:tmk_core/common/action.c ****                         backlight_level(0);
 573:tmk_core/common/action.c ****                         break;
 574:tmk_core/common/action.c ****                 }
 575:tmk_core/common/action.c ****             }
 576:tmk_core/common/action.c ****             break;
 577:tmk_core/common/action.c **** #endif
 578:tmk_core/common/action.c ****         case ACT_COMMAND:
 579:tmk_core/common/action.c ****             break;
 580:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 581:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 582:tmk_core/common/action.c ****             switch (action.swap.code) {
 583:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 584:tmk_core/common/action.c ****                     if (event.pressed) {
 585:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 586:tmk_core/common/action.c ****                     }
 587:tmk_core/common/action.c ****                     break;
 588:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 589:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 592:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_ON:
 595:tmk_core/common/action.c ****                     if (!event.pressed) {
 596:tmk_core/common/action.c ****                         swap_hands = true;
 597:tmk_core/common/action.c ****                     }
 598:tmk_core/common/action.c ****                     break;
 599:tmk_core/common/action.c ****                 case OP_SH_OFF:
 600:tmk_core/common/action.c ****                     if (!event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = false;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 605:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 606:tmk_core/common/action.c ****                     /* tap toggle */
 607:tmk_core/common/action.c **** 
 608:tmk_core/common/action.c ****                     if (event.pressed) {
 609:tmk_core/common/action.c ****                         if (swap_held) {
 610:tmk_core/common/action.c ****                             swap_held = false;
 611:tmk_core/common/action.c ****                         } else {
 612:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 613:tmk_core/common/action.c ****                         }
 614:tmk_core/common/action.c ****                     } else {
 615:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 616:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 617:tmk_core/common/action.c ****                         }
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c ****                 default:
 621:tmk_core/common/action.c ****                     /* tap key */
 622:tmk_core/common/action.c ****                     if (tap_count > 0) {
 623:tmk_core/common/action.c ****                         if (swap_held) {
 624:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 625:tmk_core/common/action.c ****                             swap_held  = false;
 626:tmk_core/common/action.c ****                         }
 627:tmk_core/common/action.c ****                         if (event.pressed) {
 628:tmk_core/common/action.c ****                             register_code(action.swap.code);
 629:tmk_core/common/action.c ****                         } else {
 630:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 631:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 632:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 633:tmk_core/common/action.c ****                         }
 634:tmk_core/common/action.c ****                     } else {
 635:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 636:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 637:tmk_core/common/action.c ****                             swap_held  = false;
 638:tmk_core/common/action.c ****                         }
 639:tmk_core/common/action.c ****                     }
 640:tmk_core/common/action.c **** #    endif
 641:tmk_core/common/action.c ****             }
 642:tmk_core/common/action.c **** #endif
 643:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 644:tmk_core/common/action.c ****         case ACT_FUNCTION:
 645:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 646:tmk_core/common/action.c ****             break;
 647:tmk_core/common/action.c **** #endif
 648:tmk_core/common/action.c ****         default:
 649:tmk_core/common/action.c ****             break;
 650:tmk_core/common/action.c ****     }
 651:tmk_core/common/action.c **** 
 652:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 653:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 654:tmk_core/common/action.c ****     switch (action.kind.id) {
 655:tmk_core/common/action.c ****         case ACT_LAYER:
 656:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 657:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 658:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 659:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 660:tmk_core/common/action.c **** #    endif
 661:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c ****         default:
 664:tmk_core/common/action.c ****             break;
 665:tmk_core/common/action.c ****     }
 666:tmk_core/common/action.c **** #endif
 667:tmk_core/common/action.c **** 
 668:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 669:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 670:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 671:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 672:tmk_core/common/action.c ****     } else {
 673:tmk_core/common/action.c ****         if (event.pressed) {
 674:tmk_core/common/action.c ****             if (tap_count > 0) {
 675:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 676:tmk_core/common/action.c ****             } else {
 677:tmk_core/common/action.c ****             }
 678:tmk_core/common/action.c ****         } else {
 679:tmk_core/common/action.c ****             if (tap_count > 0) {
 680:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 681:tmk_core/common/action.c ****             } else {
 682:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 683:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 684:tmk_core/common/action.c ****                 }
 685:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 686:tmk_core/common/action.c ****             }
 687:tmk_core/common/action.c ****         }
 688:tmk_core/common/action.c ****     }
 689:tmk_core/common/action.c **** #    endif
 690:tmk_core/common/action.c **** #endif
 691:tmk_core/common/action.c **** 
 692:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 693:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 694:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 695:tmk_core/common/action.c ****      */
 696:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 697:tmk_core/common/action.c ****         record->event.pressed = false;
 698:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 699:tmk_core/common/action.c ****         process_record(record);
 700:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 701:tmk_core/common/action.c ****     }
 702:tmk_core/common/action.c **** #endif
 703:tmk_core/common/action.c **** }
 704:tmk_core/common/action.c **** 
 705:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 706:tmk_core/common/action.c ****  *
 707:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 708:tmk_core/common/action.c ****  */
 709:tmk_core/common/action.c **** void register_code(uint8_t code) {
 133               		.loc 1 709 0
 134               		.cfi_startproc
 135               	.LVL9:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 710:tmk_core/common/action.c ****     if (code == KC_NO) {
 140               		.loc 1 710 0
 141 0000 8823      		tst r24
 142 0002 01F4      		brne .+2
 143 0004 00C0      		rjmp .L4
 711:tmk_core/common/action.c ****         return;
 712:tmk_core/common/action.c ****     }
 713:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 714:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 715:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 716:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 717:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 718:tmk_core/common/action.c **** #    endif
 719:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 720:tmk_core/common/action.c ****         send_keyboard_report();
 721:tmk_core/common/action.c ****         wait_ms(100);
 722:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 723:tmk_core/common/action.c ****         send_keyboard_report();
 724:tmk_core/common/action.c ****     }
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 727:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 728:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 729:tmk_core/common/action.c **** #    endif
 730:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 731:tmk_core/common/action.c ****         send_keyboard_report();
 732:tmk_core/common/action.c ****         wait_ms(100);
 733:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** 
 737:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 738:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 739:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 740:tmk_core/common/action.c **** #    endif
 741:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 742:tmk_core/common/action.c ****         send_keyboard_report();
 743:tmk_core/common/action.c ****         wait_ms(100);
 744:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 745:tmk_core/common/action.c ****         send_keyboard_report();
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #endif
 748:tmk_core/common/action.c **** 
 749:tmk_core/common/action.c ****     else if
 750:tmk_core/common/action.c ****         IS_KEY(code) {
 144               		.loc 1 750 0
 145 0006 9CEF      		ldi r25,lo8(-4)
 146 0008 980F      		add r25,r24
 147 000a 913A      		cpi r25,lo8(-95)
 148 000c 00F4      		brsh .L6
 751:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 752:tmk_core/common/action.c ****             if (command_proc(code)) return;
 753:tmk_core/common/action.c **** 
 754:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 755:tmk_core/common/action.c **** /* TODO: remove
 756:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 757:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 758:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****             add_key(code);
 761:tmk_core/common/action.c ****             send_keyboard_report();
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             set_mods(tmp_mods);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c ****             oneshot_cancel();
 766:tmk_core/common/action.c ****         } else
 767:tmk_core/common/action.c **** */
 768:tmk_core/common/action.c **** #endif
 769:tmk_core/common/action.c ****             {
 770:tmk_core/common/action.c ****                 add_key(code);
 149               		.loc 1 770 0
 150 000e 0E94 0000 		call add_key
 151               	.LVL10:
 152               	.L39:
 771:tmk_core/common/action.c ****                 send_keyboard_report();
 772:tmk_core/common/action.c ****             }
 773:tmk_core/common/action.c ****         }
 774:tmk_core/common/action.c ****     else if
 775:tmk_core/common/action.c ****         IS_MOD(code) {
 776:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 777:tmk_core/common/action.c ****             send_keyboard_report();
 153               		.loc 1 777 0
 154 0012 0C94 0000 		jmp send_keyboard_report
 155               	.LVL11:
 156               	.L6:
 775:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 157               		.loc 1 775 0
 158 0016 90E2      		ldi r25,lo8(32)
 159 0018 980F      		add r25,r24
 160 001a 9830      		cpi r25,lo8(8)
 161 001c 00F4      		brsh .L7
 776:tmk_core/common/action.c ****             send_keyboard_report();
 162               		.loc 1 776 0
 163 001e 8770      		andi r24,lo8(7)
 164               	.LVL12:
 165 0020 91E0      		ldi r25,lo8(1)
 166 0022 00C0      		rjmp 2f
 167               		1:
 168 0024 990F      		lsl r25
 169               		2:
 170 0026 8A95      		dec r24
 171 0028 02F4      		brpl 1b
 172 002a 892F      		mov r24,r25
 173 002c 0E94 0000 		call add_mods
 174               	.LVL13:
 175 0030 00C0      		rjmp .L39
 176               	.LVL14:
 177               	.L7:
 778:tmk_core/common/action.c ****         }
 779:tmk_core/common/action.c ****     else if
 780:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 178               		.loc 1 780 0
 179 0032 9BE5      		ldi r25,lo8(91)
 180 0034 980F      		add r25,r24
 181 0036 9330      		cpi r25,lo8(3)
 182 0038 00F4      		brsh .L8
 183               		.loc 1 780 0 is_stmt 0 discriminator 1
 184 003a 853A      		cpi r24,lo8(-91)
 185 003c 01F0      		breq .L11
 186               		.loc 1 780 0 discriminator 2
 187 003e 863A      		cpi r24,lo8(-90)
 188 0040 01F0      		breq .L12
 189               		.loc 1 780 0
 190 0042 83E8      		ldi r24,lo8(-125)
 191 0044 90E0      		ldi r25,0
 192               	.LVL15:
 193               	.L9:
 194               		.loc 1 780 0 discriminator 13
 195 0046 0C94 0000 		jmp host_system_send
 196               	.LVL16:
 197               	.L11:
 198               		.loc 1 780 0
 199 004a 81E8      		ldi r24,lo8(-127)
 200 004c 90E0      		ldi r25,0
 201               	.LVL17:
 202 004e 00C0      		rjmp .L9
 203               	.LVL18:
 204               	.L12:
 205 0050 82E8      		ldi r24,lo8(-126)
 206 0052 90E0      		ldi r25,0
 207               	.LVL19:
 208 0054 00C0      		rjmp .L9
 209               	.LVL20:
 210               	.L8:
 781:tmk_core/common/action.c ****     else if
 782:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 211               		.loc 1 782 0 is_stmt 1
 212 0056 98E5      		ldi r25,lo8(88)
 213 0058 980F      		add r25,r24
 214 005a 9731      		cpi r25,lo8(23)
 215 005c 00F0      		brlo .+2
 216 005e 00C0      		rjmp .L4
 217               		.loc 1 782 0 is_stmt 0 discriminator 1
 218 0060 883A      		cpi r24,lo8(-88)
 219 0062 01F4      		brne .+2
 220 0064 00C0      		rjmp .L13
 221               		.loc 1 782 0 discriminator 2
 222 0066 893A      		cpi r24,lo8(-87)
 223 0068 01F4      		brne .+2
 224 006a 00C0      		rjmp .L14
 225               		.loc 1 782 0 discriminator 4
 226 006c 8A3A      		cpi r24,lo8(-86)
 227 006e 01F4      		brne .+2
 228 0070 00C0      		rjmp .L15
 229               		.loc 1 782 0 discriminator 6
 230 0072 8B3A      		cpi r24,lo8(-85)
 231 0074 01F4      		brne .+2
 232 0076 00C0      		rjmp .L16
 233               		.loc 1 782 0 discriminator 8
 234 0078 8C3A      		cpi r24,lo8(-84)
 235 007a 01F4      		brne .+2
 236 007c 00C0      		rjmp .L17
 237               		.loc 1 782 0 discriminator 10
 238 007e 8B3B      		cpi r24,lo8(-69)
 239 0080 01F4      		brne .+2
 240 0082 00C0      		rjmp .L18
 241               		.loc 1 782 0 discriminator 12
 242 0084 8C3B      		cpi r24,lo8(-68)
 243 0086 01F4      		brne .+2
 244 0088 00C0      		rjmp .L19
 245               		.loc 1 782 0 discriminator 14
 246 008a 8D3A      		cpi r24,lo8(-83)
 247 008c 01F4      		brne .+2
 248 008e 00C0      		rjmp .L20
 249               		.loc 1 782 0 discriminator 16
 250 0090 803B      		cpi r24,lo8(-80)
 251 0092 01F4      		brne .+2
 252 0094 00C0      		rjmp .L21
 253               		.loc 1 782 0 discriminator 18
 254 0096 8E3A      		cpi r24,lo8(-82)
 255 0098 01F4      		brne .+2
 256 009a 00C0      		rjmp .L22
 257               		.loc 1 782 0 discriminator 20
 258 009c 8F3A      		cpi r24,lo8(-81)
 259 009e 01F4      		brne .+2
 260 00a0 00C0      		rjmp .L23
 261               		.loc 1 782 0 discriminator 22
 262 00a2 813B      		cpi r24,lo8(-79)
 263 00a4 01F4      		brne .+2
 264 00a6 00C0      		rjmp .L24
 265               		.loc 1 782 0 discriminator 24
 266 00a8 823B      		cpi r24,lo8(-78)
 267 00aa 01F4      		brne .+2
 268 00ac 00C0      		rjmp .L25
 269               		.loc 1 782 0 discriminator 26
 270 00ae 833B      		cpi r24,lo8(-77)
 271 00b0 01F4      		brne .+2
 272 00b2 00C0      		rjmp .L26
 273               		.loc 1 782 0 discriminator 28
 274 00b4 843B      		cpi r24,lo8(-76)
 275 00b6 01F4      		brne .+2
 276 00b8 00C0      		rjmp .L27
 277               		.loc 1 782 0 discriminator 30
 278 00ba 853B      		cpi r24,lo8(-75)
 279 00bc 01F4      		brne .+2
 280 00be 00C0      		rjmp .L28
 281               		.loc 1 782 0 discriminator 32
 282 00c0 863B      		cpi r24,lo8(-74)
 283 00c2 01F4      		brne .+2
 284 00c4 00C0      		rjmp .L29
 285               		.loc 1 782 0 discriminator 34
 286 00c6 873B      		cpi r24,lo8(-73)
 287 00c8 01F4      		brne .+2
 288 00ca 00C0      		rjmp .L30
 289               		.loc 1 782 0 discriminator 36
 290 00cc 883B      		cpi r24,lo8(-72)
 291 00ce 01F4      		brne .+2
 292 00d0 00C0      		rjmp .L31
 293               		.loc 1 782 0 discriminator 38
 294 00d2 893B      		cpi r24,lo8(-71)
 295 00d4 01F4      		brne .+2
 296 00d6 00C0      		rjmp .L32
 297               		.loc 1 782 0 discriminator 40
 298 00d8 8D3B      		cpi r24,lo8(-67)
 299 00da 01F4      		brne .+2
 300 00dc 00C0      		rjmp .L33
 301               		.loc 1 782 0 discriminator 42
 302 00de 8E3B      		cpi r24,lo8(-66)
 303 00e0 01F4      		brne .+2
 304 00e2 00C0      		rjmp .L34
 305               		.loc 1 782 0 discriminator 44
 306 00e4 8A3B      		cpi r24,lo8(-70)
 307 00e6 01F4      		brne .+2
 308 00e8 00C0      		rjmp .L35
 309               		.loc 1 782 0
 310 00ea 90E0      		ldi r25,0
 311 00ec 80E0      		ldi r24,0
 312               	.LVL21:
 313               	.L10:
 314               		.loc 1 782 0 discriminator 93
 315 00ee 0C94 0000 		jmp host_consumer_send
 316               	.LVL22:
 317               	.L13:
 318               		.loc 1 782 0
 319 00f2 82EE      		ldi r24,lo8(-30)
 320 00f4 90E0      		ldi r25,0
 321               	.LVL23:
 322 00f6 00C0      		rjmp .L10
 323               	.LVL24:
 324               	.L14:
 325 00f8 89EE      		ldi r24,lo8(-23)
 326 00fa 90E0      		ldi r25,0
 327               	.LVL25:
 328 00fc 00C0      		rjmp .L10
 329               	.LVL26:
 330               	.L15:
 331 00fe 8AEE      		ldi r24,lo8(-22)
 332 0100 90E0      		ldi r25,0
 333               	.LVL27:
 334 0102 00C0      		rjmp .L10
 335               	.LVL28:
 336               	.L16:
 337 0104 85EB      		ldi r24,lo8(-75)
 338 0106 90E0      		ldi r25,0
 339               	.LVL29:
 340 0108 00C0      		rjmp .L10
 341               	.LVL30:
 342               	.L17:
 343 010a 86EB      		ldi r24,lo8(-74)
 344 010c 90E0      		ldi r25,0
 345               	.LVL31:
 346 010e 00C0      		rjmp .L10
 347               	.LVL32:
 348               	.L18:
 349 0110 83EB      		ldi r24,lo8(-77)
 350 0112 90E0      		ldi r25,0
 351               	.LVL33:
 352 0114 00C0      		rjmp .L10
 353               	.LVL34:
 354               	.L19:
 355 0116 84EB      		ldi r24,lo8(-76)
 356 0118 90E0      		ldi r25,0
 357               	.LVL35:
 358 011a 00C0      		rjmp .L10
 359               	.LVL36:
 360               	.L20:
 361 011c 87EB      		ldi r24,lo8(-73)
 362 011e 90E0      		ldi r25,0
 363               	.LVL37:
 364 0120 00C0      		rjmp .L10
 365               	.LVL38:
 366               	.L21:
 367 0122 8CEC      		ldi r24,lo8(-52)
 368 0124 90E0      		ldi r25,0
 369               	.LVL39:
 370 0126 00C0      		rjmp .L10
 371               	.LVL40:
 372               	.L22:
 373 0128 8DEC      		ldi r24,lo8(-51)
 374 012a 90E0      		ldi r25,0
 375               	.LVL41:
 376 012c 00C0      		rjmp .L10
 377               	.LVL42:
 378               	.L23:
 379 012e 83E8      		ldi r24,lo8(-125)
 380 0130 91E0      		ldi r25,lo8(1)
 381               	.LVL43:
 382 0132 00C0      		rjmp .L10
 383               	.LVL44:
 384               	.L24:
 385 0134 8AE8      		ldi r24,lo8(-118)
 386 0136 91E0      		ldi r25,lo8(1)
 387               	.LVL45:
 388 0138 00C0      		rjmp .L10
 389               	.LVL46:
 390               	.L25:
 391 013a 82E9      		ldi r24,lo8(-110)
 392 013c 91E0      		ldi r25,lo8(1)
 393               	.LVL47:
 394 013e 00C0      		rjmp .L10
 395               	.LVL48:
 396               	.L26:
 397 0140 84E9      		ldi r24,lo8(-108)
 398 0142 91E0      		ldi r25,lo8(1)
 399               	.LVL49:
 400 0144 00C0      		rjmp .L10
 401               	.LVL50:
 402               	.L27:
 403 0146 81E2      		ldi r24,lo8(33)
 404 0148 92E0      		ldi r25,lo8(2)
 405               	.LVL51:
 406 014a 00C0      		rjmp .L10
 407               	.LVL52:
 408               	.L28:
 409 014c 83E2      		ldi r24,lo8(35)
 410 014e 92E0      		ldi r25,lo8(2)
 411               	.LVL53:
 412 0150 00C0      		rjmp .L10
 413               	.LVL54:
 414               	.L29:
 415 0152 84E2      		ldi r24,lo8(36)
 416 0154 92E0      		ldi r25,lo8(2)
 417               	.LVL55:
 418 0156 00C0      		rjmp .L10
 419               	.LVL56:
 420               	.L30:
 421 0158 85E2      		ldi r24,lo8(37)
 422 015a 92E0      		ldi r25,lo8(2)
 423               	.LVL57:
 424 015c 00C0      		rjmp .L10
 425               	.LVL58:
 426               	.L31:
 427 015e 86E2      		ldi r24,lo8(38)
 428 0160 92E0      		ldi r25,lo8(2)
 429               	.LVL59:
 430 0162 00C0      		rjmp .L10
 431               	.LVL60:
 432               	.L32:
 433 0164 87E2      		ldi r24,lo8(39)
 434 0166 92E0      		ldi r25,lo8(2)
 435               	.LVL61:
 436 0168 00C0      		rjmp .L10
 437               	.LVL62:
 438               	.L33:
 439 016a 8FE6      		ldi r24,lo8(111)
 440 016c 90E0      		ldi r25,0
 441               	.LVL63:
 442 016e 00C0      		rjmp .L10
 443               	.LVL64:
 444               	.L34:
 445 0170 80E7      		ldi r24,lo8(112)
 446 0172 90E0      		ldi r25,0
 447               	.LVL65:
 448 0174 00C0      		rjmp .L10
 449               	.LVL66:
 450               	.L35:
 451 0176 8AE2      		ldi r24,lo8(42)
 452 0178 92E0      		ldi r25,lo8(2)
 453               	.LVL67:
 454 017a 00C0      		rjmp .L10
 455               	.LVL68:
 456               	.L4:
 457               	/* epilogue start */
 783:tmk_core/common/action.c **** 
 784:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 785:tmk_core/common/action.c ****     else if
 786:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 787:tmk_core/common/action.c ****             mousekey_on(code);
 788:tmk_core/common/action.c ****             mousekey_send();
 789:tmk_core/common/action.c ****         }
 790:tmk_core/common/action.c **** #endif
 791:tmk_core/common/action.c **** }
 458               		.loc 1 791 0 is_stmt 1
 459 017c 0895      		ret
 460               		.cfi_endproc
 461               	.LFE112:
 463               		.section	.text.unregister_code,"ax",@progbits
 464               	.global	unregister_code
 466               	unregister_code:
 467               	.LFB113:
 792:tmk_core/common/action.c **** 
 793:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 794:tmk_core/common/action.c ****  *
 795:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 796:tmk_core/common/action.c ****  */
 797:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 468               		.loc 1 797 0
 469               		.cfi_startproc
 470               	.LVL69:
 471               	/* prologue: function */
 472               	/* frame size = 0 */
 473               	/* stack size = 0 */
 474               	.L__stack_usage = 0
 798:tmk_core/common/action.c ****     if (code == KC_NO) {
 475               		.loc 1 798 0
 476 0000 8823      		tst r24
 477 0002 01F0      		breq .L40
 799:tmk_core/common/action.c ****         return;
 800:tmk_core/common/action.c ****     }
 801:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 802:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 803:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 804:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 805:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 806:tmk_core/common/action.c **** #    endif
 807:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 810:tmk_core/common/action.c ****         send_keyboard_report();
 811:tmk_core/common/action.c ****     }
 812:tmk_core/common/action.c **** 
 813:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 814:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 815:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 816:tmk_core/common/action.c **** #    endif
 817:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 818:tmk_core/common/action.c ****         send_keyboard_report();
 819:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 820:tmk_core/common/action.c ****         send_keyboard_report();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 824:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 825:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 826:tmk_core/common/action.c **** #    endif
 827:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 828:tmk_core/common/action.c ****         send_keyboard_report();
 829:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 830:tmk_core/common/action.c ****         send_keyboard_report();
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****     else if
 835:tmk_core/common/action.c ****         IS_KEY(code) {
 478               		.loc 1 835 0
 479 0004 9CEF      		ldi r25,lo8(-4)
 480 0006 980F      		add r25,r24
 481 0008 913A      		cpi r25,lo8(-95)
 482 000a 00F4      		brsh .L42
 836:tmk_core/common/action.c ****             del_key(code);
 483               		.loc 1 836 0
 484 000c 0E94 0000 		call del_key
 485               	.LVL70:
 486               	.L48:
 837:tmk_core/common/action.c ****             send_keyboard_report();
 838:tmk_core/common/action.c ****         }
 839:tmk_core/common/action.c ****     else if
 840:tmk_core/common/action.c ****         IS_MOD(code) {
 841:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 842:tmk_core/common/action.c ****             send_keyboard_report();
 487               		.loc 1 842 0
 488 0010 0C94 0000 		jmp send_keyboard_report
 489               	.LVL71:
 490               	.L42:
 840:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 491               		.loc 1 840 0
 492 0014 90E2      		ldi r25,lo8(32)
 493 0016 980F      		add r25,r24
 494 0018 9830      		cpi r25,lo8(8)
 495 001a 00F4      		brsh .L43
 841:tmk_core/common/action.c ****             send_keyboard_report();
 496               		.loc 1 841 0
 497 001c 8770      		andi r24,lo8(7)
 498               	.LVL72:
 499 001e 91E0      		ldi r25,lo8(1)
 500 0020 00C0      		rjmp 2f
 501               		1:
 502 0022 990F      		lsl r25
 503               		2:
 504 0024 8A95      		dec r24
 505 0026 02F4      		brpl 1b
 506 0028 892F      		mov r24,r25
 507 002a 0E94 0000 		call del_mods
 508               	.LVL73:
 509 002e 00C0      		rjmp .L48
 510               	.LVL74:
 511               	.L43:
 843:tmk_core/common/action.c ****         }
 844:tmk_core/common/action.c ****     else if
 845:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 512               		.loc 1 845 0
 513 0030 9BE5      		ldi r25,lo8(91)
 514 0032 980F      		add r25,r24
 515 0034 9330      		cpi r25,lo8(3)
 516 0036 00F4      		brsh .L44
 517               		.loc 1 845 0 is_stmt 0 discriminator 1
 518 0038 90E0      		ldi r25,0
 519 003a 80E0      		ldi r24,0
 520               	.LVL75:
 521 003c 0C94 0000 		jmp host_system_send
 522               	.LVL76:
 523               	.L44:
 846:tmk_core/common/action.c ****     else if
 847:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 524               		.loc 1 847 0 is_stmt 1
 525 0040 885A      		subi r24,lo8(-(88))
 526               	.LVL77:
 527 0042 8731      		cpi r24,lo8(23)
 528 0044 00F4      		brsh .L40
 529               		.loc 1 847 0 is_stmt 0 discriminator 1
 530 0046 90E0      		ldi r25,0
 531 0048 80E0      		ldi r24,0
 532               	.LVL78:
 533 004a 0C94 0000 		jmp host_consumer_send
 534               	.LVL79:
 535               	.L40:
 536               	/* epilogue start */
 848:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 849:tmk_core/common/action.c ****     else if
 850:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 851:tmk_core/common/action.c ****             mousekey_off(code);
 852:tmk_core/common/action.c ****             mousekey_send();
 853:tmk_core/common/action.c ****         }
 854:tmk_core/common/action.c **** #endif
 855:tmk_core/common/action.c **** }
 537               		.loc 1 855 0 is_stmt 1
 538 004e 0895      		ret
 539               		.cfi_endproc
 540               	.LFE113:
 542               		.section	.text.tap_code,"ax",@progbits
 543               	.global	tap_code
 545               	tap_code:
 546               	.LFB114:
 856:tmk_core/common/action.c **** 
 857:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 858:tmk_core/common/action.c ****  *
 859:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 860:tmk_core/common/action.c ****  */
 861:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 547               		.loc 1 861 0
 548               		.cfi_startproc
 549               	.LVL80:
 550 0000 CF93      		push r28
 551               	.LCFI4:
 552               		.cfi_def_cfa_offset 3
 553               		.cfi_offset 28, -2
 554               	/* prologue: function */
 555               	/* frame size = 0 */
 556               	/* stack size = 1 */
 557               	.L__stack_usage = 1
 558 0002 C82F      		mov r28,r24
 862:tmk_core/common/action.c ****     register_code(code);
 559               		.loc 1 862 0
 560 0004 0E94 0000 		call register_code
 561               	.LVL81:
 863:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 562               		.loc 1 863 0
 563 0008 C933      		cpi r28,lo8(57)
 564 000a 01F4      		brne .L51
 565               	.LVL82:
 566               	.LBB16:
 567               	.LBB17:
 568               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 569               		.loc 2 187 0
 570 000c 2FEF      		ldi r18,lo8(255999)
 571 000e 87EE      		ldi r24,hi8(255999)
 572 0010 93E0      		ldi r25,hlo8(255999)
 573 0012 2150      	1:	subi r18,1
 574 0014 8040      		sbci r24,0
 575 0016 9040      		sbci r25,0
 576 0018 01F4      		brne 1b
 577 001a 00C0      		rjmp .
 578 001c 0000      		nop
 579               	.LVL83:
 580               	.L51:
 581               	.LBE17:
 582               	.LBE16:
 864:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 865:tmk_core/common/action.c ****     } else {
 866:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 867:tmk_core/common/action.c ****     }
 868:tmk_core/common/action.c ****     unregister_code(code);
 583               		.loc 1 868 0
 584 001e 8C2F      		mov r24,r28
 585               	/* epilogue start */
 869:tmk_core/common/action.c **** }
 586               		.loc 1 869 0
 587 0020 CF91      		pop r28
 588               	.LVL84:
 868:tmk_core/common/action.c **** }
 589               		.loc 1 868 0
 590 0022 0C94 0000 		jmp unregister_code
 591               	.LVL85:
 592               		.cfi_endproc
 593               	.LFE114:
 595               		.section	.text.register_mods,"ax",@progbits
 596               	.global	register_mods
 598               	register_mods:
 599               	.LFB115:
 870:tmk_core/common/action.c **** 
 871:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:tmk_core/common/action.c ****  *
 873:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:tmk_core/common/action.c ****  */
 875:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 600               		.loc 1 875 0
 601               		.cfi_startproc
 602               	.LVL86:
 603               	/* prologue: function */
 604               	/* frame size = 0 */
 605               	/* stack size = 0 */
 606               	.L__stack_usage = 0
 876:tmk_core/common/action.c ****     if (mods) {
 607               		.loc 1 876 0
 608 0000 8823      		tst r24
 609 0002 01F0      		breq .L52
 877:tmk_core/common/action.c ****         add_mods(mods);
 610               		.loc 1 877 0
 611 0004 0E94 0000 		call add_mods
 612               	.LVL87:
 878:tmk_core/common/action.c ****         send_keyboard_report();
 613               		.loc 1 878 0
 614 0008 0C94 0000 		jmp send_keyboard_report
 615               	.LVL88:
 616               	.L52:
 617               	/* epilogue start */
 879:tmk_core/common/action.c ****     }
 880:tmk_core/common/action.c **** }
 618               		.loc 1 880 0
 619 000c 0895      		ret
 620               		.cfi_endproc
 621               	.LFE115:
 623               		.section	.text.unregister_mods,"ax",@progbits
 624               	.global	unregister_mods
 626               	unregister_mods:
 627               	.LFB116:
 881:tmk_core/common/action.c **** 
 882:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 883:tmk_core/common/action.c ****  *
 884:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 885:tmk_core/common/action.c ****  */
 886:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 628               		.loc 1 886 0
 629               		.cfi_startproc
 630               	.LVL89:
 631               	/* prologue: function */
 632               	/* frame size = 0 */
 633               	/* stack size = 0 */
 634               	.L__stack_usage = 0
 887:tmk_core/common/action.c ****     if (mods) {
 635               		.loc 1 887 0
 636 0000 8823      		tst r24
 637 0002 01F0      		breq .L54
 888:tmk_core/common/action.c ****         del_mods(mods);
 638               		.loc 1 888 0
 639 0004 0E94 0000 		call del_mods
 640               	.LVL90:
 889:tmk_core/common/action.c ****         send_keyboard_report();
 641               		.loc 1 889 0
 642 0008 0C94 0000 		jmp send_keyboard_report
 643               	.LVL91:
 644               	.L54:
 645               	/* epilogue start */
 890:tmk_core/common/action.c ****     }
 891:tmk_core/common/action.c **** }
 646               		.loc 1 891 0
 647 000c 0895      		ret
 648               		.cfi_endproc
 649               	.LFE116:
 651               		.section	.text.process_action,"ax",@progbits
 652               	.global	process_action
 654               	process_action:
 655               	.LFB111:
 197:tmk_core/common/action.c ****     keyevent_t event = record->event;
 656               		.loc 1 197 0
 657               		.cfi_startproc
 658               	.LVL92:
 659 0000 CF92      		push r12
 660               	.LCFI5:
 661               		.cfi_def_cfa_offset 3
 662               		.cfi_offset 12, -2
 663 0002 DF92      		push r13
 664               	.LCFI6:
 665               		.cfi_def_cfa_offset 4
 666               		.cfi_offset 13, -3
 667 0004 EF92      		push r14
 668               	.LCFI7:
 669               		.cfi_def_cfa_offset 5
 670               		.cfi_offset 14, -4
 671 0006 FF92      		push r15
 672               	.LCFI8:
 673               		.cfi_def_cfa_offset 6
 674               		.cfi_offset 15, -5
 675 0008 0F93      		push r16
 676               	.LCFI9:
 677               		.cfi_def_cfa_offset 7
 678               		.cfi_offset 16, -6
 679 000a 1F93      		push r17
 680               	.LCFI10:
 681               		.cfi_def_cfa_offset 8
 682               		.cfi_offset 17, -7
 683 000c CF93      		push r28
 684               	.LCFI11:
 685               		.cfi_def_cfa_offset 9
 686               		.cfi_offset 28, -8
 687 000e DF93      		push r29
 688               	.LCFI12:
 689               		.cfi_def_cfa_offset 10
 690               		.cfi_offset 29, -9
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 8 */
 694               	.L__stack_usage = 8
 695 0010 6C01      		movw r12,r24
 696 0012 D62F      		mov r29,r22
 697 0014 C72F      		mov r28,r23
 698               	.LVL93:
 200:tmk_core/common/action.c **** #endif
 699               		.loc 1 200 0
 700 0016 FC01      		movw r30,r24
 701 0018 0581      		ldd r16,Z+5
 702 001a 0295      		swap r16
 703 001c 0F70      		andi r16,lo8(15)
 704               	.LVL94:
 203:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 705               		.loc 1 203 0
 706 001e 1281      		ldd r17,Z+2
 707 0020 1111      		cpse r17,__zero_reg__
 205:tmk_core/common/action.c ****     }
 708               		.loc 1 205 0
 709 0022 0E94 0000 		call clear_weak_mods
 710               	.LVL95:
 711               	.L57:
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 712               		.loc 1 211 0
 713 0026 0E94 0000 		call is_oneshot_layer_active
 714               	.LVL96:
 715 002a E82E      		mov r14,r24
 716 002c 8823      		tst r24
 717 002e 01F0      		breq .L58
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 718               		.loc 1 211 0 is_stmt 0 discriminator 1
 719 0030 1123      		tst r17
 720 0032 01F0      		breq .L138
 211:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 721               		.loc 1 211 0 discriminator 2
 722 0034 80E2      		ldi r24,lo8(32)
 723 0036 8D0F      		add r24,r29
 724 0038 8830      		cpi r24,lo8(8)
 725 003a 00F0      		brlo .L138
 212:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 726               		.loc 1 212 0 is_stmt 1
 727 003c 82E0      		ldi r24,lo8(2)
 728 003e 0E94 0000 		call clear_oneshot_layer_state
 729               	.LVL97:
 213:tmk_core/common/action.c ****     }
 730               		.loc 1 213 0
 731 0042 0E94 0000 		call is_oneshot_layer_active
 732               	.LVL98:
 733 0046 91E0      		ldi r25,lo8(1)
 734 0048 E82E      		mov r14,r24
 735 004a E926      		eor r14,r25
 736               	.LVL99:
 737               	.L58:
 217:tmk_core/common/action.c ****         /* Key and Mods */
 738               		.loc 1 217 0
 739 004c FC2E      		mov r15,r28
 740 004e F294      		swap r15
 741 0050 9FE0      		ldi r25,lo8(15)
 742 0052 F922      		and r15,r25
 743 0054 FDE0      		ldi r31,lo8(13)
 744 0056 FF15      		cp r31,r15
 745 0058 00F4      		brsh .+2
 746 005a 00C0      		rjmp .L59
 747 005c EF2D      		mov r30,r15
 748 005e F0E0      		ldi r31,0
 749 0060 E050      		subi r30,lo8(-(gs(.L61)))
 750 0062 F040      		sbci r31,hi8(-(gs(.L61)))
 751 0064 0C94 0000 		jmp __tablejump2__
 752               		.p2align	1
 753               	.L61:
 754 0068 0000      		.word gs(.L60)
 755 006a 0000      		.word gs(.L60)
 756 006c 0000      		.word gs(.L62)
 757 006e 0000      		.word gs(.L62)
 758 0070 0000      		.word gs(.L59)
 759 0072 0000      		.word gs(.L59)
 760 0074 0000      		.word gs(.L59)
 761 0076 0000      		.word gs(.L59)
 762 0078 0000      		.word gs(.L63)
 763 007a 0000      		.word gs(.L64)
 764 007c 0000      		.word gs(.L65)
 765 007e 0000      		.word gs(.L65)
 766 0080 0000      		.word gs(.L59)
 767 0082 0000      		.word gs(.L66)
 768               	.LVL100:
 769               	.L138:
 209:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 770               		.loc 1 209 0
 771 0084 E12C      		mov r14,__zero_reg__
 772 0086 00C0      		rjmp .L58
 773               	.LVL101:
 774               	.L60:
 775 0088 0C2F      		mov r16,r28
 776               	.LVL102:
 777 008a 0F70      		andi r16,lo8(15)
 778               	.LBB18:
 221:tmk_core/common/action.c ****             if (event.pressed) {
 779               		.loc 1 221 0
 780 008c C07F      		andi r28,lo8(-16)
 781               	.LVL103:
 782 008e 01F0      		breq .L67
 221:tmk_core/common/action.c ****             if (event.pressed) {
 783               		.loc 1 221 0 is_stmt 0 discriminator 2
 784 0090 0295      		swap r16
 785 0092 007F      		andi r16,lo8(-16)
 786               	.L67:
 787               	.LVL104:
 222:tmk_core/common/action.c ****                 if (mods) {
 788               		.loc 1 222 0 is_stmt 1 discriminator 4
 789 0094 1123      		tst r17
 790 0096 01F0      		breq .L68
 223:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 791               		.loc 1 223 0
 792 0098 0023      		tst r16
 793 009a 01F0      		breq .L90
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 794               		.loc 1 224 0
 795 009c 80E2      		ldi r24,lo8(32)
 796 009e 8D0F      		add r24,r29
 797 00a0 8830      		cpi r24,lo8(8)
 798 00a2 00F0      		brlo .L70
 224:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 799               		.loc 1 224 0 is_stmt 0 discriminator 1
 800 00a4 D111      		cpse r29,__zero_reg__
 801 00a6 00C0      		rjmp .L71
 802               	.L70:
 228:tmk_core/common/action.c ****                     } else {
 803               		.loc 1 228 0 is_stmt 1
 804 00a8 802F      		mov r24,r16
 805 00aa 0E94 0000 		call add_mods
 806               	.LVL105:
 807               	.L72:
 232:tmk_core/common/action.c ****                 }
 808               		.loc 1 232 0
 809 00ae 0E94 0000 		call send_keyboard_report
 810               	.LVL106:
 811               	.L90:
 812               	.LBE18:
 813               	.LBB19:
 318:tmk_core/common/action.c ****                             }
 814               		.loc 1 318 0
 815 00b2 8D2F      		mov r24,r29
 816 00b4 0E94 0000 		call register_code
 817               	.LVL107:
 818 00b8 00C0      		rjmp .L73
 819               	.LVL108:
 820               	.L71:
 821               	.LBE19:
 822               	.LBB22:
 230:tmk_core/common/action.c ****                     }
 823               		.loc 1 230 0
 824 00ba 802F      		mov r24,r16
 825 00bc 0E94 0000 		call add_weak_mods
 826               	.LVL109:
 827 00c0 00C0      		rjmp .L72
 828               	.L68:
 236:tmk_core/common/action.c ****                 if (mods) {
 829               		.loc 1 236 0
 830 00c2 8D2F      		mov r24,r29
 831 00c4 0E94 0000 		call unregister_code
 832               	.LVL110:
 237:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 833               		.loc 1 237 0
 834 00c8 0023      		tst r16
 835 00ca 01F0      		breq .L73
 238:tmk_core/common/action.c ****                         del_mods(mods);
 836               		.loc 1 238 0
 837 00cc 80E2      		ldi r24,lo8(32)
 838 00ce 8D0F      		add r24,r29
 839 00d0 8830      		cpi r24,lo8(8)
 840 00d2 00F0      		brlo .L75
 238:tmk_core/common/action.c ****                         del_mods(mods);
 841               		.loc 1 238 0 is_stmt 0 discriminator 1
 842 00d4 D111      		cpse r29,__zero_reg__
 843 00d6 00C0      		rjmp .L76
 844               	.L75:
 239:tmk_core/common/action.c ****                     } else {
 845               		.loc 1 239 0 is_stmt 1
 846 00d8 802F      		mov r24,r16
 847 00da 0E94 0000 		call del_mods
 848               	.LVL111:
 849               	.L77:
 243:tmk_core/common/action.c ****                 }
 850               		.loc 1 243 0
 851 00de 0E94 0000 		call send_keyboard_report
 852               	.LVL112:
 853               	.L73:
 854               	.LBE22:
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 855               		.loc 1 696 0
 856 00e2 EE20      		tst r14
 857 00e4 01F4      		brne .+2
 858 00e6 00C0      		rjmp .L56
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 859               		.loc 1 696 0 is_stmt 0 discriminator 1
 860 00e8 0E94 0000 		call get_oneshot_layer_state
 861               	.LVL113:
 862 00ec 80FD      		sbrc r24,0
 863 00ee 00C0      		rjmp .L56
 697:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 864               		.loc 1 697 0 is_stmt 1
 865 00f0 F601      		movw r30,r12
 866 00f2 1282      		std Z+2,__zero_reg__
 698:tmk_core/common/action.c ****         process_record(record);
 867               		.loc 1 698 0
 868 00f4 0E94 0000 		call get_oneshot_layer
 869               	.LVL114:
 870 00f8 0E94 0000 		call layer_on
 871               	.LVL115:
 699:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 872               		.loc 1 699 0
 873 00fc C601      		movw r24,r12
 874 00fe 0E94 0000 		call process_record
 875               	.LVL116:
 700:tmk_core/common/action.c ****     }
 876               		.loc 1 700 0
 877 0102 0E94 0000 		call get_oneshot_layer
 878               	.LVL117:
 879               	/* epilogue start */
 703:tmk_core/common/action.c **** 
 880               		.loc 1 703 0
 881 0106 DF91      		pop r29
 882               	.LVL118:
 883 0108 CF91      		pop r28
 884 010a 1F91      		pop r17
 885 010c 0F91      		pop r16
 886 010e FF90      		pop r15
 887 0110 EF90      		pop r14
 888               	.LVL119:
 889 0112 DF90      		pop r13
 890 0114 CF90      		pop r12
 891               	.LVL120:
 700:tmk_core/common/action.c ****     }
 892               		.loc 1 700 0
 893 0116 0C94 0000 		jmp layer_off
 894               	.LVL121:
 895               	.L76:
 896               	.LBB23:
 241:tmk_core/common/action.c ****                     }
 897               		.loc 1 241 0
 898 011a 802F      		mov r24,r16
 899 011c 0E94 0000 		call del_weak_mods
 900               	.LVL122:
 901 0120 00C0      		rjmp .L77
 902               	.LVL123:
 903               	.L62:
 904 0122 2C2F      		mov r18,r28
 905 0124 2F70      		andi r18,lo8(15)
 906 0126 F22E      		mov r15,r18
 907               	.LBE23:
 908               	.LBB24:
 250:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 909               		.loc 1 250 0
 910 0128 C07F      		andi r28,lo8(-16)
 911               	.LVL124:
 912 012a C032      		cpi r28,lo8(32)
 913 012c 01F0      		breq .L78
 250:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 914               		.loc 1 250 0 is_stmt 0 discriminator 2
 915 012e F294      		swap r15
 916 0130 80EF      		ldi r24,lo8(-16)
 917 0132 F822      		and r15,r24
 918               	.L78:
 919               	.LVL125:
 251:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 920               		.loc 1 251 0 is_stmt 1 discriminator 4
 921 0134 DD23      		tst r29
 922 0136 01F0      		breq .L80
 923 0138 D130      		cpi r29,lo8(1)
 924 013a 01F0      		breq .L81
 306:tmk_core/common/action.c ****                         if (tap_count > 0) {
 925               		.loc 1 306 0
 926 013c 1123      		tst r17
 927 013e 01F0      		breq .L88
 307:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 928               		.loc 1 307 0
 929 0140 0023      		tst r16
 930 0142 01F0      		breq .L168
 309:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 931               		.loc 1 309 0
 932 0144 F601      		movw r30,r12
 933 0146 8581      		ldd r24,Z+5
 934 0148 80FF      		sbrs r24,0
 935 014a 00C0      		rjmp .L90
 312:tmk_core/common/action.c ****                                 register_mods(mods);
 936               		.loc 1 312 0
 937 014c 8F70      		andi r24,lo8(15)
 938 014e 8583      		std Z+5,r24
 939 0150 00C0      		rjmp .L168
 940               	.L80:
 255:tmk_core/common/action.c ****                         if (tap_count == 0) {
 941               		.loc 1 255 0
 942 0152 1123      		tst r17
 943 0154 01F0      		breq .L82
 256:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 944               		.loc 1 256 0
 945 0156 0111      		cpse r16,__zero_reg__
 946 0158 00C0      		rjmp .L83
 947               	.L84:
 270:tmk_core/common/action.c ****                         }
 948               		.loc 1 270 0
 949 015a 0E94 0000 		call get_oneshot_mods
 950               	.LVL126:
 951 015e 8F29      		or r24,r15
 952               	.L167:
 313:tmk_core/common/action.c ****                             } else
 953               		.loc 1 313 0
 954 0160 0E94 0000 		call register_mods
 955               	.LVL127:
 956 0164 00C0      		rjmp .L73
 957               	.L83:
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 958               		.loc 1 259 0
 959 0166 0130      		cpi r16,lo8(1)
 960 0168 01F4      		brne .L84
 261:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 961               		.loc 1 261 0
 962 016a 0E94 0000 		call get_oneshot_mods
 963               	.LVL128:
 964 016e 8F29      		or r24,r15
 965 0170 0E94 0000 		call set_oneshot_mods
 966               	.LVL129:
 967 0174 00C0      		rjmp .L73
 968               	.L82:
 273:tmk_core/common/action.c ****                             clear_oneshot_mods();
 969               		.loc 1 273 0
 970 0176 0111      		cpse r16,__zero_reg__
 971 0178 00C0      		rjmp .L85
 972               	.L169:
 288:tmk_core/common/action.c ****                             unregister_mods(mods);
 973               		.loc 1 288 0
 974 017a 0E94 0000 		call clear_oneshot_mods
 975               	.LVL130:
 976               	.L91:
 333:tmk_core/common/action.c ****                         }
 977               		.loc 1 333 0
 978 017e 8F2D      		mov r24,r15
 979 0180 0E94 0000 		call unregister_mods
 980               	.LVL131:
 981 0184 00C0      		rjmp .L73
 982               	.L85:
 276:tmk_core/common/action.c ****                             // Retain Oneshot mods
 983               		.loc 1 276 0
 984 0186 0130      		cpi r16,lo8(1)
 985 0188 01F4      		brne .+2
 986 018a 00C0      		rjmp .L73
 987 018c 00C0      		rjmp .L169
 988               	.L81:
 295:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 989               		.loc 1 295 0
 990 018e 1123      		tst r17
 991 0190 01F0      		breq .L87
 296:tmk_core/common/action.c ****                             register_mods(mods);
 992               		.loc 1 296 0
 993 0192 0630      		cpi r16,lo8(6)
 994 0194 00F0      		brlo .+2
 995 0196 00C0      		rjmp .L73
 996               	.L168:
 313:tmk_core/common/action.c ****                             } else
 997               		.loc 1 313 0
 998 0198 8F2D      		mov r24,r15
 999 019a 00C0      		rjmp .L167
 1000               	.L87:
 300:tmk_core/common/action.c ****                             unregister_mods(mods);
 1001               		.loc 1 300 0
 1002 019c 0530      		cpi r16,lo8(5)
 1003 019e 00F0      		brlo .+2
 1004 01a0 00C0      		rjmp .L73
 1005 01a2 00C0      		rjmp .L91
 1006               	.L88:
 325:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1007               		.loc 1 325 0
 1008 01a4 0023      		tst r16
 1009 01a6 01F0      		breq .L91
 327:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1010               		.loc 1 327 0
 1011 01a8 D933      		cpi r29,lo8(57)
 1012 01aa 01F4      		brne .L92
 1013               	.LVL132:
 1014               	.LBB20:
 1015               	.LBB21:
 1016               		.loc 2 187 0
 1017 01ac FFEF      		ldi r31,lo8(255999)
 1018 01ae 27EE      		ldi r18,hi8(255999)
 1019 01b0 83E0      		ldi r24,hlo8(255999)
 1020 01b2 F150      	1:	subi r31,1
 1021 01b4 2040      		sbci r18,0
 1022 01b6 8040      		sbci r24,0
 1023 01b8 01F4      		brne 1b
 1024 01ba 00C0      		rjmp .
 1025 01bc 0000      		nop
 1026               	.LVL133:
 1027               	.L92:
 1028               	.LBE21:
 1029               	.LBE20:
 330:tmk_core/common/action.c ****                         } else {
 1030               		.loc 1 330 0
 1031 01be 8D2F      		mov r24,r29
 1032 01c0 0E94 0000 		call unregister_code
 1033               	.LVL134:
 1034 01c4 00C0      		rjmp .L73
 1035               	.LVL135:
 1036               	.L63:
 1037               	.LBE24:
 401:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1038               		.loc 1 401 0
 1039 01c6 8C2F      		mov r24,r28
 1040 01c8 8370      		andi r24,lo8(3)
 1041 01ca 01F0      		breq .+2
 1042 01cc 00C0      		rjmp .L93
 403:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1043               		.loc 1 403 0
 1044 01ce 1111      		cpse r17,__zero_reg__
 1045 01d0 00C0      		rjmp .L94
 1046               	.LVL136:
 1047               	.LBB25:
 404:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1048               		.loc 1 404 0
 1049 01d2 4D2F      		mov r20,r29
 1050 01d4 4295      		swap r20
 1051 01d6 4695      		lsr r20
 1052 01d8 4770      		andi r20,lo8(7)
 1053 01da 440F      		lsl r20
 1054 01dc 440F      		lsl r20
 405:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1055               		.loc 1 405 0
 1056 01de 0D2F      		mov r16,r29
 1057               	.LVL137:
 1058 01e0 0F70      		andi r16,lo8(15)
 1059 01e2 10E0      		ldi r17,0
 1060               	.LVL138:
 1061 01e4 30E0      		ldi r19,0
 1062 01e6 20E0      		ldi r18,0
 1063 01e8 042E      		mov r0,r20
 1064 01ea 00C0      		rjmp 2f
 1065               		1:
 1066 01ec 000F      		lsl r16
 1067 01ee 111F      		rol r17
 1068 01f0 221F      		rol r18
 1069 01f2 331F      		rol r19
 1070               		2:
 1071 01f4 0A94      		dec r0
 1072 01f6 02F4      		brpl 1b
 1073               	.LVL139:
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1074               		.loc 1 406 0
 1075 01f8 60E0      		ldi r22,0
 1076 01fa 70E0      		ldi r23,0
 1077 01fc CB01      		movw r24,r22
 1078 01fe D4FF      		sbrs r29,4
 1079 0200 00C0      		rjmp .L95
 406:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1080               		.loc 1 406 0 is_stmt 0 discriminator 1
 1081 0202 6FE0      		ldi r22,lo8(15)
 1082 0204 70E0      		ldi r23,0
 1083 0206 80E0      		ldi r24,0
 1084 0208 90E0      		ldi r25,0
 1085 020a 00C0      		rjmp 2f
 1086               		1:
 1087 020c 660F      		lsl r22
 1088 020e 771F      		rol r23
 1089 0210 881F      		rol r24
 1090 0212 991F      		rol r25
 1091               		2:
 1092 0214 4A95      		dec r20
 1093 0216 02F4      		brpl 1b
 1094 0218 6095      		com r22
 1095 021a 7095      		com r23
 1096 021c 8095      		com r24
 1097 021e 9095      		com r25
 1098               	.L95:
 1099               	.LVL140:
 1100 0220 602B      		or r22,r16
 1101               	.LVL141:
 1102 0222 712B      		or r23,r17
 1103 0224 822B      		or r24,r18
 1104 0226 932B      		or r25,r19
 407:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1105               		.loc 1 407 0 is_stmt 1 discriminator 4
 1106 0228 C695      		lsr r28
 1107 022a C695      		lsr r28
 1108               	.LVL142:
 1109 022c C370      		andi r28,lo8(3)
 1110 022e C230      		cpi r28,lo8(2)
 1111 0230 01F0      		breq .L97
 1112 0232 00F4      		brsh .L98
 1113 0234 C130      		cpi r28,lo8(1)
 1114 0236 01F0      		breq .L99
 409:tmk_core/common/action.c ****                             break;
 1115               		.loc 1 409 0 discriminator 4
 1116 0238 0E94 0000 		call default_layer_and
 1117               	.LVL143:
 1118               	.L94:
 1119               	.LBE25:
 661:tmk_core/common/action.c ****             break;
 1120               		.loc 1 661 0
 1121 023c 0E94 0000 		call host_keyboard_leds
 1122               	.LVL144:
 1123 0240 0E94 0000 		call led_set
 1124               	.LVL145:
 662:tmk_core/common/action.c ****         default:
 1125               		.loc 1 662 0
 1126 0244 00C0      		rjmp .L73
 1127               	.LVL146:
 1128               	.L99:
 1129               	.LBB26:
 412:tmk_core/common/action.c ****                             break;
 1130               		.loc 1 412 0
 1131 0246 0E94 0000 		call default_layer_or
 1132               	.LVL147:
 413:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1133               		.loc 1 413 0
 1134 024a 00C0      		rjmp .L94
 1135               	.L97:
 415:tmk_core/common/action.c ****                             break;
 1136               		.loc 1 415 0
 1137 024c 0E94 0000 		call default_layer_xor
 1138               	.LVL148:
 416:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1139               		.loc 1 416 0
 1140 0250 00C0      		rjmp .L94
 1141               	.L98:
 418:tmk_core/common/action.c ****                             break;
 1142               		.loc 1 418 0
 1143 0252 0E94 0000 		call default_layer_set
 1144               	.LVL149:
 419:tmk_core/common/action.c ****                     }
 1145               		.loc 1 419 0
 1146 0256 00C0      		rjmp .L94
 1147               	.LVL150:
 1148               	.L93:
 1149               	.LBE26:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1150               		.loc 1 424 0
 1151 0258 8695      		lsr r24
 1152 025a 1123      		tst r17
 1153 025c 01F0      		breq .L101
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1154               		.loc 1 424 0 is_stmt 0 discriminator 1
 1155 025e 8C2F      		mov r24,r28
 1156 0260 8170      		andi r24,lo8(1)
 1157               	.L101:
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1158               		.loc 1 424 0 discriminator 4
 1159 0262 8823      		tst r24
 1160 0264 01F0      		breq .L94
 1161               	.LVL151:
 1162               	.LBB27:
 425:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1163               		.loc 1 425 0 is_stmt 1
 1164 0266 4D2F      		mov r20,r29
 1165 0268 4295      		swap r20
 1166 026a 4695      		lsr r20
 1167 026c 4770      		andi r20,lo8(7)
 1168 026e 440F      		lsl r20
 1169 0270 440F      		lsl r20
 426:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1170               		.loc 1 426 0
 1171 0272 0D2F      		mov r16,r29
 1172               	.LVL152:
 1173 0274 0F70      		andi r16,lo8(15)
 1174 0276 10E0      		ldi r17,0
 1175               	.LVL153:
 1176 0278 30E0      		ldi r19,0
 1177 027a 20E0      		ldi r18,0
 1178 027c 042E      		mov r0,r20
 1179 027e 00C0      		rjmp 2f
 1180               		1:
 1181 0280 000F      		lsl r16
 1182 0282 111F      		rol r17
 1183 0284 221F      		rol r18
 1184 0286 331F      		rol r19
 1185               		2:
 1186 0288 0A94      		dec r0
 1187 028a 02F4      		brpl 1b
 1188               	.LVL154:
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1189               		.loc 1 427 0
 1190 028c 60E0      		ldi r22,0
 1191 028e 70E0      		ldi r23,0
 1192 0290 CB01      		movw r24,r22
 1193 0292 D4FF      		sbrs r29,4
 1194 0294 00C0      		rjmp .L102
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1195               		.loc 1 427 0 is_stmt 0 discriminator 1
 1196 0296 6FE0      		ldi r22,lo8(15)
 1197 0298 70E0      		ldi r23,0
 1198 029a 80E0      		ldi r24,0
 1199 029c 90E0      		ldi r25,0
 1200 029e 00C0      		rjmp 2f
 1201               		1:
 1202 02a0 660F      		lsl r22
 1203 02a2 771F      		rol r23
 1204 02a4 881F      		rol r24
 1205 02a6 991F      		rol r25
 1206               		2:
 1207 02a8 4A95      		dec r20
 1208 02aa 02F4      		brpl 1b
 1209 02ac 6095      		com r22
 1210 02ae 7095      		com r23
 1211 02b0 8095      		com r24
 1212 02b2 9095      		com r25
 1213               	.L102:
 1214               	.LVL155:
 1215 02b4 602B      		or r22,r16
 1216               	.LVL156:
 1217 02b6 712B      		or r23,r17
 1218 02b8 822B      		or r24,r18
 1219 02ba 932B      		or r25,r19
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1220               		.loc 1 428 0 is_stmt 1 discriminator 4
 1221 02bc C695      		lsr r28
 1222 02be C695      		lsr r28
 1223               	.LVL157:
 1224 02c0 C370      		andi r28,lo8(3)
 1225 02c2 C230      		cpi r28,lo8(2)
 1226 02c4 01F0      		breq .L104
 1227 02c6 00F4      		brsh .L105
 1228 02c8 C130      		cpi r28,lo8(1)
 1229 02ca 01F0      		breq .L106
 430:tmk_core/common/action.c ****                             break;
 1230               		.loc 1 430 0 discriminator 4
 1231 02cc 0E94 0000 		call layer_and
 1232               	.LVL158:
 431:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1233               		.loc 1 431 0 discriminator 4
 1234 02d0 00C0      		rjmp .L94
 1235               	.L106:
 433:tmk_core/common/action.c ****                             break;
 1236               		.loc 1 433 0
 1237 02d2 0E94 0000 		call layer_or
 1238               	.LVL159:
 434:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1239               		.loc 1 434 0
 1240 02d6 00C0      		rjmp .L94
 1241               	.L104:
 436:tmk_core/common/action.c ****                             break;
 1242               		.loc 1 436 0
 1243 02d8 0E94 0000 		call layer_xor
 1244               	.LVL160:
 437:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1245               		.loc 1 437 0
 1246 02dc 00C0      		rjmp .L94
 1247               	.L105:
 439:tmk_core/common/action.c ****                             break;
 1248               		.loc 1 439 0
 1249 02de 0E94 0000 		call layer_state_set
 1250               	.LVL161:
 440:tmk_core/common/action.c ****                     }
 1251               		.loc 1 440 0
 1252 02e2 00C0      		rjmp .L94
 1253               	.LVL162:
 1254               	.L64:
 1255 02e4 CF70      		andi r28,lo8(15)
 1256               	.LVL163:
 1257               	.LBE27:
 446:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1258               		.loc 1 446 0
 1259 02e6 1123      		tst r17
 1260 02e8 01F0      		breq .L107
 447:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1261               		.loc 1 447 0
 1262 02ea 8C2F      		mov r24,r28
 1263 02ec 0E94 0000 		call layer_on
 1264               	.LVL164:
 448:tmk_core/common/action.c ****             } else {
 1265               		.loc 1 448 0
 1266 02f0 8D2F      		mov r24,r29
 1267 02f2 0E94 0000 		call register_mods
 1268               	.LVL165:
 1269 02f6 00C0      		rjmp .L94
 1270               	.L107:
 450:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1271               		.loc 1 450 0
 1272 02f8 8D2F      		mov r24,r29
 1273 02fa 0E94 0000 		call unregister_mods
 1274               	.LVL166:
 451:tmk_core/common/action.c ****             }
 1275               		.loc 1 451 0
 1276 02fe 8C2F      		mov r24,r28
 1277 0300 0E94 0000 		call layer_off
 1278               	.LVL167:
 1279 0304 00C0      		rjmp .L94
 1280               	.LVL168:
 1281               	.L65:
 457:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1282               		.loc 1 457 0
 1283 0306 D23F      		cpi r29,lo8(-14)
 1284 0308 01F0      		breq .L109
 1285 030a 00F4      		brsh .L110
 1286 030c D03F      		cpi r29,lo8(-16)
 1287 030e 01F0      		breq .L111
 1288 0310 D13F      		cpi r29,lo8(-15)
 1289 0312 01F0      		breq .L112
 1290               	.L108:
 519:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1291               		.loc 1 519 0
 1292 0314 1123      		tst r17
 1293 0316 01F4      		brne .+2
 1294 0318 00C0      		rjmp .L122
 520:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1295               		.loc 1 520 0
 1296 031a 0023      		tst r16
 1297 031c 01F4      		brne .+2
 1298 031e 00C0      		rjmp .L123
 522:tmk_core/common/action.c ****                         } else {
 1299               		.loc 1 522 0
 1300 0320 8D2F      		mov r24,r29
 1301 0322 0E94 0000 		call register_code
 1302               	.LVL169:
 1303 0326 00C0      		rjmp .L59
 1304               	.L110:
 457:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1305               		.loc 1 457 0
 1306 0328 D33F      		cpi r29,lo8(-13)
 1307 032a 01F0      		breq .L113
 1308 032c D43F      		cpi r29,lo8(-12)
 1309 032e 01F4      		brne .L108
 505:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1310               		.loc 1 505 0
 1311 0330 1123      		tst r17
 1312 0332 01F0      		breq .L121
 506:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1313               		.loc 1 506 0
 1314 0334 CF71      		andi r28,lo8(31)
 1315               	.LVL170:
 1316 0336 8C2F      		mov r24,r28
 1317 0338 0E94 0000 		call layer_on
 1318               	.LVL171:
 507:tmk_core/common/action.c ****                     } else {
 1319               		.loc 1 507 0
 1320 033c 63E0      		ldi r22,lo8(3)
 1321 033e 8C2F      		mov r24,r28
 1322 0340 0E94 0000 		call set_oneshot_layer
 1323               	.LVL172:
 1324 0344 00C0      		rjmp .L59
 1325               	.LVL173:
 1326               	.L111:
 460:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1327               		.loc 1 460 0
 1328 0346 1123      		tst r17
 1329 0348 01F0      		breq .L115
 461:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1330               		.loc 1 461 0
 1331 034a 0530      		cpi r16,lo8(5)
 1332 034c 00F4      		brsh .L59
 1333               	.L116:
 462:tmk_core/common/action.c ****                         }
 1334               		.loc 1 462 0
 1335 034e 8C2F      		mov r24,r28
 1336 0350 8F71      		andi r24,lo8(31)
 1337 0352 0E94 0000 		call layer_invert
 1338               	.LVL174:
 1339               	.L59:
 654:tmk_core/common/action.c ****         case ACT_LAYER:
 1340               		.loc 1 654 0
 1341 0356 88EF      		ldi r24,lo8(-8)
 1342 0358 8F0D      		add r24,r15
 1343 035a 8430      		cpi r24,lo8(4)
 1344 035c 00F0      		brlo .+2
 1345 035e 00C0      		rjmp .L73
 1346 0360 00C0      		rjmp .L94
 1347               	.L115:
 465:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1348               		.loc 1 465 0
 1349 0362 0630      		cpi r16,lo8(6)
 1350 0364 00F4      		brsh .L59
 1351 0366 00C0      		rjmp .L116
 1352               	.L112:
 1353 0368 8C2F      		mov r24,r28
 1354 036a 8F71      		andi r24,lo8(31)
 471:tmk_core/common/action.c ****                     break;
 1355               		.loc 1 471 0
 1356 036c 1123      		tst r17
 1357 036e 01F0      		breq .L165
 1358               	.L164:
 525:tmk_core/common/action.c ****                         }
 1359               		.loc 1 525 0
 1360 0370 0E94 0000 		call layer_on
 1361               	.LVL175:
 1362 0374 00C0      		rjmp .L59
 1363               	.L109:
 1364 0376 8C2F      		mov r24,r28
 1365 0378 8F71      		andi r24,lo8(31)
 474:tmk_core/common/action.c ****                     break;
 1366               		.loc 1 474 0
 1367 037a 1123      		tst r17
 1368 037c 01F0      		breq .L164
 1369               	.L165:
 538:tmk_core/common/action.c ****                         }
 1370               		.loc 1 538 0
 1371 037e 0E94 0000 		call layer_off
 1372               	.LVL176:
 1373 0382 00C0      		rjmp .L59
 1374               	.L113:
 477:tmk_core/common/action.c ****                     break;
 1375               		.loc 1 477 0
 1376 0384 1123      		tst r17
 1377 0386 01F0      		breq .L120
 477:tmk_core/common/action.c ****                     break;
 1378               		.loc 1 477 0 is_stmt 0 discriminator 1
 1379 0388 8C2F      		mov r24,r28
 1380 038a 8F71      		andi r24,lo8(31)
 1381 038c 0E94 0000 		call layer_move
 1382               	.LVL177:
 1383 0390 00C0      		rjmp .L59
 1384               	.L120:
 477:tmk_core/common/action.c ****                     break;
 1385               		.loc 1 477 0 discriminator 2
 1386 0392 0E94 0000 		call layer_clear
 1387               	.LVL178:
 1388 0396 00C0      		rjmp .L59
 1389               	.L121:
 509:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1390               		.loc 1 509 0 is_stmt 1
 1391 0398 81E0      		ldi r24,lo8(1)
 1392 039a 0E94 0000 		call clear_oneshot_layer_state
 1393               	.LVL179:
 510:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1394               		.loc 1 510 0
 1395 039e 0230      		cpi r16,lo8(2)
 1396 03a0 00F0      		brlo .L59
 511:tmk_core/common/action.c ****                         }
 1397               		.loc 1 511 0
 1398 03a2 82E0      		ldi r24,lo8(2)
 1399 03a4 0E94 0000 		call clear_oneshot_layer_state
 1400               	.LVL180:
 1401 03a8 00C0      		rjmp .L59
 1402               	.L123:
 525:tmk_core/common/action.c ****                         }
 1403               		.loc 1 525 0
 1404 03aa 8C2F      		mov r24,r28
 1405 03ac 8F71      		andi r24,lo8(31)
 1406 03ae 00C0      		rjmp .L164
 1407               	.L122:
 528:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1408               		.loc 1 528 0
 1409 03b0 0023      		tst r16
 1410 03b2 01F0      		breq .L124
 530:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1411               		.loc 1 530 0
 1412 03b4 D933      		cpi r29,lo8(57)
 1413 03b6 01F4      		brne .L126
 1414               	.LVL181:
 1415               	.LBB28:
 1416               	.LBB29:
 1417               		.loc 2 187 0
 1418 03b8 9FEF      		ldi r25,lo8(255999)
 1419 03ba E7EE      		ldi r30,hi8(255999)
 1420 03bc F3E0      		ldi r31,hlo8(255999)
 1421 03be 9150      	1:	subi r25,1
 1422 03c0 E040      		sbci r30,0
 1423 03c2 F040      		sbci r31,0
 1424 03c4 01F4      		brne 1b
 1425 03c6 00C0      		rjmp .
 1426 03c8 0000      		nop
 1427               	.LVL182:
 1428               	.L126:
 1429               	.LBE29:
 1430               	.LBE28:
 535:tmk_core/common/action.c ****                         } else {
 1431               		.loc 1 535 0
 1432 03ca 8D2F      		mov r24,r29
 1433 03cc 0E94 0000 		call unregister_code
 1434               	.LVL183:
 1435 03d0 00C0      		rjmp .L59
 1436               	.L124:
 538:tmk_core/common/action.c ****                         }
 1437               		.loc 1 538 0
 1438 03d2 8C2F      		mov r24,r28
 1439 03d4 8F71      		andi r24,lo8(31)
 1440 03d6 00C0      		rjmp .L165
 1441               	.L66:
 554:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 1442               		.loc 1 554 0
 1443 03d8 1111      		cpse r17,__zero_reg__
 1444 03da 00C0      		rjmp .L73
 555:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1445               		.loc 1 555 0
 1446 03dc CF70      		andi r28,lo8(15)
 1447               	.LVL184:
 1448 03de C230      		cpi r28,lo8(2)
 1449 03e0 01F0      		breq .L127
 1450 03e2 00F4      		brsh .L128
 1451 03e4 CC23      		tst r28
 1452 03e6 01F0      		breq .L129
 1453 03e8 C130      		cpi r28,lo8(1)
 1454 03ea 01F0      		breq .+2
 1455 03ec 00C0      		rjmp .L59
 560:tmk_core/common/action.c ****                         break;
 1456               		.loc 1 560 0
 1457 03ee 0E94 0000 		call backlight_decrease
 1458               	.LVL185:
 561:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 1459               		.loc 1 561 0
 1460 03f2 00C0      		rjmp .L73
 1461               	.L128:
 555:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1462               		.loc 1 555 0
 1463 03f4 C430      		cpi r28,lo8(4)
 1464 03f6 01F0      		breq .L131
 1465 03f8 00F0      		brlo .L132
 572:tmk_core/common/action.c ****                         break;
 1466               		.loc 1 572 0
 1467 03fa 80E0      		ldi r24,0
 555:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1468               		.loc 1 555 0
 1469 03fc C530      		cpi r28,lo8(5)
 1470 03fe 01F0      		breq .+2
 1471 0400 00C0      		rjmp .L59
 1472               	.L166:
 572:tmk_core/common/action.c ****                         break;
 1473               		.loc 1 572 0
 1474 0402 0E94 0000 		call backlight_level
 1475               	.LVL186:
 573:tmk_core/common/action.c ****                 }
 1476               		.loc 1 573 0
 1477 0406 00C0      		rjmp .L73
 1478               	.L129:
 557:tmk_core/common/action.c ****                         break;
 1479               		.loc 1 557 0
 1480 0408 0E94 0000 		call backlight_increase
 1481               	.LVL187:
 558:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 1482               		.loc 1 558 0
 1483 040c 00C0      		rjmp .L73
 1484               	.L127:
 563:tmk_core/common/action.c ****                         break;
 1485               		.loc 1 563 0
 1486 040e 0E94 0000 		call backlight_toggle
 1487               	.LVL188:
 564:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 1488               		.loc 1 564 0
 1489 0412 00C0      		rjmp .L73
 1490               	.L132:
 566:tmk_core/common/action.c ****                         break;
 1491               		.loc 1 566 0
 1492 0414 0E94 0000 		call backlight_step
 1493               	.LVL189:
 567:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 1494               		.loc 1 567 0
 1495 0418 00C0      		rjmp .L73
 1496               	.L131:
 569:tmk_core/common/action.c ****                         break;
 1497               		.loc 1 569 0
 1498 041a 83E0      		ldi r24,lo8(3)
 1499 041c 00C0      		rjmp .L166
 1500               	.LVL190:
 1501               	.L56:
 1502               	/* epilogue start */
 703:tmk_core/common/action.c **** 
 1503               		.loc 1 703 0
 1504 041e DF91      		pop r29
 1505               	.LVL191:
 1506 0420 CF91      		pop r28
 1507 0422 1F91      		pop r17
 1508 0424 0F91      		pop r16
 1509 0426 FF90      		pop r15
 1510 0428 EF90      		pop r14
 1511               	.LVL192:
 1512 042a DF90      		pop r13
 1513 042c CF90      		pop r12
 1514               	.LVL193:
 1515 042e 0895      		ret
 1516               		.cfi_endproc
 1517               	.LFE111:
 1519               		.section	.text.process_record,"ax",@progbits
 1520               	.global	process_record
 1522               	process_record:
 1523               	.LFB110:
 172:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1524               		.loc 1 172 0
 1525               		.cfi_startproc
 1526               	.LVL194:
 1527 0000 0F93      		push r16
 1528               	.LCFI13:
 1529               		.cfi_def_cfa_offset 3
 1530               		.cfi_offset 16, -2
 1531 0002 1F93      		push r17
 1532               	.LCFI14:
 1533               		.cfi_def_cfa_offset 4
 1534               		.cfi_offset 17, -3
 1535 0004 CF93      		push r28
 1536               	.LCFI15:
 1537               		.cfi_def_cfa_offset 5
 1538               		.cfi_offset 28, -4
 1539 0006 DF93      		push r29
 1540               	.LCFI16:
 1541               		.cfi_def_cfa_offset 6
 1542               		.cfi_offset 29, -5
 1543               	/* prologue: function */
 1544               	/* frame size = 0 */
 1545               	/* stack size = 4 */
 1546               	.L__stack_usage = 4
 1547 0008 EC01      		movw r28,r24
 173:tmk_core/common/action.c ****         return;
 1548               		.loc 1 173 0
 1549 000a 9881      		ld r25,Y
 1550 000c 8981      		ldd r24,Y+1
 1551               	.LVL195:
 1552               	.LBB32:
 1553               	.LBB33:
 1554               		.file 3 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1555               		.loc 3 48 0
 1556 000e 2B81      		ldd r18,Y+3
 1557 0010 3C81      		ldd r19,Y+4
 1558 0012 232B      		or r18,r19
 1559 0014 01F0      		breq .L174
 1560 0016 8F3F      		cpi r24,lo8(-1)
 1561 0018 01F4      		brne .L175
 1562 001a 81E0      		ldi r24,lo8(1)
 1563 001c 9F3F      		cpi r25,lo8(-1)
 1564 001e 01F0      		breq .L171
 1565               	.L175:
 1566 0020 80E0      		ldi r24,0
 1567 0022 00C0      		rjmp .L171
 1568               	.L174:
 1569 0024 81E0      		ldi r24,lo8(1)
 1570               	.L171:
 1571               	.LBE33:
 1572               	.LBE32:
 173:tmk_core/common/action.c ****         return;
 1573               		.loc 1 173 0
 1574 0026 80FD      		sbrc r24,0
 1575 0028 00C0      		rjmp .L170
 177:tmk_core/common/action.c **** 
 1576               		.loc 1 177 0
 1577 002a CE01      		movw r24,r28
 1578 002c 0E94 0000 		call process_record_quantum
 1579               	.LVL196:
 1580 0030 8823      		tst r24
 1581 0032 01F0      		breq .L170
 179:tmk_core/common/action.c ****     dprint("ACTION: ");
 1582               		.loc 1 179 0
 1583 0034 6881      		ld r22,Y
 1584 0036 7981      		ldd r23,Y+1
 1585 0038 8A81      		ldd r24,Y+2
 1586 003a 0E94 0000 		call store_or_get_action
 1587               	.LVL197:
 1588 003e 8C01      		movw r16,r24
 1589               	.LVL198:
 184:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1590               		.loc 1 184 0
 1591 0040 0E94 0000 		call layer_debug
 1592               	.LVL199:
 186:tmk_core/common/action.c **** #endif
 1593               		.loc 1 186 0
 1594 0044 0E94 0000 		call default_layer_debug
 1595               	.LVL200:
 190:tmk_core/common/action.c **** }
 1596               		.loc 1 190 0
 1597 0048 B801      		movw r22,r16
 1598 004a CE01      		movw r24,r28
 1599               	/* epilogue start */
 191:tmk_core/common/action.c **** 
 1600               		.loc 1 191 0
 1601 004c DF91      		pop r29
 1602 004e CF91      		pop r28
 1603               	.LVL201:
 1604 0050 1F91      		pop r17
 1605 0052 0F91      		pop r16
 1606               	.LVL202:
 190:tmk_core/common/action.c **** }
 1607               		.loc 1 190 0
 1608 0054 0C94 0000 		jmp process_action
 1609               	.LVL203:
 1610               	.L170:
 1611               	/* epilogue start */
 191:tmk_core/common/action.c **** 
 1612               		.loc 1 191 0
 1613 0058 DF91      		pop r29
 1614 005a CF91      		pop r28
 1615               	.LVL204:
 1616 005c 1F91      		pop r17
 1617 005e 0F91      		pop r16
 1618 0060 0895      		ret
 1619               		.cfi_endproc
 1620               	.LFE110:
 1622               		.section	.text.process_record_nocache,"ax",@progbits
 1623               	.global	process_record_nocache
 1625               	process_record_nocache:
 1626               	.LFB107:
 134:tmk_core/common/action.c ****     disable_action_cache = true;
 1627               		.loc 1 134 0
 1628               		.cfi_startproc
 1629               	.LVL205:
 1630               	/* prologue: function */
 1631               	/* frame size = 0 */
 1632               	/* stack size = 0 */
 1633               	.L__stack_usage = 0
 135:tmk_core/common/action.c ****     process_record(record);
 1634               		.loc 1 135 0
 1635 0000 21E0      		ldi r18,lo8(1)
 1636 0002 2093 0000 		sts disable_action_cache,r18
 136:tmk_core/common/action.c ****     disable_action_cache = false;
 1637               		.loc 1 136 0
 1638 0006 0E94 0000 		call process_record
 1639               	.LVL206:
 137:tmk_core/common/action.c **** }
 1640               		.loc 1 137 0
 1641 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1642               	/* epilogue start */
 138:tmk_core/common/action.c **** #else
 1643               		.loc 1 138 0
 1644 000e 0895      		ret
 1645               		.cfi_endproc
 1646               	.LFE107:
 1648               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1649               	.global	clear_keyboard_but_mods_and_keys
 1651               	clear_keyboard_but_mods_and_keys:
 1652               	.LFB119:
 892:tmk_core/common/action.c **** 
 893:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 894:tmk_core/common/action.c ****  *
 895:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 896:tmk_core/common/action.c ****  */
 897:tmk_core/common/action.c **** void clear_keyboard(void) {
 898:tmk_core/common/action.c ****     clear_mods();
 899:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 900:tmk_core/common/action.c **** }
 901:tmk_core/common/action.c **** 
 902:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 903:tmk_core/common/action.c ****  *
 904:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 905:tmk_core/common/action.c ****  */
 906:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 907:tmk_core/common/action.c ****     clear_keys();
 908:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 909:tmk_core/common/action.c **** }
 910:tmk_core/common/action.c **** 
 911:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 912:tmk_core/common/action.c ****  *
 913:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 914:tmk_core/common/action.c ****  */
 915:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1653               		.loc 1 915 0
 1654               		.cfi_startproc
 1655               	/* prologue: function */
 1656               	/* frame size = 0 */
 1657               	/* stack size = 0 */
 1658               	.L__stack_usage = 0
 916:tmk_core/common/action.c ****     clear_weak_mods();
 1659               		.loc 1 916 0
 1660 0000 0E94 0000 		call clear_weak_mods
 1661               	.LVL207:
 917:tmk_core/common/action.c ****     clear_macro_mods();
 1662               		.loc 1 917 0
 1663 0004 0E94 0000 		call clear_macro_mods
 1664               	.LVL208:
 918:tmk_core/common/action.c ****     send_keyboard_report();
 1665               		.loc 1 918 0
 1666 0008 0C94 0000 		jmp send_keyboard_report
 1667               	.LVL209:
 1668               		.cfi_endproc
 1669               	.LFE119:
 1671               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1672               	.global	clear_keyboard_but_mods
 1674               	clear_keyboard_but_mods:
 1675               	.LFB118:
 906:tmk_core/common/action.c ****     clear_keys();
 1676               		.loc 1 906 0
 1677               		.cfi_startproc
 1678               	/* prologue: function */
 1679               	/* frame size = 0 */
 1680               	/* stack size = 0 */
 1681               	.L__stack_usage = 0
 907:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1682               		.loc 1 907 0
 1683 0000 0E94 0000 		call clear_keys
 1684               	.LVL210:
 908:tmk_core/common/action.c **** }
 1685               		.loc 1 908 0
 1686 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1687               	.LVL211:
 1688               		.cfi_endproc
 1689               	.LFE118:
 1691               		.section	.text.clear_keyboard,"ax",@progbits
 1692               	.global	clear_keyboard
 1694               	clear_keyboard:
 1695               	.LFB117:
 897:tmk_core/common/action.c ****     clear_mods();
 1696               		.loc 1 897 0
 1697               		.cfi_startproc
 1698               	/* prologue: function */
 1699               	/* frame size = 0 */
 1700               	/* stack size = 0 */
 1701               	.L__stack_usage = 0
 898:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1702               		.loc 1 898 0
 1703 0000 0E94 0000 		call clear_mods
 1704               	.LVL212:
 899:tmk_core/common/action.c **** }
 1705               		.loc 1 899 0
 1706 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1707               	.LVL213:
 1708               		.cfi_endproc
 1709               	.LFE117:
 1711               		.section	.text.is_tap_action,"ax",@progbits
 1712               	.global	is_tap_action
 1714               	is_tap_action:
 1715               	.LFB121:
 919:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 920:tmk_core/common/action.c ****     mousekey_clear();
 921:tmk_core/common/action.c ****     mousekey_send();
 922:tmk_core/common/action.c **** #endif
 923:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 924:tmk_core/common/action.c ****     host_system_send(0);
 925:tmk_core/common/action.c ****     host_consumer_send(0);
 926:tmk_core/common/action.c **** #endif
 927:tmk_core/common/action.c **** }
 928:tmk_core/common/action.c **** 
 929:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 930:tmk_core/common/action.c ****  *
 931:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 932:tmk_core/common/action.c ****  */
 933:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 934:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 935:tmk_core/common/action.c ****     return is_tap_action(action);
 936:tmk_core/common/action.c **** }
 937:tmk_core/common/action.c **** 
 938:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 939:tmk_core/common/action.c ****  *
 940:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 941:tmk_core/common/action.c ****  */
 942:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1716               		.loc 1 942 0
 1717               		.cfi_startproc
 1718               	.LVL214:
 1719               	/* prologue: function */
 1720               	/* frame size = 0 */
 1721               	/* stack size = 0 */
 1722               	.L__stack_usage = 0
 943:tmk_core/common/action.c ****     switch (action.kind.id) {
 1723               		.loc 1 943 0
 1724 0000 E92F      		mov r30,r25
 1725 0002 E295      		swap r30
 1726 0004 EF70      		andi r30,lo8(15)
 1727 0006 E250      		subi r30,lo8(-(-2))
 1728 0008 EE30      		cpi r30,lo8(14)
 1729 000a 00F4      		brsh .L195
 1730 000c F0E0      		ldi r31,0
 1731 000e E050      		subi r30,lo8(-(gs(.L189)))
 1732 0010 F040      		sbci r31,hi8(-(gs(.L189)))
 1733 0012 0C94 0000 		jmp __tablejump2__
 1734               		.p2align	1
 1735               	.L189:
 1736 0016 0000      		.word gs(.L188)
 1737 0018 0000      		.word gs(.L188)
 1738 001a 0000      		.word gs(.L195)
 1739 001c 0000      		.word gs(.L195)
 1740 001e 0000      		.word gs(.L190)
 1741 0020 0000      		.word gs(.L195)
 1742 0022 0000      		.word gs(.L195)
 1743 0024 0000      		.word gs(.L195)
 1744 0026 0000      		.word gs(.L188)
 1745 0028 0000      		.word gs(.L188)
 1746 002a 0000      		.word gs(.L191)
 1747 002c 0000      		.word gs(.L195)
 1748 002e 0000      		.word gs(.L195)
 1749 0030 0000      		.word gs(.L191)
 1750               	.L188:
 944:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 945:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 946:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 947:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 948:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1751               		.loc 1 948 0
 1752 0032 803F      		cpi r24,lo8(-16)
 1753 0034 01F0      		breq .L197
 1754 0036 00F4      		brsh .L193
 1755 0038 883E      		cpi r24,lo8(-24)
 1756 003a 00F4      		brsh .L195
 1757               	.L197:
 949:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 950:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 951:tmk_core/common/action.c ****                 case OP_ONESHOT:
 952:tmk_core/common/action.c ****                     return true;
 1758               		.loc 1 952 0
 1759 003c 81E0      		ldi r24,lo8(1)
 1760               	.LVL215:
 1761               	/* epilogue start */
 953:tmk_core/common/action.c ****             }
 954:tmk_core/common/action.c ****             return false;
 955:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 956:tmk_core/common/action.c ****             switch (action.swap.code) {
 957:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 958:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 959:tmk_core/common/action.c ****                     return true;
 960:tmk_core/common/action.c ****             }
 961:tmk_core/common/action.c ****             return false;
 962:tmk_core/common/action.c ****         case ACT_MACRO:
 963:tmk_core/common/action.c ****         case ACT_FUNCTION:
 964:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 965:tmk_core/common/action.c ****                 return true;
 966:tmk_core/common/action.c ****             }
 967:tmk_core/common/action.c ****             return false;
 968:tmk_core/common/action.c ****     }
 969:tmk_core/common/action.c ****     return false;
 970:tmk_core/common/action.c **** }
 1762               		.loc 1 970 0
 1763 003e 0895      		ret
 1764               	.LVL216:
 1765               	.L193:
 948:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1766               		.loc 1 948 0
 1767 0040 843F      		cpi r24,lo8(-12)
 1768 0042 01F0      		breq .L197
 1769               	.L195:
 954:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1770               		.loc 1 954 0
 1771 0044 80E0      		ldi r24,0
 1772               	.LVL217:
 1773 0046 0895      		ret
 1774               	.LVL218:
 1775               	.L190:
 956:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1776               		.loc 1 956 0
 1777 0048 883E      		cpi r24,lo8(-24)
 1778 004a 00F0      		brlo .L197
 1779 004c 813F      		cpi r24,lo8(-15)
 1780 004e 01F4      		brne .L195
 1781 0050 00C0      		rjmp .L197
 1782               	.L191:
 964:tmk_core/common/action.c ****                 return true;
 1783               		.loc 1 964 0
 1784 0052 93FB      		bst r25,3
 1785 0054 8827      		clr r24
 1786 0056 80F9      		bld r24,0
 1787               	.LVL219:
 1788 0058 0895      		ret
 1789               		.cfi_endproc
 1790               	.LFE121:
 1792               		.section	.text.is_tap_key,"ax",@progbits
 1793               	.global	is_tap_key
 1795               	is_tap_key:
 1796               	.LFB120:
 933:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1797               		.loc 1 933 0
 1798               		.cfi_startproc
 1799               	.LVL220:
 1800               	/* prologue: function */
 1801               	/* frame size = 0 */
 1802               	/* stack size = 0 */
 1803               	.L__stack_usage = 0
 934:tmk_core/common/action.c ****     return is_tap_action(action);
 1804               		.loc 1 934 0
 1805 0000 0E94 0000 		call layer_switch_get_action
 1806               	.LVL221:
 935:tmk_core/common/action.c **** }
 1807               		.loc 1 935 0
 1808 0004 0C94 0000 		jmp is_tap_action
 1809               	.LVL222:
 1810               		.cfi_endproc
 1811               	.LFE120:
 1813               		.section	.text.debug_event,"ax",@progbits
 1814               	.global	debug_event
 1816               	debug_event:
 1817               	.LFB122:
 971:tmk_core/common/action.c **** 
 972:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 973:tmk_core/common/action.c ****  *
 974:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 975:tmk_core/common/action.c ****  */
 976:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1818               		.loc 1 976 0
 1819               		.cfi_startproc
 1820 0000 CF93      		push r28
 1821               	.LCFI17:
 1822               		.cfi_def_cfa_offset 3
 1823               		.cfi_offset 28, -2
 1824 0002 DF93      		push r29
 1825               	.LCFI18:
 1826               		.cfi_def_cfa_offset 4
 1827               		.cfi_offset 29, -3
 1828 0004 00D0      		rcall .
 1829 0006 00D0      		rcall .
 1830 0008 1F92      		push __zero_reg__
 1831               	.LCFI19:
 1832               		.cfi_def_cfa_offset 9
 1833 000a CDB7      		in r28,__SP_L__
 1834 000c DEB7      		in r29,__SP_H__
 1835               	.LCFI20:
 1836               		.cfi_def_cfa_register 28
 1837               	/* prologue: function */
 1838               	/* frame size = 5 */
 1839               	/* stack size = 7 */
 1840               	.L__stack_usage = 7
 1841               	/* epilogue start */
 1842               		.loc 1 976 0
 1843 000e 0F90      		pop __tmp_reg__
 1844 0010 0F90      		pop __tmp_reg__
 1845 0012 0F90      		pop __tmp_reg__
 1846 0014 0F90      		pop __tmp_reg__
 1847 0016 0F90      		pop __tmp_reg__
 1848 0018 DF91      		pop r29
 1849 001a CF91      		pop r28
 1850 001c 0895      		ret
 1851               		.cfi_endproc
 1852               	.LFE122:
 1854               		.section	.text.debug_record,"ax",@progbits
 1855               	.global	debug_record
 1857               	debug_record:
 1858               	.LFB123:
 977:tmk_core/common/action.c **** 
 978:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 979:tmk_core/common/action.c ****  *
 980:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 981:tmk_core/common/action.c ****  */
 982:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1859               		.loc 1 982 0
 1860               		.cfi_startproc
 1861 0000 CF93      		push r28
 1862               	.LCFI21:
 1863               		.cfi_def_cfa_offset 3
 1864               		.cfi_offset 28, -2
 1865 0002 DF93      		push r29
 1866               	.LCFI22:
 1867               		.cfi_def_cfa_offset 4
 1868               		.cfi_offset 29, -3
 1869 0004 00D0      		rcall .
 1870 0006 00D0      		rcall .
 1871 0008 00D0      		rcall .
 1872               	.LCFI23:
 1873               		.cfi_def_cfa_offset 10
 1874 000a CDB7      		in r28,__SP_L__
 1875 000c DEB7      		in r29,__SP_H__
 1876               	.LCFI24:
 1877               		.cfi_def_cfa_register 28
 1878               	/* prologue: function */
 1879               	/* frame size = 6 */
 1880               	/* stack size = 8 */
 1881               	.L__stack_usage = 8
 1882               	/* epilogue start */
 983:tmk_core/common/action.c ****     debug_event(record.event);
 984:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 985:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** }
 1883               		.loc 1 987 0
 1884 000e 2696      		adiw r28,6
 1885 0010 0FB6      		in __tmp_reg__,__SREG__
 1886 0012 F894      		cli
 1887 0014 DEBF      		out __SP_H__,r29
 1888 0016 0FBE      		out __SREG__,__tmp_reg__
 1889 0018 CDBF      		out __SP_L__,r28
 1890 001a DF91      		pop r29
 1891 001c CF91      		pop r28
 1892 001e 0895      		ret
 1893               		.cfi_endproc
 1894               	.LFE123:
 1896               		.section	.text.debug_action,"ax",@progbits
 1897               	.global	debug_action
 1899               	debug_action:
 1900               	.LFB124:
 988:tmk_core/common/action.c **** 
 989:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 990:tmk_core/common/action.c ****  *
 991:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 992:tmk_core/common/action.c ****  */
 993:tmk_core/common/action.c **** void debug_action(action_t action) {
 1901               		.loc 1 993 0
 1902               		.cfi_startproc
 1903               	.LVL223:
 1904               	/* prologue: function */
 1905               	/* frame size = 0 */
 1906               	/* stack size = 0 */
 1907               	.L__stack_usage = 0
 1908               	/* epilogue start */
 994:tmk_core/common/action.c ****     switch (action.kind.id) {
 995:tmk_core/common/action.c ****         case ACT_LMODS:
 996:tmk_core/common/action.c ****             dprint("ACT_LMODS");
 997:tmk_core/common/action.c ****             break;
 998:tmk_core/common/action.c ****         case ACT_RMODS:
 999:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1000:tmk_core/common/action.c ****             break;
1001:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1002:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1003:tmk_core/common/action.c ****             break;
1004:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1005:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1006:tmk_core/common/action.c ****             break;
1007:tmk_core/common/action.c ****         case ACT_USAGE:
1008:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1009:tmk_core/common/action.c ****             break;
1010:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1011:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1012:tmk_core/common/action.c ****             break;
1013:tmk_core/common/action.c ****         case ACT_LAYER:
1014:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1015:tmk_core/common/action.c ****             break;
1016:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1017:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1018:tmk_core/common/action.c ****             break;
1019:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1020:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1021:tmk_core/common/action.c ****             break;
1022:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1023:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1024:tmk_core/common/action.c ****             break;
1025:tmk_core/common/action.c ****         case ACT_MACRO:
1026:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1027:tmk_core/common/action.c ****             break;
1028:tmk_core/common/action.c ****         case ACT_COMMAND:
1029:tmk_core/common/action.c ****             dprint("ACT_COMMAND");
1030:tmk_core/common/action.c ****             break;
1031:tmk_core/common/action.c ****         case ACT_FUNCTION:
1032:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1033:tmk_core/common/action.c ****             break;
1034:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1035:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1036:tmk_core/common/action.c ****             break;
1037:tmk_core/common/action.c ****         default:
1038:tmk_core/common/action.c ****             dprint("UNKNOWN");
1039:tmk_core/common/action.c ****             break;
1040:tmk_core/common/action.c ****     }
1041:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
1042:tmk_core/common/action.c **** }
 1909               		.loc 1 1042 0
 1910 0000 0895      		ret
 1911               		.cfi_endproc
 1912               	.LFE124:
 1914               	.global	disable_action_cache
 1915               		.section	.bss.disable_action_cache,"aw",@nobits
 1918               	disable_action_cache:
 1919 0000 00        		.zero	1
 1920               		.comm	tp_buttons,2,1
 1921               		.text
 1922               	.Letext0:
 1923               		.file 4 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdint.h"
 1924               		.file 5 "tmk_core/common/keycode.h"
 1925               		.file 6 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 1926               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 1927               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 1928               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 1929               		.file 10 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdio.h"
 1930               		.file 11 "tmk_core/common/report.h"
 1931               		.file 12 "tmk_core/common/host.h"
 1932               		.file 13 "tmk_core/common/mousekey.h"
 1933               		.file 14 "tmk_core/common/command.h"
 1934               		.file 15 "tmk_core/common/action_code.h"
 1935               		.file 16 "tmk_core/common/action.h"
 1936               		.file 17 "tmk_core/common/action_layer.h"
 1937               		.file 18 "tmk_core/common/action_util.h"
 1938               		.file 19 "tmk_core/common/debug.h"
 1939               		.file 20 "tmk_core/common/led.h"
 1940               		.file 21 "tmk_core/common/backlight.h"
 1941               		.file 22 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/tmp//ccGfQWWr.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//ccGfQWWr.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//ccGfQWWr.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//ccGfQWWr.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//ccGfQWWr.s:6      *ABS*:0000000000000001 __zero_reg__
/var/tmp//ccGfQWWr.s:13     .text.action_exec:0000000000000000 action_exec
/var/tmp//ccGfQWWr.s:89     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/tmp//ccGfQWWr.s:109    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/tmp//ccGfQWWr.s:131    .text.register_code:0000000000000000 register_code
/var/tmp//ccGfQWWr.s:466    .text.unregister_code:0000000000000000 unregister_code
/var/tmp//ccGfQWWr.s:545    .text.tap_code:0000000000000000 tap_code
/var/tmp//ccGfQWWr.s:598    .text.register_mods:0000000000000000 register_mods
/var/tmp//ccGfQWWr.s:626    .text.unregister_mods:0000000000000000 unregister_mods
/var/tmp//ccGfQWWr.s:654    .text.process_action:0000000000000000 process_action
/var/tmp//ccGfQWWr.s:1522   .text.process_record:0000000000000000 process_record
/var/tmp//ccGfQWWr.s:1625   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/tmp//ccGfQWWr.s:1918   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/tmp//ccGfQWWr.s:1651   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/tmp//ccGfQWWr.s:1674   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/tmp//ccGfQWWr.s:1694   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/tmp//ccGfQWWr.s:1714   .text.is_tap_action:0000000000000000 is_tap_action
/var/tmp//ccGfQWWr.s:1795   .text.is_tap_key:0000000000000000 is_tap_key
/var/tmp//ccGfQWWr.s:1816   .text.debug_event:0000000000000000 debug_event
/var/tmp//ccGfQWWr.s:1857   .text.debug_record:0000000000000000 debug_record
/var/tmp//ccGfQWWr.s:1899   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
add_key
send_keyboard_report
add_mods
host_system_send
host_consumer_send
del_key
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
host_keyboard_leds
led_set
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
backlight_decrease
backlight_level
backlight_increase
backlight_toggle
backlight_step
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_clear_bss

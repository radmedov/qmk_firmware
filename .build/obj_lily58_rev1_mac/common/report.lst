   1               		.file	"report.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.has_anykey,"ax",@progbits
  11               	.global	has_anykey
  13               	has_anykey:
  14               	.LFB100:
  15               		.file 1 "tmk_core/common/report.c"
   1:tmk_core/common/report.c **** /* Copyright 2017 Fred Sundvik
   2:tmk_core/common/report.c ****  *
   3:tmk_core/common/report.c ****  * This program is free software: you can redistribute it and/or modify
   4:tmk_core/common/report.c ****  * it under the terms of the GNU General Public License as published by
   5:tmk_core/common/report.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:tmk_core/common/report.c ****  * (at your option) any later version.
   7:tmk_core/common/report.c ****  *
   8:tmk_core/common/report.c ****  * This program is distributed in the hope that it will be useful,
   9:tmk_core/common/report.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:tmk_core/common/report.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:tmk_core/common/report.c ****  * GNU General Public License for more details.
  12:tmk_core/common/report.c ****  *
  13:tmk_core/common/report.c ****  * You should have received a copy of the GNU General Public License
  14:tmk_core/common/report.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:tmk_core/common/report.c ****  */
  16:tmk_core/common/report.c **** 
  17:tmk_core/common/report.c **** #include "report.h"
  18:tmk_core/common/report.c **** #include "host.h"
  19:tmk_core/common/report.c **** #include "keycode_config.h"
  20:tmk_core/common/report.c **** #include "debug.h"
  21:tmk_core/common/report.c **** #include "util.h"
  22:tmk_core/common/report.c **** #include <string.h>
  23:tmk_core/common/report.c **** 
  24:tmk_core/common/report.c **** /** \brief has_anykey
  25:tmk_core/common/report.c ****  *
  26:tmk_core/common/report.c ****  * FIXME: Needs doc
  27:tmk_core/common/report.c ****  */
  28:tmk_core/common/report.c **** uint8_t has_anykey(report_keyboard_t* keyboard_report) {
  16               		.loc 1 28 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  29:tmk_core/common/report.c ****     uint8_t  cnt = 0;
  30:tmk_core/common/report.c ****     uint8_t* p   = keyboard_report->keys;
  23               		.loc 1 30 0
  24 0000 FC01      		movw r30,r24
  25 0002 3296      		adiw r30,2
  26               	.LVL1:
  31:tmk_core/common/report.c ****     uint8_t  lp  = sizeof(keyboard_report->keys);
  32:tmk_core/common/report.c **** #ifdef NKRO_ENABLE
  33:tmk_core/common/report.c ****     if (keyboard_protocol && keymap_config.nkro) {
  27               		.loc 1 33 0
  28 0004 8091 0000 		lds r24,keyboard_protocol
  29               	.LVL2:
  30 0008 8823      		tst r24
  31 000a 01F0      		breq .L7
  32               		.loc 1 33 0 is_stmt 0 discriminator 1
  33 000c 8091 0000 		lds r24,keymap_config
  34:tmk_core/common/report.c ****         p  = keyboard_report->nkro.bits;
  35:tmk_core/common/report.c ****         lp = sizeof(keyboard_report->nkro.bits);
  34               		.loc 1 35 0 is_stmt 1 discriminator 1
  35 0010 9EE1      		ldi r25,lo8(30)
  33:tmk_core/common/report.c ****         p  = keyboard_report->nkro.bits;
  36               		.loc 1 33 0 discriminator 1
  37 0012 87FF      		sbrs r24,7
  38               	.L7:
  31:tmk_core/common/report.c ****     uint8_t  lp  = sizeof(keyboard_report->keys);
  39               		.loc 1 31 0
  40 0014 96E0      		ldi r25,lo8(6)
  41               	.L2:
  42 0016 80E0      		ldi r24,0
  43               	.LVL3:
  44               	.L3:
  36:tmk_core/common/report.c ****     }
  37:tmk_core/common/report.c **** #endif
  38:tmk_core/common/report.c ****     while (lp--) {
  45               		.loc 1 38 0
  46               	.LVL4:
  47 0018 9150      		subi r25,1
  48 001a 00F4      		brcc .L5
  49               	/* epilogue start */
  39:tmk_core/common/report.c ****         if (*p++) cnt++;
  40:tmk_core/common/report.c ****     }
  41:tmk_core/common/report.c ****     return cnt;
  42:tmk_core/common/report.c **** }
  50               		.loc 1 42 0
  51 001c 0895      		ret
  52               	.L5:
  53               	.LVL5:
  39:tmk_core/common/report.c ****         if (*p++) cnt++;
  54               		.loc 1 39 0
  55 001e 2191      		ld r18,Z+
  56               	.LVL6:
  57 0020 2223      		tst r18
  58 0022 01F0      		breq .L3
  39:tmk_core/common/report.c ****         if (*p++) cnt++;
  59               		.loc 1 39 0 is_stmt 0 discriminator 1
  60 0024 8F5F      		subi r24,lo8(-(1))
  61               	.LVL7:
  62 0026 00C0      		rjmp .L3
  63               		.cfi_endproc
  64               	.LFE100:
  66               		.section	.text.get_first_key,"ax",@progbits
  67               	.global	get_first_key
  69               	get_first_key:
  70               	.LFB101:
  43:tmk_core/common/report.c **** 
  44:tmk_core/common/report.c **** /** \brief get_first_key
  45:tmk_core/common/report.c ****  *
  46:tmk_core/common/report.c ****  * FIXME: Needs doc
  47:tmk_core/common/report.c ****  */
  48:tmk_core/common/report.c **** uint8_t get_first_key(report_keyboard_t* keyboard_report) {
  71               		.loc 1 48 0 is_stmt 1
  72               		.cfi_startproc
  73               	.LVL8:
  74 0000 CF93      		push r28
  75               	.LCFI0:
  76               		.cfi_def_cfa_offset 3
  77               		.cfi_offset 28, -2
  78 0002 DF93      		push r29
  79               	.LCFI1:
  80               		.cfi_def_cfa_offset 4
  81               		.cfi_offset 29, -3
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 2 */
  85               	.L__stack_usage = 2
  49:tmk_core/common/report.c **** #ifdef NKRO_ENABLE
  50:tmk_core/common/report.c ****     if (keyboard_protocol && keymap_config.nkro) {
  86               		.loc 1 50 0
  87 0004 2091 0000 		lds r18,keyboard_protocol
  88 0008 FC01      		movw r30,r24
  89 000a 2223      		tst r18
  90 000c 01F0      		breq .L12
  91               		.loc 1 50 0 is_stmt 0 discriminator 1
  92 000e 2091 0000 		lds r18,keymap_config
  93 0012 27FF      		sbrs r18,7
  94 0014 00C0      		rjmp .L12
  95 0016 3296      		adiw r30,2
  96               	.LBB2:
  51:tmk_core/common/report.c ****         uint8_t i = 0;
  97               		.loc 1 51 0 is_stmt 1
  98 0018 C0E0      		ldi r28,0
  99               	.L13:
 100               	.LVL9:
  52:tmk_core/common/report.c ****         for (; i < KEYBOARD_REPORT_BITS && !keyboard_report->nkro.bits[i]; i++)
 101               		.loc 1 52 0 discriminator 2
 102 001a 2191      		ld r18,Z+
 103 001c 2111      		cpse r18,__zero_reg__
 104 001e 00C0      		rjmp .L14
 105               		.loc 1 52 0 is_stmt 0 discriminator 3
 106 0020 CF5F      		subi r28,lo8(-(1))
 107               	.LVL10:
 108 0022 CE31      		cpi r28,lo8(30)
 109 0024 01F4      		brne .L13
 110               	.L14:
  53:tmk_core/common/report.c ****             ;
  54:tmk_core/common/report.c ****         return i << 3 | biton(keyboard_report->nkro.bits[i]);
 111               		.loc 1 54 0 is_stmt 1
 112 0026 D0E0      		ldi r29,0
 113 0028 8C0F      		add r24,r28
 114 002a 9D1F      		adc r25,r29
 115               	.LVL11:
 116 002c FC01      		movw r30,r24
 117 002e 8281      		ldd r24,Z+2
 118 0030 0E94 0000 		call biton
 119               	.LVL12:
 120 0034 93E0      		ldi r25,3
 121               		1:
 122 0036 CC0F      		lsl r28
 123 0038 DD1F      		rol r29
 124 003a 9A95      		dec r25
 125 003c 01F4      		brne 1b
 126               	.LVL13:
 127 003e 8C2B      		or r24,r28
 128               	.L11:
 129               	/* epilogue start */
 130               	.LBE2:
  55:tmk_core/common/report.c ****     }
  56:tmk_core/common/report.c **** #endif
  57:tmk_core/common/report.c **** #ifdef USB_6KRO_ENABLE
  58:tmk_core/common/report.c ****     uint8_t i = cb_head;
  59:tmk_core/common/report.c ****     do {
  60:tmk_core/common/report.c ****         if (keyboard_report->keys[i] != 0) {
  61:tmk_core/common/report.c ****             break;
  62:tmk_core/common/report.c ****         }
  63:tmk_core/common/report.c ****         i = RO_INC(i);
  64:tmk_core/common/report.c ****     } while (i != cb_tail);
  65:tmk_core/common/report.c ****     return keyboard_report->keys[i];
  66:tmk_core/common/report.c **** #else
  67:tmk_core/common/report.c ****     return keyboard_report->keys[0];
  68:tmk_core/common/report.c **** #endif
  69:tmk_core/common/report.c **** }
 131               		.loc 1 69 0
 132 0040 DF91      		pop r29
 133 0042 CF91      		pop r28
 134 0044 0895      		ret
 135               	.LVL14:
 136               	.L12:
  67:tmk_core/common/report.c **** #endif
 137               		.loc 1 67 0
 138 0046 8281      		ldd r24,Z+2
 139               	.LVL15:
 140 0048 00C0      		rjmp .L11
 141               		.cfi_endproc
 142               	.LFE101:
 144               		.section	.text.add_key_byte,"ax",@progbits
 145               	.global	add_key_byte
 147               	add_key_byte:
 148               	.LFB102:
  70:tmk_core/common/report.c **** 
  71:tmk_core/common/report.c **** /** \brief add key byte
  72:tmk_core/common/report.c ****  *
  73:tmk_core/common/report.c ****  * FIXME: Needs doc
  74:tmk_core/common/report.c ****  */
  75:tmk_core/common/report.c **** void add_key_byte(report_keyboard_t* keyboard_report, uint8_t code) {
 149               		.loc 1 75 0
 150               		.cfi_startproc
 151               	.LVL16:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
 156 0000 9C01      		movw r18,r24
 157               	.LVL17:
 158 0002 FC01      		movw r30,r24
 159 0004 3296      		adiw r30,2
  76:tmk_core/common/report.c **** #ifdef USB_6KRO_ENABLE
  77:tmk_core/common/report.c ****     int8_t i     = cb_head;
  78:tmk_core/common/report.c ****     int8_t empty = -1;
  79:tmk_core/common/report.c ****     if (cb_count) {
  80:tmk_core/common/report.c ****         do {
  81:tmk_core/common/report.c ****             if (keyboard_report->keys[i] == code) {
  82:tmk_core/common/report.c ****                 return;
  83:tmk_core/common/report.c ****             }
  84:tmk_core/common/report.c ****             if (empty == -1 && keyboard_report->keys[i] == 0) {
  85:tmk_core/common/report.c ****                 empty = i;
  86:tmk_core/common/report.c ****             }
  87:tmk_core/common/report.c ****             i = RO_INC(i);
  88:tmk_core/common/report.c ****         } while (i != cb_tail);
  89:tmk_core/common/report.c ****         if (i == cb_tail) {
  90:tmk_core/common/report.c ****             if (cb_tail == cb_head) {
  91:tmk_core/common/report.c ****                 // buffer is full
  92:tmk_core/common/report.c ****                 if (empty == -1) {
  93:tmk_core/common/report.c ****                     // pop head when has no empty space
  94:tmk_core/common/report.c ****                     cb_head = RO_INC(cb_head);
  95:tmk_core/common/report.c ****                     cb_count--;
  96:tmk_core/common/report.c ****                 } else {
  97:tmk_core/common/report.c ****                     // left shift when has empty space
  98:tmk_core/common/report.c ****                     uint8_t offset = 1;
  99:tmk_core/common/report.c ****                     i              = RO_INC(empty);
 100:tmk_core/common/report.c ****                     do {
 101:tmk_core/common/report.c ****                         if (keyboard_report->keys[i] != 0) {
 102:tmk_core/common/report.c ****                             keyboard_report->keys[empty] = keyboard_report->keys[i];
 103:tmk_core/common/report.c ****                             keyboard_report->keys[i]     = 0;
 104:tmk_core/common/report.c ****                             empty                        = RO_INC(empty);
 105:tmk_core/common/report.c ****                         } else {
 106:tmk_core/common/report.c ****                             offset++;
 107:tmk_core/common/report.c ****                         }
 108:tmk_core/common/report.c ****                         i = RO_INC(i);
 109:tmk_core/common/report.c ****                     } while (i != cb_tail);
 110:tmk_core/common/report.c ****                     cb_tail = RO_SUB(cb_tail, offset);
 111:tmk_core/common/report.c ****                 }
 112:tmk_core/common/report.c ****             }
 113:tmk_core/common/report.c ****         }
 114:tmk_core/common/report.c ****     }
 115:tmk_core/common/report.c ****     // add to tail
 116:tmk_core/common/report.c ****     keyboard_report->keys[cb_tail] = code;
 117:tmk_core/common/report.c ****     cb_tail                        = RO_INC(cb_tail);
 118:tmk_core/common/report.c ****     cb_count++;
 119:tmk_core/common/report.c **** #else
 120:tmk_core/common/report.c ****     int8_t i     = 0;
 121:tmk_core/common/report.c ****     int8_t empty = -1;
 160               		.loc 1 121 0
 161 0006 9FEF      		ldi r25,lo8(-1)
 120:tmk_core/common/report.c ****     int8_t empty = -1;
 162               		.loc 1 120 0
 163 0008 80E0      		ldi r24,0
 164               	.LVL18:
 165               	.L26:
 122:tmk_core/common/report.c ****     for (; i < KEYBOARD_REPORT_KEYS; i++) {
 123:tmk_core/common/report.c ****         if (keyboard_report->keys[i] == code) {
 166               		.loc 1 123 0
 167 000a 4191      		ld r20,Z+
 168 000c 4617      		cp r20,r22
 169 000e 01F0      		breq .L23
 124:tmk_core/common/report.c ****             break;
 125:tmk_core/common/report.c ****         }
 126:tmk_core/common/report.c ****         if (empty == -1 && keyboard_report->keys[i] == 0) {
 170               		.loc 1 126 0
 171 0010 9F3F      		cpi r25,lo8(-1)
 172 0012 01F4      		brne .L25
 173               		.loc 1 126 0 is_stmt 0 discriminator 1
 174 0014 4111      		cpse r20,__zero_reg__
 175 0016 00C0      		rjmp .L25
 176               		.loc 1 126 0
 177 0018 982F      		mov r25,r24
 178               	.LVL19:
 179               	.L25:
 180 001a 8F5F      		subi r24,lo8(-(1))
 181               	.LVL20:
 122:tmk_core/common/report.c ****     for (; i < KEYBOARD_REPORT_KEYS; i++) {
 182               		.loc 1 122 0 is_stmt 1
 183 001c 8630      		cpi r24,lo8(6)
 184 001e 01F4      		brne .L26
 127:tmk_core/common/report.c ****             empty = i;
 128:tmk_core/common/report.c ****         }
 129:tmk_core/common/report.c ****     }
 130:tmk_core/common/report.c ****     if (i == KEYBOARD_REPORT_KEYS) {
 131:tmk_core/common/report.c ****         if (empty != -1) {
 185               		.loc 1 131 0
 186 0020 9F3F      		cpi r25,lo8(-1)
 187 0022 01F4      		brne .L28
 188               	.L23:
 189               	/* epilogue start */
 132:tmk_core/common/report.c ****             keyboard_report->keys[empty] = code;
 133:tmk_core/common/report.c ****         }
 134:tmk_core/common/report.c ****     }
 135:tmk_core/common/report.c **** #endif
 136:tmk_core/common/report.c **** }
 190               		.loc 1 136 0
 191 0024 0895      		ret
 192               	.L28:
 132:tmk_core/common/report.c ****             keyboard_report->keys[empty] = code;
 193               		.loc 1 132 0
 194 0026 290F      		add r18,r25
 195 0028 311D      		adc r19,__zero_reg__
 196 002a 97FD      		sbrc r25,7
 197 002c 3A95      		dec r19
 198               	.LVL21:
 199 002e F901      		movw r30,r18
 200 0030 6283      		std Z+2,r22
 201               		.loc 1 136 0
 202 0032 0895      		ret
 203               		.cfi_endproc
 204               	.LFE102:
 206               		.section	.text.del_key_byte,"ax",@progbits
 207               	.global	del_key_byte
 209               	del_key_byte:
 210               	.LFB103:
 137:tmk_core/common/report.c **** 
 138:tmk_core/common/report.c **** /** \brief del key byte
 139:tmk_core/common/report.c ****  *
 140:tmk_core/common/report.c ****  * FIXME: Needs doc
 141:tmk_core/common/report.c ****  */
 142:tmk_core/common/report.c **** void del_key_byte(report_keyboard_t* keyboard_report, uint8_t code) {
 211               		.loc 1 142 0
 212               		.cfi_startproc
 213               	.LVL22:
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 216               	/* stack size = 0 */
 217               	.L__stack_usage = 0
 218 0000 FC01      		movw r30,r24
 219 0002 3296      		adiw r30,2
 220 0004 0896      		adiw r24,8
 221               	.LVL23:
 222               	.L33:
 223               	.LBB3:
 143:tmk_core/common/report.c **** #ifdef USB_6KRO_ENABLE
 144:tmk_core/common/report.c ****     uint8_t i = cb_head;
 145:tmk_core/common/report.c ****     if (cb_count) {
 146:tmk_core/common/report.c ****         do {
 147:tmk_core/common/report.c ****             if (keyboard_report->keys[i] == code) {
 148:tmk_core/common/report.c ****                 keyboard_report->keys[i] = 0;
 149:tmk_core/common/report.c ****                 cb_count--;
 150:tmk_core/common/report.c ****                 if (cb_count == 0) {
 151:tmk_core/common/report.c ****                     // reset head and tail
 152:tmk_core/common/report.c ****                     cb_tail = cb_head = 0;
 153:tmk_core/common/report.c ****                 }
 154:tmk_core/common/report.c ****                 if (i == RO_DEC(cb_tail)) {
 155:tmk_core/common/report.c ****                     // left shift when next to tail
 156:tmk_core/common/report.c ****                     do {
 157:tmk_core/common/report.c ****                         cb_tail = RO_DEC(cb_tail);
 158:tmk_core/common/report.c ****                         if (keyboard_report->keys[RO_DEC(cb_tail)] != 0) {
 159:tmk_core/common/report.c ****                             break;
 160:tmk_core/common/report.c ****                         }
 161:tmk_core/common/report.c ****                     } while (cb_tail != cb_head);
 162:tmk_core/common/report.c ****                 }
 163:tmk_core/common/report.c ****                 break;
 164:tmk_core/common/report.c ****             }
 165:tmk_core/common/report.c ****             i = RO_INC(i);
 166:tmk_core/common/report.c ****         } while (i != cb_tail);
 167:tmk_core/common/report.c ****     }
 168:tmk_core/common/report.c **** #else
 169:tmk_core/common/report.c ****     for (uint8_t i = 0; i < KEYBOARD_REPORT_KEYS; i++) {
 170:tmk_core/common/report.c ****         if (keyboard_report->keys[i] == code) {
 224               		.loc 1 170 0
 225 0006 2191      		ld r18,Z+
 226               	.LVL24:
 227 0008 2613      		cpse r18,r22
 228 000a 00C0      		rjmp .L32
 171:tmk_core/common/report.c ****             keyboard_report->keys[i] = 0;
 229               		.loc 1 171 0
 230 000c DF01      		movw r26,r30
 231 000e 1197      		sbiw r26,1
 232 0010 1C92      		st X,__zero_reg__
 233               	.L32:
 234               	.LVL25:
 169:tmk_core/common/report.c ****         if (keyboard_report->keys[i] == code) {
 235               		.loc 1 169 0 discriminator 2
 236 0012 E817      		cp r30,r24
 237 0014 F907      		cpc r31,r25
 238 0016 01F4      		brne .L33
 239               	/* epilogue start */
 240               	.LBE3:
 172:tmk_core/common/report.c ****         }
 173:tmk_core/common/report.c ****     }
 174:tmk_core/common/report.c **** #endif
 175:tmk_core/common/report.c **** }
 241               		.loc 1 175 0
 242 0018 0895      		ret
 243               		.cfi_endproc
 244               	.LFE103:
 246               		.section	.text.add_key_bit,"ax",@progbits
 247               	.global	add_key_bit
 249               	add_key_bit:
 250               	.LFB104:
 176:tmk_core/common/report.c **** 
 177:tmk_core/common/report.c **** #ifdef NKRO_ENABLE
 178:tmk_core/common/report.c **** /** \brief add key bit
 179:tmk_core/common/report.c ****  *
 180:tmk_core/common/report.c ****  * FIXME: Needs doc
 181:tmk_core/common/report.c ****  */
 182:tmk_core/common/report.c **** void add_key_bit(report_keyboard_t* keyboard_report, uint8_t code) {
 251               		.loc 1 182 0
 252               		.cfi_startproc
 253               	.LVL26:
 254               	/* prologue: function */
 255               	/* frame size = 0 */
 256               	/* stack size = 0 */
 257               	.L__stack_usage = 0
 183:tmk_core/common/report.c ****     if ((code >> 3) < KEYBOARD_REPORT_BITS) {
 258               		.loc 1 183 0
 259 0000 E62F      		mov r30,r22
 260 0002 E695      		lsr r30
 261 0004 E695      		lsr r30
 262 0006 E695      		lsr r30
 263 0008 EE31      		cpi r30,lo8(30)
 264 000a 00F4      		brsh .L35
 184:tmk_core/common/report.c ****         keyboard_report->nkro.bits[code >> 3] |= 1 << (code & 7);
 265               		.loc 1 184 0
 266 000c E80F      		add r30,r24
 267 000e F92F      		mov r31,r25
 268 0010 F11D      		adc r31,__zero_reg__
 269 0012 6770      		andi r22,lo8(7)
 270               	.LVL27:
 271 0014 21E0      		ldi r18,lo8(1)
 272 0016 30E0      		ldi r19,0
 273 0018 00C0      		rjmp 2f
 274               		1:
 275 001a 220F      		lsl r18
 276               		2:
 277 001c 6A95      		dec r22
 278 001e 02F4      		brpl 1b
 279 0020 8281      		ldd r24,Z+2
 280               	.LVL28:
 281 0022 822B      		or r24,r18
 282 0024 8283      		std Z+2,r24
 283               	.L35:
 284               	/* epilogue start */
 185:tmk_core/common/report.c ****     } else {
 186:tmk_core/common/report.c ****         dprintf("add_key_bit: can't add: %02X\n", code);
 187:tmk_core/common/report.c ****     }
 188:tmk_core/common/report.c **** }
 285               		.loc 1 188 0
 286 0026 0895      		ret
 287               		.cfi_endproc
 288               	.LFE104:
 290               		.section	.text.del_key_bit,"ax",@progbits
 291               	.global	del_key_bit
 293               	del_key_bit:
 294               	.LFB105:
 189:tmk_core/common/report.c **** 
 190:tmk_core/common/report.c **** /** \brief del key bit
 191:tmk_core/common/report.c ****  *
 192:tmk_core/common/report.c ****  * FIXME: Needs doc
 193:tmk_core/common/report.c ****  */
 194:tmk_core/common/report.c **** void del_key_bit(report_keyboard_t* keyboard_report, uint8_t code) {
 295               		.loc 1 194 0
 296               		.cfi_startproc
 297               	.LVL29:
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 0 */
 301               	.L__stack_usage = 0
 195:tmk_core/common/report.c ****     if ((code >> 3) < KEYBOARD_REPORT_BITS) {
 302               		.loc 1 195 0
 303 0000 E62F      		mov r30,r22
 304 0002 E695      		lsr r30
 305 0004 E695      		lsr r30
 306 0006 E695      		lsr r30
 307 0008 EE31      		cpi r30,lo8(30)
 308 000a 00F4      		brsh .L37
 196:tmk_core/common/report.c ****         keyboard_report->nkro.bits[code >> 3] &= ~(1 << (code & 7));
 309               		.loc 1 196 0
 310 000c E80F      		add r30,r24
 311 000e F92F      		mov r31,r25
 312 0010 F11D      		adc r31,__zero_reg__
 313 0012 6770      		andi r22,lo8(7)
 314               	.LVL30:
 315 0014 21E0      		ldi r18,lo8(1)
 316 0016 30E0      		ldi r19,0
 317 0018 00C0      		rjmp 2f
 318               		1:
 319 001a 220F      		lsl r18
 320               		2:
 321 001c 6A95      		dec r22
 322 001e 02F4      		brpl 1b
 323 0020 2095      		com r18
 324 0022 8281      		ldd r24,Z+2
 325               	.LVL31:
 326 0024 2823      		and r18,r24
 327 0026 2283      		std Z+2,r18
 328               	.L37:
 329               	/* epilogue start */
 197:tmk_core/common/report.c ****     } else {
 198:tmk_core/common/report.c ****         dprintf("del_key_bit: can't del: %02X\n", code);
 199:tmk_core/common/report.c ****     }
 200:tmk_core/common/report.c **** }
 330               		.loc 1 200 0
 331 0028 0895      		ret
 332               		.cfi_endproc
 333               	.LFE105:
 335               		.section	.text.add_key_to_report,"ax",@progbits
 336               	.global	add_key_to_report
 338               	add_key_to_report:
 339               	.LFB106:
 201:tmk_core/common/report.c **** #endif
 202:tmk_core/common/report.c **** 
 203:tmk_core/common/report.c **** /** \brief add key to report
 204:tmk_core/common/report.c ****  *
 205:tmk_core/common/report.c ****  * FIXME: Needs doc
 206:tmk_core/common/report.c ****  */
 207:tmk_core/common/report.c **** void add_key_to_report(report_keyboard_t* keyboard_report, uint8_t key) {
 340               		.loc 1 207 0
 341               		.cfi_startproc
 342               	.LVL32:
 343               	/* prologue: function */
 344               	/* frame size = 0 */
 345               	/* stack size = 0 */
 346               	.L__stack_usage = 0
 208:tmk_core/common/report.c **** #ifdef NKRO_ENABLE
 209:tmk_core/common/report.c ****     if (keyboard_protocol && keymap_config.nkro) {
 347               		.loc 1 209 0
 348 0000 2091 0000 		lds r18,keyboard_protocol
 349 0004 2223      		tst r18
 350 0006 01F0      		breq .L40
 351               		.loc 1 209 0 is_stmt 0 discriminator 1
 352 0008 2091 0000 		lds r18,keymap_config
 353 000c 27FD      		sbrc r18,7
 210:tmk_core/common/report.c ****         add_key_bit(keyboard_report, key);
 354               		.loc 1 210 0 is_stmt 1
 355 000e 0C94 0000 		jmp add_key_bit
 356               	.LVL33:
 357               	.L40:
 211:tmk_core/common/report.c ****         return;
 212:tmk_core/common/report.c ****     }
 213:tmk_core/common/report.c **** #endif
 214:tmk_core/common/report.c ****     add_key_byte(keyboard_report, key);
 358               		.loc 1 214 0
 359 0012 0C94 0000 		jmp add_key_byte
 360               	.LVL34:
 361               		.cfi_endproc
 362               	.LFE106:
 364               		.section	.text.del_key_from_report,"ax",@progbits
 365               	.global	del_key_from_report
 367               	del_key_from_report:
 368               	.LFB107:
 215:tmk_core/common/report.c **** }
 216:tmk_core/common/report.c **** 
 217:tmk_core/common/report.c **** /** \brief del key from report
 218:tmk_core/common/report.c ****  *
 219:tmk_core/common/report.c ****  * FIXME: Needs doc
 220:tmk_core/common/report.c ****  */
 221:tmk_core/common/report.c **** void del_key_from_report(report_keyboard_t* keyboard_report, uint8_t key) {
 369               		.loc 1 221 0
 370               		.cfi_startproc
 371               	.LVL35:
 372               	/* prologue: function */
 373               	/* frame size = 0 */
 374               	/* stack size = 0 */
 375               	.L__stack_usage = 0
 222:tmk_core/common/report.c **** #ifdef NKRO_ENABLE
 223:tmk_core/common/report.c ****     if (keyboard_protocol && keymap_config.nkro) {
 376               		.loc 1 223 0
 377 0000 2091 0000 		lds r18,keyboard_protocol
 378 0004 2223      		tst r18
 379 0006 01F0      		breq .L45
 380               		.loc 1 223 0 is_stmt 0 discriminator 1
 381 0008 2091 0000 		lds r18,keymap_config
 382 000c 27FD      		sbrc r18,7
 224:tmk_core/common/report.c ****         del_key_bit(keyboard_report, key);
 383               		.loc 1 224 0 is_stmt 1
 384 000e 0C94 0000 		jmp del_key_bit
 385               	.LVL36:
 386               	.L45:
 225:tmk_core/common/report.c ****         return;
 226:tmk_core/common/report.c ****     }
 227:tmk_core/common/report.c **** #endif
 228:tmk_core/common/report.c ****     del_key_byte(keyboard_report, key);
 387               		.loc 1 228 0
 388 0012 0C94 0000 		jmp del_key_byte
 389               	.LVL37:
 390               		.cfi_endproc
 391               	.LFE107:
 393               		.section	.text.clear_keys_from_report,"ax",@progbits
 394               	.global	clear_keys_from_report
 396               	clear_keys_from_report:
 397               	.LFB108:
 229:tmk_core/common/report.c **** }
 230:tmk_core/common/report.c **** 
 231:tmk_core/common/report.c **** /** \brief clear key from report
 232:tmk_core/common/report.c ****  *
 233:tmk_core/common/report.c ****  * FIXME: Needs doc
 234:tmk_core/common/report.c ****  */
 235:tmk_core/common/report.c **** void clear_keys_from_report(report_keyboard_t* keyboard_report) {
 398               		.loc 1 235 0
 399               		.cfi_startproc
 400               	.LVL38:
 401               	/* prologue: function */
 402               	/* frame size = 0 */
 403               	/* stack size = 0 */
 404               	.L__stack_usage = 0
 405 0000 FC01      		movw r30,r24
 406 0002 3296      		adiw r30,2
 236:tmk_core/common/report.c ****     // not clear mods
 237:tmk_core/common/report.c **** #ifdef NKRO_ENABLE
 238:tmk_core/common/report.c ****     if (keyboard_protocol && keymap_config.nkro) {
 407               		.loc 1 238 0
 408 0004 8091 0000 		lds r24,keyboard_protocol
 409               	.LVL39:
 410 0008 8823      		tst r24
 411 000a 01F0      		breq .L50
 412               		.loc 1 238 0 is_stmt 0 discriminator 1
 413 000c 8091 0000 		lds r24,keymap_config
 414 0010 87FF      		sbrs r24,7
 415 0012 00C0      		rjmp .L50
 239:tmk_core/common/report.c ****         memset(keyboard_report->nkro.bits, 0, sizeof(keyboard_report->nkro.bits));
 416               		.loc 1 239 0 is_stmt 1
 417 0014 8EE1      		ldi r24,lo8(30)
 418               	.L55:
 240:tmk_core/common/report.c ****         return;
 241:tmk_core/common/report.c ****     }
 242:tmk_core/common/report.c **** #endif
 243:tmk_core/common/report.c ****     memset(keyboard_report->keys, 0, sizeof(keyboard_report->keys));
 419               		.loc 1 243 0
 420 0016 DF01      		movw r26,r30
 421               		0:
 422 0018 1D92      		st X+,__zero_reg__
 423 001a 8A95      		dec r24
 424 001c 01F4      		brne 0b
 425               	/* epilogue start */
 244:tmk_core/common/report.c **** }
 426               		.loc 1 244 0
 427 001e 0895      		ret
 428               	.L50:
 243:tmk_core/common/report.c **** }
 429               		.loc 1 243 0
 430 0020 86E0      		ldi r24,lo8(6)
 431 0022 00C0      		rjmp .L55
 432               		.cfi_endproc
 433               	.LFE108:
 435               		.text
 436               	.Letext0:
 437               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdint.h"
 438               		.file 3 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 439               		.file 4 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 440               		.file 5 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 441               		.file 6 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 442               		.file 7 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdio.h"
 443               		.file 8 "tmk_core/common/report.h"
 444               		.file 9 "tmk_core/common/host.h"
 445               		.file 10 "quantum/keycode_config.h"
 446               		.file 11 "tmk_core/common/debug.h"
 447               		.file 12 "tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 report.c
/var/tmp//cceAfW8w.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//cceAfW8w.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//cceAfW8w.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//cceAfW8w.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//cceAfW8w.s:6      *ABS*:0000000000000001 __zero_reg__
/var/tmp//cceAfW8w.s:13     .text.has_anykey:0000000000000000 has_anykey
/var/tmp//cceAfW8w.s:69     .text.get_first_key:0000000000000000 get_first_key
/var/tmp//cceAfW8w.s:147    .text.add_key_byte:0000000000000000 add_key_byte
/var/tmp//cceAfW8w.s:209    .text.del_key_byte:0000000000000000 del_key_byte
/var/tmp//cceAfW8w.s:249    .text.add_key_bit:0000000000000000 add_key_bit
/var/tmp//cceAfW8w.s:293    .text.del_key_bit:0000000000000000 del_key_bit
/var/tmp//cceAfW8w.s:338    .text.add_key_to_report:0000000000000000 add_key_to_report
/var/tmp//cceAfW8w.s:367    .text.del_key_from_report:0000000000000000 del_key_from_report
/var/tmp//cceAfW8w.s:396    .text.clear_keys_from_report:0000000000000000 clear_keys_from_report

UNDEFINED SYMBOLS
keyboard_protocol
keymap_config
biton

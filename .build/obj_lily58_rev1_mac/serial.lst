   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sync_recv,"ax",@progbits
  12               	sync_recv:
  13               	.LFB16:
  14               		.file 1 "keyboards/lily58/serial.c"
   1:keyboards/lily58/serial.c **** /*
   2:keyboards/lily58/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:keyboards/lily58/serial.c ****  *
   4:keyboards/lily58/serial.c ****  * 2018-10-28 checked
   5:keyboards/lily58/serial.c ****  *  avr-gcc 4.9.2
   6:keyboards/lily58/serial.c ****  *  avr-gcc 5.4.0
   7:keyboards/lily58/serial.c ****  *  avr-gcc 7.3.0
   8:keyboards/lily58/serial.c ****  */
   9:keyboards/lily58/serial.c **** 
  10:keyboards/lily58/serial.c **** #ifndef F_CPU
  11:keyboards/lily58/serial.c **** #define F_CPU 16000000
  12:keyboards/lily58/serial.c **** #endif
  13:keyboards/lily58/serial.c **** 
  14:keyboards/lily58/serial.c **** #include <avr/io.h>
  15:keyboards/lily58/serial.c **** #include <avr/interrupt.h>
  16:keyboards/lily58/serial.c **** #include <util/delay.h>
  17:keyboards/lily58/serial.c **** #include <stddef.h>
  18:keyboards/lily58/serial.c **** #include <stdbool.h>
  19:keyboards/lily58/serial.c **** #include "serial.h"
  20:keyboards/lily58/serial.c **** //#include <pro_micro.h>
  21:keyboards/lily58/serial.c **** 
  22:keyboards/lily58/serial.c **** #ifdef SOFT_SERIAL_PIN
  23:keyboards/lily58/serial.c **** 
  24:keyboards/lily58/serial.c **** #ifdef __AVR_ATmega32U4__
  25:keyboards/lily58/serial.c ****   // if using ATmega32U4 I2C, can not use PD0 and PD1 in soft serial.
  26:keyboards/lily58/serial.c ****   #ifdef USE_I2C
  27:keyboards/lily58/serial.c ****     #if SOFT_SERIAL_PIN == D0 || SOFT_SERIAL_PIN == D1
  28:keyboards/lily58/serial.c ****       #error Using ATmega32U4 I2C, so can not use PD0, PD1
  29:keyboards/lily58/serial.c ****     #endif
  30:keyboards/lily58/serial.c ****   #endif
  31:keyboards/lily58/serial.c **** 
  32:keyboards/lily58/serial.c ****   #if SOFT_SERIAL_PIN >= D0 && SOFT_SERIAL_PIN <= D3
  33:keyboards/lily58/serial.c ****     #define SERIAL_PIN_DDR   DDRD
  34:keyboards/lily58/serial.c ****     #define SERIAL_PIN_PORT  PORTD
  35:keyboards/lily58/serial.c ****     #define SERIAL_PIN_INPUT PIND
  36:keyboards/lily58/serial.c ****     #if SOFT_SERIAL_PIN == D0
  37:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD0)
  38:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT0)
  39:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC00) | _BV(ISC01)))
  40:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT0_vect
  41:keyboards/lily58/serial.c ****     #elif  SOFT_SERIAL_PIN == D1
  42:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD1)
  43:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT1)
  44:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC10) | _BV(ISC11)))
  45:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT1_vect
  46:keyboards/lily58/serial.c ****     #elif  SOFT_SERIAL_PIN == D2
  47:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD2)
  48:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT2)
  49:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC20) | _BV(ISC21)))
  50:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT2_vect
  51:keyboards/lily58/serial.c ****     #elif  SOFT_SERIAL_PIN == D3
  52:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD3)
  53:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT3)
  54:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC30) | _BV(ISC31)))
  55:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT3_vect
  56:keyboards/lily58/serial.c ****     #endif
  57:keyboards/lily58/serial.c ****   #elif  SOFT_SERIAL_PIN == E6
  58:keyboards/lily58/serial.c ****     #define SERIAL_PIN_DDR   DDRE
  59:keyboards/lily58/serial.c ****     #define SERIAL_PIN_PORT  PORTE
  60:keyboards/lily58/serial.c ****     #define SERIAL_PIN_INPUT PINE
  61:keyboards/lily58/serial.c ****     #define SERIAL_PIN_MASK  _BV(PE6)
  62:keyboards/lily58/serial.c ****     #define EIMSK_BIT        _BV(INT6)
  63:keyboards/lily58/serial.c ****     #define EICRx_BIT        (~(_BV(ISC60) | _BV(ISC61)))
  64:keyboards/lily58/serial.c ****     #define SERIAL_PIN_INTERRUPT INT6_vect
  65:keyboards/lily58/serial.c ****   #else
  66:keyboards/lily58/serial.c ****   #error invalid SOFT_SERIAL_PIN value
  67:keyboards/lily58/serial.c ****   #endif
  68:keyboards/lily58/serial.c **** 
  69:keyboards/lily58/serial.c **** #else
  70:keyboards/lily58/serial.c ****  #error serial.c now support ATmega32U4 only
  71:keyboards/lily58/serial.c **** #endif
  72:keyboards/lily58/serial.c **** 
  73:keyboards/lily58/serial.c **** //////////////// for backward compatibility ////////////////////////////////
  74:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
  75:keyboards/lily58/serial.c **** /* --- USE Simple API (OLD API, compatible with let's split serial.c) */
  76:keyboards/lily58/serial.c ****   #if SERIAL_SLAVE_BUFFER_LENGTH > 0
  77:keyboards/lily58/serial.c ****   uint8_t volatile serial_slave_buffer[SERIAL_SLAVE_BUFFER_LENGTH] = {0};
  78:keyboards/lily58/serial.c ****   #endif
  79:keyboards/lily58/serial.c ****   #if SERIAL_MASTER_BUFFER_LENGTH > 0
  80:keyboards/lily58/serial.c ****   uint8_t volatile serial_master_buffer[SERIAL_MASTER_BUFFER_LENGTH] = {0};
  81:keyboards/lily58/serial.c ****   #endif
  82:keyboards/lily58/serial.c ****   uint8_t volatile status0 = 0;
  83:keyboards/lily58/serial.c **** 
  84:keyboards/lily58/serial.c **** SSTD_t transactions[] = {
  85:keyboards/lily58/serial.c ****     { (uint8_t *)&status0,
  86:keyboards/lily58/serial.c ****   #if SERIAL_MASTER_BUFFER_LENGTH > 0
  87:keyboards/lily58/serial.c ****       sizeof(serial_master_buffer), (uint8_t *)serial_master_buffer,
  88:keyboards/lily58/serial.c ****   #else
  89:keyboards/lily58/serial.c ****       0, (uint8_t *)NULL,
  90:keyboards/lily58/serial.c ****   #endif
  91:keyboards/lily58/serial.c ****   #if SERIAL_SLAVE_BUFFER_LENGTH > 0
  92:keyboards/lily58/serial.c ****       sizeof(serial_slave_buffer), (uint8_t *)serial_slave_buffer
  93:keyboards/lily58/serial.c ****   #else
  94:keyboards/lily58/serial.c ****       0, (uint8_t *)NULL,
  95:keyboards/lily58/serial.c ****   #endif
  96:keyboards/lily58/serial.c ****   }
  97:keyboards/lily58/serial.c **** };
  98:keyboards/lily58/serial.c **** 
  99:keyboards/lily58/serial.c **** void serial_master_init(void)
 100:keyboards/lily58/serial.c **** { soft_serial_initiator_init(transactions, TID_LIMIT(transactions)); }
 101:keyboards/lily58/serial.c **** 
 102:keyboards/lily58/serial.c **** void serial_slave_init(void)
 103:keyboards/lily58/serial.c **** { soft_serial_target_init(transactions, TID_LIMIT(transactions)); }
 104:keyboards/lily58/serial.c **** 
 105:keyboards/lily58/serial.c **** // 0 => no error
 106:keyboards/lily58/serial.c **** // 1 => slave did not respond
 107:keyboards/lily58/serial.c **** // 2 => checksum error
 108:keyboards/lily58/serial.c **** int serial_update_buffers()
 109:keyboards/lily58/serial.c **** {
 110:keyboards/lily58/serial.c ****     int result;
 111:keyboards/lily58/serial.c ****     result = soft_serial_transaction();
 112:keyboards/lily58/serial.c ****     return result;
 113:keyboards/lily58/serial.c **** }
 114:keyboards/lily58/serial.c **** 
 115:keyboards/lily58/serial.c **** #endif // end of Simple API (OLD API, compatible with let's split serial.c)
 116:keyboards/lily58/serial.c **** ////////////////////////////////////////////////////////////////////////////
 117:keyboards/lily58/serial.c **** 
 118:keyboards/lily58/serial.c **** #define ALWAYS_INLINE __attribute__((always_inline))
 119:keyboards/lily58/serial.c **** #define NO_INLINE __attribute__((noinline))
 120:keyboards/lily58/serial.c **** #define _delay_sub_us(x)    __builtin_avr_delay_cycles(x)
 121:keyboards/lily58/serial.c **** 
 122:keyboards/lily58/serial.c **** // parity check
 123:keyboards/lily58/serial.c **** #define ODD_PARITY 1
 124:keyboards/lily58/serial.c **** #define EVEN_PARITY 0
 125:keyboards/lily58/serial.c **** #define PARITY EVEN_PARITY
 126:keyboards/lily58/serial.c **** 
 127:keyboards/lily58/serial.c **** #ifdef SERIAL_DELAY
 128:keyboards/lily58/serial.c ****   // custom setup in config.h
 129:keyboards/lily58/serial.c ****   // #define TID_SEND_ADJUST 2
 130:keyboards/lily58/serial.c ****   // #define SERIAL_DELAY 6             // micro sec
 131:keyboards/lily58/serial.c ****   // #define READ_WRITE_START_ADJUST 30 // cycles
 132:keyboards/lily58/serial.c ****   // #define READ_WRITE_WIDTH_ADJUST 8 // cycles
 133:keyboards/lily58/serial.c **** #else
 134:keyboards/lily58/serial.c **** // ============ Standard setups ============
 135:keyboards/lily58/serial.c **** 
 136:keyboards/lily58/serial.c **** #ifndef SELECT_SOFT_SERIAL_SPEED
 137:keyboards/lily58/serial.c **** #define SELECT_SOFT_SERIAL_SPEED 1
 138:keyboards/lily58/serial.c **** //  0: about 189kbps
 139:keyboards/lily58/serial.c **** //  1: about 137kbps (default)
 140:keyboards/lily58/serial.c **** //  2: about 75kbps
 141:keyboards/lily58/serial.c **** //  3: about 39kbps
 142:keyboards/lily58/serial.c **** //  4: about 26kbps
 143:keyboards/lily58/serial.c **** //  5: about 20kbps
 144:keyboards/lily58/serial.c **** #endif
 145:keyboards/lily58/serial.c **** 
 146:keyboards/lily58/serial.c **** #if __GNUC__ < 6
 147:keyboards/lily58/serial.c ****   #define TID_SEND_ADJUST 14
 148:keyboards/lily58/serial.c **** #else
 149:keyboards/lily58/serial.c ****   #define TID_SEND_ADJUST 2
 150:keyboards/lily58/serial.c **** #endif
 151:keyboards/lily58/serial.c **** 
 152:keyboards/lily58/serial.c **** #if SELECT_SOFT_SERIAL_SPEED == 0
 153:keyboards/lily58/serial.c ****   // Very High speed
 154:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 4             // micro sec
 155:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 156:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 33 // cycles
 157:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 158:keyboards/lily58/serial.c ****   #else
 159:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 34 // cycles
 160:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 161:keyboards/lily58/serial.c ****   #endif
 162:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 1
 163:keyboards/lily58/serial.c ****   // High speed
 164:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 6             // micro sec
 165:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 166:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 30 // cycles
 167:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 168:keyboards/lily58/serial.c ****   #else
 169:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 33 // cycles
 170:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 171:keyboards/lily58/serial.c ****   #endif
 172:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 2
 173:keyboards/lily58/serial.c ****   // Middle speed
 174:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 12            // micro sec
 175:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 176:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 177:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 178:keyboards/lily58/serial.c ****   #else
 179:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 180:keyboards/lily58/serial.c ****   #endif
 181:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 3
 182:keyboards/lily58/serial.c ****   // Low speed
 183:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 24            // micro sec
 184:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 185:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 186:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 187:keyboards/lily58/serial.c ****   #else
 188:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 189:keyboards/lily58/serial.c ****   #endif
 190:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 4
 191:keyboards/lily58/serial.c ****   // Very Low speed
 192:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 36            // micro sec
 193:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 194:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 195:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 196:keyboards/lily58/serial.c ****   #else
 197:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 198:keyboards/lily58/serial.c ****   #endif
 199:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 5
 200:keyboards/lily58/serial.c ****   // Ultra Low speed
 201:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 48            // micro sec
 202:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 203:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 204:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 205:keyboards/lily58/serial.c ****   #else
 206:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 207:keyboards/lily58/serial.c ****   #endif
 208:keyboards/lily58/serial.c **** #else
 209:keyboards/lily58/serial.c **** #error invalid SELECT_SOFT_SERIAL_SPEED value
 210:keyboards/lily58/serial.c **** #endif /* SELECT_SOFT_SERIAL_SPEED */
 211:keyboards/lily58/serial.c **** #endif /* SERIAL_DELAY */
 212:keyboards/lily58/serial.c **** 
 213:keyboards/lily58/serial.c **** #define SERIAL_DELAY_HALF1 (SERIAL_DELAY/2)
 214:keyboards/lily58/serial.c **** #define SERIAL_DELAY_HALF2 (SERIAL_DELAY - SERIAL_DELAY/2)
 215:keyboards/lily58/serial.c **** 
 216:keyboards/lily58/serial.c **** #define SLAVE_INT_WIDTH_US 1
 217:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 218:keyboards/lily58/serial.c ****   #define SLAVE_INT_RESPONSE_TIME SERIAL_DELAY
 219:keyboards/lily58/serial.c **** #else
 220:keyboards/lily58/serial.c ****   #define SLAVE_INT_ACK_WIDTH_UNIT 2
 221:keyboards/lily58/serial.c ****   #define SLAVE_INT_ACK_WIDTH 4
 222:keyboards/lily58/serial.c **** #endif
 223:keyboards/lily58/serial.c **** 
 224:keyboards/lily58/serial.c **** static SSTD_t *Transaction_table = NULL;
 225:keyboards/lily58/serial.c **** static uint8_t Transaction_table_size = 0;
 226:keyboards/lily58/serial.c **** 
 227:keyboards/lily58/serial.c **** inline static void serial_delay(void) ALWAYS_INLINE;
 228:keyboards/lily58/serial.c **** inline static
 229:keyboards/lily58/serial.c **** void serial_delay(void) {
 230:keyboards/lily58/serial.c ****   _delay_us(SERIAL_DELAY);
 231:keyboards/lily58/serial.c **** }
 232:keyboards/lily58/serial.c **** 
 233:keyboards/lily58/serial.c **** inline static void serial_delay_half1(void) ALWAYS_INLINE;
 234:keyboards/lily58/serial.c **** inline static
 235:keyboards/lily58/serial.c **** void serial_delay_half1(void) {
 236:keyboards/lily58/serial.c ****   _delay_us(SERIAL_DELAY_HALF1);
 237:keyboards/lily58/serial.c **** }
 238:keyboards/lily58/serial.c **** 
 239:keyboards/lily58/serial.c **** inline static void serial_delay_half2(void) ALWAYS_INLINE;
 240:keyboards/lily58/serial.c **** inline static
 241:keyboards/lily58/serial.c **** void serial_delay_half2(void) {
 242:keyboards/lily58/serial.c ****   _delay_us(SERIAL_DELAY_HALF2);
 243:keyboards/lily58/serial.c **** }
 244:keyboards/lily58/serial.c **** 
 245:keyboards/lily58/serial.c **** inline static void serial_output(void) ALWAYS_INLINE;
 246:keyboards/lily58/serial.c **** inline static
 247:keyboards/lily58/serial.c **** void serial_output(void) {
 248:keyboards/lily58/serial.c ****   SERIAL_PIN_DDR |= SERIAL_PIN_MASK;
 249:keyboards/lily58/serial.c **** }
 250:keyboards/lily58/serial.c **** 
 251:keyboards/lily58/serial.c **** // make the serial pin an input with pull-up resistor
 252:keyboards/lily58/serial.c **** inline static void serial_input_with_pullup(void) ALWAYS_INLINE;
 253:keyboards/lily58/serial.c **** inline static
 254:keyboards/lily58/serial.c **** void serial_input_with_pullup(void) {
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_DDR  &= ~SERIAL_PIN_MASK;
 256:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 257:keyboards/lily58/serial.c **** }
 258:keyboards/lily58/serial.c **** 
 259:keyboards/lily58/serial.c **** inline static uint8_t serial_read_pin(void) ALWAYS_INLINE;
 260:keyboards/lily58/serial.c **** inline static
 261:keyboards/lily58/serial.c **** uint8_t serial_read_pin(void) {
 262:keyboards/lily58/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
 263:keyboards/lily58/serial.c **** }
 264:keyboards/lily58/serial.c **** 
 265:keyboards/lily58/serial.c **** inline static void serial_low(void) ALWAYS_INLINE;
 266:keyboards/lily58/serial.c **** inline static
 267:keyboards/lily58/serial.c **** void serial_low(void) {
 268:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
 269:keyboards/lily58/serial.c **** }
 270:keyboards/lily58/serial.c **** 
 271:keyboards/lily58/serial.c **** inline static void serial_high(void) ALWAYS_INLINE;
 272:keyboards/lily58/serial.c **** inline static
 273:keyboards/lily58/serial.c **** void serial_high(void) {
 274:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 275:keyboards/lily58/serial.c **** }
 276:keyboards/lily58/serial.c **** 
 277:keyboards/lily58/serial.c **** void soft_serial_initiator_init(SSTD_t *sstd_table, int sstd_table_size)
 278:keyboards/lily58/serial.c **** {
 279:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 280:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 281:keyboards/lily58/serial.c ****     serial_output();
 282:keyboards/lily58/serial.c ****     serial_high();
 283:keyboards/lily58/serial.c **** }
 284:keyboards/lily58/serial.c **** 
 285:keyboards/lily58/serial.c **** void soft_serial_target_init(SSTD_t *sstd_table, int sstd_table_size)
 286:keyboards/lily58/serial.c **** {
 287:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 288:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 289:keyboards/lily58/serial.c ****     serial_input_with_pullup();
 290:keyboards/lily58/serial.c **** 
 291:keyboards/lily58/serial.c ****     // Enable INT0-INT3,INT6
 292:keyboards/lily58/serial.c ****     EIMSK |= EIMSK_BIT;
 293:keyboards/lily58/serial.c **** #if SERIAL_PIN_MASK == _BV(PE6)
 294:keyboards/lily58/serial.c ****     // Trigger on falling edge of INT6
 295:keyboards/lily58/serial.c ****     EICRB &= EICRx_BIT;
 296:keyboards/lily58/serial.c **** #else
 297:keyboards/lily58/serial.c ****     // Trigger on falling edge of INT0-INT3
 298:keyboards/lily58/serial.c ****     EICRA &= EICRx_BIT;
 299:keyboards/lily58/serial.c **** #endif
 300:keyboards/lily58/serial.c **** }
 301:keyboards/lily58/serial.c **** 
 302:keyboards/lily58/serial.c **** // Used by the sender to synchronize timing with the reciver.
 303:keyboards/lily58/serial.c **** static void sync_recv(void) NO_INLINE;
 304:keyboards/lily58/serial.c **** static
 305:keyboards/lily58/serial.c **** void sync_recv(void) {
  15               		.loc 1 305 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               		.loc 1 305 0
  23 0000 8EE1      		ldi r24,lo8(30)
  24               	.LVL1:
  25               	.L2:
  26               	.LBB124:
 306:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < SERIAL_DELAY*5 && serial_read_pin(); i++ ) {
  27               		.loc 1 306 0
  28 0002 4A9B      		sbis 0x9,2
  29 0004 00C0      		rjmp .L7
  30               	.LVL2:
  31 0006 8150      		subi r24,lo8(-(-1))
  32               	.LVL3:
  33               		.loc 1 306 0 is_stmt 0 discriminator 4
  34 0008 01F4      		brne .L2
  35               	.LVL4:
  36               	.L7:
  37               	.LBE124:
 307:keyboards/lily58/serial.c ****   }
 308:keyboards/lily58/serial.c ****   // This shouldn't hang if the target disconnects because the
 309:keyboards/lily58/serial.c ****   // serial line will float to high if the target does disconnect.
 310:keyboards/lily58/serial.c ****   while (!serial_read_pin());
  38               		.loc 1 310 0 is_stmt 1 discriminator 1
  39 000a 4A9B      		sbis 0x9,2
  40 000c 00C0      		rjmp .L7
  41               	/* epilogue start */
 311:keyboards/lily58/serial.c **** }
  42               		.loc 1 311 0
  43 000e 0895      		ret
  44               		.cfi_endproc
  45               	.LFE16:
  47               		.section	.text.sync_send,"ax",@progbits
  49               	sync_send:
  50               	.LFB17:
 312:keyboards/lily58/serial.c **** 
 313:keyboards/lily58/serial.c **** // Used by the reciver to send a synchronization signal to the sender.
 314:keyboards/lily58/serial.c **** static void sync_send(void) NO_INLINE;
 315:keyboards/lily58/serial.c **** static
 316:keyboards/lily58/serial.c **** void sync_send(void) {
  51               		.loc 1 316 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57               	.LBB125:
  58               	.LBB126:
 268:keyboards/lily58/serial.c **** }
  59               		.loc 1 268 0
  60 0000 5A98      		cbi 0xb,2
  61               	.LVL5:
  62               	.LBE126:
  63               	.LBE125:
  64               	.LBB127:
  65               	.LBB128:
  66               	.LBB129:
  67               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  68               		.loc 2 276 0
  69 0002 80E2      		ldi r24,lo8(32)
  70 0004 8A95      	1:	dec r24
  71 0006 01F4      		brne 1b
  72               	.LVL6:
  73               	.LBE129:
  74               	.LBE128:
  75               	.LBE127:
  76               	.LBB130:
  77               	.LBB131:
 274:keyboards/lily58/serial.c **** }
  78               		.loc 1 274 0
  79 0008 5A9A      		sbi 0xb,2
  80               	/* epilogue start */
  81               	.LBE131:
  82               	.LBE130:
 317:keyboards/lily58/serial.c ****   serial_low();
 318:keyboards/lily58/serial.c ****   serial_delay();
 319:keyboards/lily58/serial.c ****   serial_high();
 320:keyboards/lily58/serial.c **** }
  83               		.loc 1 320 0
  84 000a 0895      		ret
  85               		.cfi_endproc
  86               	.LFE17:
  88               		.section	.text.serial_read_chunk,"ax",@progbits
  90               	serial_read_chunk:
  91               	.LFB18:
 321:keyboards/lily58/serial.c **** 
 322:keyboards/lily58/serial.c **** // Reads a byte from the serial line
 323:keyboards/lily58/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) NO_INLINE;
 324:keyboards/lily58/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) {
  92               		.loc 1 324 0
  93               		.cfi_startproc
  94               	.LVL7:
  95               	/* prologue: function */
  96               	/* frame size = 0 */
  97               	/* stack size = 0 */
  98               	.L__stack_usage = 0
  99 0000 FC01      		movw r30,r24
 325:keyboards/lily58/serial.c ****     uint8_t byte, i, p, pb;
 326:keyboards/lily58/serial.c **** 
 327:keyboards/lily58/serial.c ****   _delay_sub_us(READ_WRITE_START_ADJUST);
 100               		.loc 1 327 0
 101 0002 3BE0      		ldi r19,lo8(11)
 102 0004 3A95      	1:	dec r19
 103 0006 01F4      		brne 1b
 104               	.LVL8:
 328:keyboards/lily58/serial.c ****   for( i = 0, byte = 0, p = PARITY; i < bit; i++ ) {
 105               		.loc 1 328 0
 106 0008 20E0      		ldi r18,0
 107 000a 90E0      		ldi r25,0
 108 000c 80E0      		ldi r24,0
 109               	.LVL9:
 329:keyboards/lily58/serial.c ****       serial_delay_half1();   // read the middle of pulses
 330:keyboards/lily58/serial.c ****       if( serial_read_pin() ) {
 331:keyboards/lily58/serial.c ****           byte = (byte << 1) | 1; p ^= 1;
 110               		.loc 1 331 0
 111 000e 31E0      		ldi r19,lo8(1)
 112               	.LVL10:
 113               	.L14:
 114               	.LBB132:
 115               	.LBB133:
 116               	.LBB134:
 117               		.loc 2 276 0
 118 0010 40E1      		ldi r20,lo8(16)
 119 0012 4A95      	1:	dec r20
 120 0014 01F4      		brne 1b
 121               	.LVL11:
 122               	.LBE134:
 123               	.LBE133:
 124               	.LBE132:
 125               		.loc 1 331 0
 126 0016 880F      		lsl r24
 127               	.LVL12:
 330:keyboards/lily58/serial.c ****           byte = (byte << 1) | 1; p ^= 1;
 128               		.loc 1 330 0
 129 0018 4A9B      		sbis 0x9,2
 130 001a 00C0      		rjmp .L13
 131               		.loc 1 331 0
 132 001c 8160      		ori r24,lo8(1)
 133               	.LVL13:
 134 001e 2327      		eor r18,r19
 135               	.LVL14:
 136               	.L13:
 332:keyboards/lily58/serial.c ****       } else {
 333:keyboards/lily58/serial.c ****           byte = (byte << 1) | 0; p ^= 0;
 334:keyboards/lily58/serial.c ****       }
 335:keyboards/lily58/serial.c ****       _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 137               		.loc 1 335 0 discriminator 2
 138 0020 42E0      		ldi r20,lo8(2)
 139 0022 4A95      	1:	dec r20
 140 0024 01F4      		brne 1b
 141 0026 0000      		nop
 142               	.LVL15:
 143               	.LBB135:
 144               	.LBB136:
 145               	.LBB137:
 146               		.loc 2 276 0 discriminator 2
 147 0028 40E1      		ldi r20,lo8(16)
 148 002a 4A95      	1:	dec r20
 149 002c 01F4      		brne 1b
 150               	.LVL16:
 151               	.LBE137:
 152               	.LBE136:
 153               	.LBE135:
 328:keyboards/lily58/serial.c ****       serial_delay_half1();   // read the middle of pulses
 154               		.loc 1 328 0 discriminator 2
 155 002e 9F5F      		subi r25,lo8(-(1))
 156               	.LVL17:
 157 0030 6913      		cpse r22,r25
 158 0032 00C0      		rjmp .L14
 159               	.LVL18:
 160               	.LBB138:
 161               	.LBB139:
 162               	.LBB140:
 163               		.loc 2 276 0
 164 0034 90E1      		ldi r25,lo8(16)
 165 0036 9A95      	1:	dec r25
 166 0038 01F4      		brne 1b
 167               	.LVL19:
 168               	.LBE140:
 169               	.LBE139:
 170               	.LBE138:
 171               	.LBB141:
 172               	.LBB142:
 262:keyboards/lily58/serial.c **** }
 173               		.loc 1 262 0
 174 003a 99B1      		in r25,0x9
 175               	.LBE142:
 176               	.LBE141:
 336:keyboards/lily58/serial.c ****       serial_delay_half2();
 337:keyboards/lily58/serial.c ****   }
 338:keyboards/lily58/serial.c ****   /* recive parity bit */
 339:keyboards/lily58/serial.c ****   serial_delay_half1();   // read the middle of pulses
 340:keyboards/lily58/serial.c ****   pb = serial_read_pin();
 341:keyboards/lily58/serial.c ****   _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 177               		.loc 1 341 0
 178 003c 32E0      		ldi r19,lo8(2)
 179 003e 3A95      	1:	dec r19
 180 0040 01F4      		brne 1b
 181 0042 0000      		nop
 182               	.LVL20:
 183               	.LBB144:
 184               	.LBB145:
 185               	.LBB146:
 186               		.loc 2 276 0
 187 0044 40E1      		ldi r20,lo8(16)
 188 0046 4A95      	1:	dec r20
 189 0048 01F4      		brne 1b
 190               	.LVL21:
 191               	.LBE146:
 192               	.LBE145:
 193               	.LBE144:
 194               	.LBB147:
 195               	.LBB143:
 262:keyboards/lily58/serial.c **** }
 196               		.loc 1 262 0
 197 004a 92FB      		bst r25,2
 198 004c 9927      		clr r25
 199 004e 90F9      		bld r25,0
 200               	.LBE143:
 201               	.LBE147:
 342:keyboards/lily58/serial.c ****   serial_delay_half2();
 343:keyboards/lily58/serial.c **** 
 344:keyboards/lily58/serial.c ****   *pterrcount += (p != pb)? 1 : 0;
 202               		.loc 1 344 0
 203 0050 9227      		eor r25,r18
 204 0052 2081      		ld r18,Z
 205               	.LVL22:
 206 0054 920F      		add r25,r18
 207 0056 9083      		st Z,r25
 208               	/* epilogue start */
 345:keyboards/lily58/serial.c **** 
 346:keyboards/lily58/serial.c ****   return byte;
 347:keyboards/lily58/serial.c **** }
 209               		.loc 1 347 0
 210 0058 0895      		ret
 211               		.cfi_endproc
 212               	.LFE18:
 214               		.section	.text.serial_recive_packet,"ax",@progbits
 216               	serial_recive_packet:
 217               	.LFB21:
 348:keyboards/lily58/serial.c **** 
 349:keyboards/lily58/serial.c **** // Sends a byte with MSB ordering
 350:keyboards/lily58/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) NO_INLINE;
 351:keyboards/lily58/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) {
 352:keyboards/lily58/serial.c ****     uint8_t b, p;
 353:keyboards/lily58/serial.c ****     for( p = PARITY, b = 1<<(bit-1); b ; b >>= 1) {
 354:keyboards/lily58/serial.c ****         if(data & b) {
 355:keyboards/lily58/serial.c ****             serial_high(); p ^= 1;
 356:keyboards/lily58/serial.c ****         } else {
 357:keyboards/lily58/serial.c ****             serial_low();  p ^= 0;
 358:keyboards/lily58/serial.c ****         }
 359:keyboards/lily58/serial.c ****         serial_delay();
 360:keyboards/lily58/serial.c ****     }
 361:keyboards/lily58/serial.c ****     /* send parity bit */
 362:keyboards/lily58/serial.c ****     if(p & 1) { serial_high(); }
 363:keyboards/lily58/serial.c ****     else      { serial_low(); }
 364:keyboards/lily58/serial.c ****     serial_delay();
 365:keyboards/lily58/serial.c **** 
 366:keyboards/lily58/serial.c ****     serial_low(); // sync_send() / senc_recv() need raise edge
 367:keyboards/lily58/serial.c **** }
 368:keyboards/lily58/serial.c **** 
 369:keyboards/lily58/serial.c **** static void serial_send_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 370:keyboards/lily58/serial.c **** static
 371:keyboards/lily58/serial.c **** void serial_send_packet(uint8_t *buffer, uint8_t size) {
 372:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < size; ++i) {
 373:keyboards/lily58/serial.c ****     uint8_t data;
 374:keyboards/lily58/serial.c ****     data = buffer[i];
 375:keyboards/lily58/serial.c ****     sync_send();
 376:keyboards/lily58/serial.c ****     serial_write_chunk(data,8);
 377:keyboards/lily58/serial.c ****   }
 378:keyboards/lily58/serial.c **** }
 379:keyboards/lily58/serial.c **** 
 380:keyboards/lily58/serial.c **** static uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 381:keyboards/lily58/serial.c **** static
 382:keyboards/lily58/serial.c **** uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) {
 218               		.loc 1 382 0
 219               		.cfi_startproc
 220               	.LVL23:
 221 0000 EF92      		push r14
 222               	.LCFI0:
 223               		.cfi_def_cfa_offset 3
 224               		.cfi_offset 14, -2
 225 0002 FF92      		push r15
 226               	.LCFI1:
 227               		.cfi_def_cfa_offset 4
 228               		.cfi_offset 15, -3
 229 0004 0F93      		push r16
 230               	.LCFI2:
 231               		.cfi_def_cfa_offset 5
 232               		.cfi_offset 16, -4
 233 0006 1F93      		push r17
 234               	.LCFI3:
 235               		.cfi_def_cfa_offset 6
 236               		.cfi_offset 17, -5
 237 0008 CF93      		push r28
 238               	.LCFI4:
 239               		.cfi_def_cfa_offset 7
 240               		.cfi_offset 28, -6
 241 000a DF93      		push r29
 242               	.LCFI5:
 243               		.cfi_def_cfa_offset 8
 244               		.cfi_offset 29, -7
 245 000c 1F92      		push __zero_reg__
 246               	.LCFI6:
 247               		.cfi_def_cfa_offset 9
 248 000e CDB7      		in r28,__SP_L__
 249 0010 DEB7      		in r29,__SP_H__
 250               	.LCFI7:
 251               		.cfi_def_cfa_register 28
 252               	/* prologue: function */
 253               	/* frame size = 1 */
 254               	/* stack size = 7 */
 255               	.L__stack_usage = 7
 383:keyboards/lily58/serial.c ****   uint8_t pecount = 0;
 256               		.loc 1 383 0
 257 0012 1982      		std Y+1,__zero_reg__
 258               	.LVL24:
 259 0014 8C01      		movw r16,r24
 260 0016 7C01      		movw r14,r24
 261 0018 E60E      		add r14,r22
 262 001a F11C      		adc r15,__zero_reg__
 263               	.LVL25:
 264               	.L17:
 265               	.LBB148:
 384:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < size; ++i) {
 266               		.loc 1 384 0 discriminator 1
 267 001c 0E15      		cp r16,r14
 268 001e 1F05      		cpc r17,r15
 269 0020 01F4      		brne .L18
 270               	.LBE148:
 385:keyboards/lily58/serial.c ****     uint8_t data;
 386:keyboards/lily58/serial.c ****     sync_recv();
 387:keyboards/lily58/serial.c ****     data = serial_read_chunk(&pecount, 8);
 388:keyboards/lily58/serial.c ****     buffer[i] = data;
 389:keyboards/lily58/serial.c ****   }
 390:keyboards/lily58/serial.c ****   return pecount == 0;
 271               		.loc 1 390 0
 272 0022 81E0      		ldi r24,lo8(1)
 273 0024 9981      		ldd r25,Y+1
 274 0026 9111      		cpse r25,__zero_reg__
 275 0028 80E0      		ldi r24,0
 276               	.L16:
 277               	/* epilogue start */
 391:keyboards/lily58/serial.c **** }
 278               		.loc 1 391 0
 279 002a 0F90      		pop __tmp_reg__
 280 002c DF91      		pop r29
 281 002e CF91      		pop r28
 282 0030 1F91      		pop r17
 283 0032 0F91      		pop r16
 284               	.LVL26:
 285 0034 FF90      		pop r15
 286 0036 EF90      		pop r14
 287 0038 0895      		ret
 288               	.LVL27:
 289               	.L18:
 290               	.LBB150:
 291               	.LBB149:
 386:keyboards/lily58/serial.c ****     data = serial_read_chunk(&pecount, 8);
 292               		.loc 1 386 0 discriminator 3
 293 003a 0E94 0000 		call sync_recv
 294               	.LVL28:
 387:keyboards/lily58/serial.c ****     buffer[i] = data;
 295               		.loc 1 387 0 discriminator 3
 296 003e 68E0      		ldi r22,lo8(8)
 297 0040 CE01      		movw r24,r28
 298 0042 0196      		adiw r24,1
 299 0044 0E94 0000 		call serial_read_chunk
 300               	.LVL29:
 388:keyboards/lily58/serial.c ****   }
 301               		.loc 1 388 0 discriminator 3
 302 0048 F801      		movw r30,r16
 303 004a 8193      		st Z+,r24
 304 004c 8F01      		movw r16,r30
 305               	.LVL30:
 306 004e 00C0      		rjmp .L17
 307               	.LBE149:
 308               	.LBE150:
 309               		.cfi_endproc
 310               	.LFE21:
 312               		.section	.text.soft_serial_initiator_init,"ax",@progbits
 313               	.global	soft_serial_initiator_init
 315               	soft_serial_initiator_init:
 316               	.LFB14:
 278:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 317               		.loc 1 278 0
 318               		.cfi_startproc
 319               	.LVL31:
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 0 */
 323               	.L__stack_usage = 0
 279:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 324               		.loc 1 279 0
 325 0000 9093 0000 		sts Transaction_table+1,r25
 326 0004 8093 0000 		sts Transaction_table,r24
 280:keyboards/lily58/serial.c ****     serial_output();
 327               		.loc 1 280 0
 328 0008 6093 0000 		sts Transaction_table_size,r22
 329               	.LBB151:
 330               	.LBB152:
 248:keyboards/lily58/serial.c **** }
 331               		.loc 1 248 0
 332 000c 529A      		sbi 0xa,2
 333               	.LBE152:
 334               	.LBE151:
 335               	.LBB153:
 336               	.LBB154:
 274:keyboards/lily58/serial.c **** }
 337               		.loc 1 274 0
 338 000e 5A9A      		sbi 0xb,2
 339               	/* epilogue start */
 340               	.LBE154:
 341               	.LBE153:
 283:keyboards/lily58/serial.c **** 
 342               		.loc 1 283 0
 343 0010 0895      		ret
 344               		.cfi_endproc
 345               	.LFE14:
 347               		.section	.text.soft_serial_target_init,"ax",@progbits
 348               	.global	soft_serial_target_init
 350               	soft_serial_target_init:
 351               	.LFB15:
 286:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 352               		.loc 1 286 0
 353               		.cfi_startproc
 354               	.LVL32:
 355               	/* prologue: function */
 356               	/* frame size = 0 */
 357               	/* stack size = 0 */
 358               	.L__stack_usage = 0
 287:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 359               		.loc 1 287 0
 360 0000 9093 0000 		sts Transaction_table+1,r25
 361 0004 8093 0000 		sts Transaction_table,r24
 288:keyboards/lily58/serial.c ****     serial_input_with_pullup();
 362               		.loc 1 288 0
 363 0008 6093 0000 		sts Transaction_table_size,r22
 364               	.LBB155:
 365               	.LBB156:
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 366               		.loc 1 255 0
 367 000c 5298      		cbi 0xa,2
 256:keyboards/lily58/serial.c **** }
 368               		.loc 1 256 0
 369 000e 5A9A      		sbi 0xb,2
 370               	.LBE156:
 371               	.LBE155:
 292:keyboards/lily58/serial.c **** #if SERIAL_PIN_MASK == _BV(PE6)
 372               		.loc 1 292 0
 373 0010 EA9A      		sbi 0x1d,2
 298:keyboards/lily58/serial.c **** #endif
 374               		.loc 1 298 0
 375 0012 E9E6      		ldi r30,lo8(105)
 376 0014 F0E0      		ldi r31,0
 377 0016 8081      		ld r24,Z
 378               	.LVL33:
 379 0018 8F7C      		andi r24,lo8(-49)
 380 001a 8083      		st Z,r24
 381               	.LVL34:
 382               	/* epilogue start */
 300:keyboards/lily58/serial.c **** 
 383               		.loc 1 300 0
 384 001c 0895      		ret
 385               		.cfi_endproc
 386               	.LFE15:
 388               		.section	.text.serial_write_chunk,"ax",@progbits
 389               	.global	serial_write_chunk
 391               	serial_write_chunk:
 392               	.LFB19:
 351:keyboards/lily58/serial.c ****     uint8_t b, p;
 393               		.loc 1 351 0
 394               		.cfi_startproc
 395               	.LVL35:
 396               	/* prologue: function */
 397               	/* frame size = 0 */
 398               	/* stack size = 0 */
 399               	.L__stack_usage = 0
 353:keyboards/lily58/serial.c ****         if(data & b) {
 400               		.loc 1 353 0
 401 0000 6150      		subi r22,1
 402 0002 770B      		sbc r23,r23
 403               	.LVL36:
 404 0004 91E0      		ldi r25,lo8(1)
 405 0006 00C0      		rjmp 2f
 406               		1:
 407 0008 990F      		lsl r25
 408               		2:
 409 000a 6A95      		dec r22
 410 000c 02F4      		brpl 1b
 411               	.LVL37:
 412 000e 20E0      		ldi r18,0
 355:keyboards/lily58/serial.c ****         } else {
 413               		.loc 1 355 0
 414 0010 31E0      		ldi r19,lo8(1)
 415               	.LVL38:
 416               	.L26:
 353:keyboards/lily58/serial.c ****         if(data & b) {
 417               		.loc 1 353 0 discriminator 1
 418 0012 9111      		cpse r25,__zero_reg__
 419 0014 00C0      		rjmp .L29
 362:keyboards/lily58/serial.c ****     else      { serial_low(); }
 420               		.loc 1 362 0
 421 0016 2223      		tst r18
 422 0018 01F0      		breq .L30
 423               	.LBB157:
 424               	.LBB158:
 274:keyboards/lily58/serial.c **** }
 425               		.loc 1 274 0
 426 001a 5A9A      		sbi 0xb,2
 427               	.L31:
 428               	.LVL39:
 429               	.LBE158:
 430               	.LBE157:
 431               	.LBB159:
 432               	.LBB160:
 433               	.LBB161:
 434               		.loc 2 276 0
 435 001c 80E2      		ldi r24,lo8(32)
 436 001e 8A95      	1:	dec r24
 437 0020 01F4      		brne 1b
 438               	.LVL40:
 439               	.LBE161:
 440               	.LBE160:
 441               	.LBE159:
 442               	.LBB162:
 443               	.LBB163:
 268:keyboards/lily58/serial.c **** }
 444               		.loc 1 268 0
 445 0022 5A98      		cbi 0xb,2
 446               	/* epilogue start */
 447               	.LBE163:
 448               	.LBE162:
 367:keyboards/lily58/serial.c **** 
 449               		.loc 1 367 0
 450 0024 0895      		ret
 451               	.LVL41:
 452               	.L29:
 354:keyboards/lily58/serial.c ****             serial_high(); p ^= 1;
 453               		.loc 1 354 0
 454 0026 492F      		mov r20,r25
 455 0028 4823      		and r20,r24
 456 002a 01F0      		breq .L27
 457               	.LBB164:
 458               	.LBB165:
 274:keyboards/lily58/serial.c **** }
 459               		.loc 1 274 0
 460 002c 5A9A      		sbi 0xb,2
 461               	.LBE165:
 462               	.LBE164:
 355:keyboards/lily58/serial.c ****         } else {
 463               		.loc 1 355 0
 464 002e 2327      		eor r18,r19
 465               	.LVL42:
 466               	.L28:
 467               	.LBB166:
 468               	.LBB167:
 469               	.LBB168:
 470               		.loc 2 276 0 discriminator 2
 471 0030 40E2      		ldi r20,lo8(32)
 472 0032 4A95      	1:	dec r20
 473 0034 01F4      		brne 1b
 474               	.LVL43:
 475               	.LBE168:
 476               	.LBE167:
 477               	.LBE166:
 353:keyboards/lily58/serial.c ****         if(data & b) {
 478               		.loc 1 353 0 discriminator 2
 479 0036 9695      		lsr r25
 480               	.LVL44:
 481 0038 00C0      		rjmp .L26
 482               	.L27:
 483               	.LBB169:
 484               	.LBB170:
 268:keyboards/lily58/serial.c **** }
 485               		.loc 1 268 0
 486 003a 5A98      		cbi 0xb,2
 487 003c 00C0      		rjmp .L28
 488               	.L30:
 489               	.LBE170:
 490               	.LBE169:
 491               	.LBB171:
 492               	.LBB172:
 493 003e 5A98      		cbi 0xb,2
 494 0040 00C0      		rjmp .L31
 495               	.LBE172:
 496               	.LBE171:
 497               		.cfi_endproc
 498               	.LFE19:
 500               		.section	.text.serial_send_packet,"ax",@progbits
 502               	serial_send_packet:
 503               	.LFB20:
 371:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < size; ++i) {
 504               		.loc 1 371 0
 505               		.cfi_startproc
 506               	.LVL45:
 507 0000 FF92      		push r15
 508               	.LCFI8:
 509               		.cfi_def_cfa_offset 3
 510               		.cfi_offset 15, -2
 511 0002 0F93      		push r16
 512               	.LCFI9:
 513               		.cfi_def_cfa_offset 4
 514               		.cfi_offset 16, -3
 515 0004 1F93      		push r17
 516               	.LCFI10:
 517               		.cfi_def_cfa_offset 5
 518               		.cfi_offset 17, -4
 519 0006 CF93      		push r28
 520               	.LCFI11:
 521               		.cfi_def_cfa_offset 6
 522               		.cfi_offset 28, -5
 523 0008 DF93      		push r29
 524               	.LCFI12:
 525               		.cfi_def_cfa_offset 7
 526               		.cfi_offset 29, -6
 527               	/* prologue: function */
 528               	/* frame size = 0 */
 529               	/* stack size = 5 */
 530               	.L__stack_usage = 5
 531               	.LVL46:
 532 000a EC01      		movw r28,r24
 533 000c 8C01      		movw r16,r24
 534 000e 060F      		add r16,r22
 535 0010 111D      		adc r17,__zero_reg__
 536               	.LVL47:
 537               	.L33:
 538               	.LBB173:
 372:keyboards/lily58/serial.c ****     uint8_t data;
 539               		.loc 1 372 0 discriminator 1
 540 0012 C017      		cp r28,r16
 541 0014 D107      		cpc r29,r17
 542 0016 01F4      		brne .L34
 543               	/* epilogue start */
 544               	.LBE173:
 378:keyboards/lily58/serial.c **** 
 545               		.loc 1 378 0
 546 0018 DF91      		pop r29
 547 001a CF91      		pop r28
 548               	.LVL48:
 549 001c 1F91      		pop r17
 550 001e 0F91      		pop r16
 551 0020 FF90      		pop r15
 552 0022 0895      		ret
 553               	.LVL49:
 554               	.L34:
 555               	.LBB175:
 556               	.LBB174:
 374:keyboards/lily58/serial.c ****     sync_send();
 557               		.loc 1 374 0 discriminator 3
 558 0024 F990      		ld r15,Y+
 559               	.LVL50:
 375:keyboards/lily58/serial.c ****     serial_write_chunk(data,8);
 560               		.loc 1 375 0 discriminator 3
 561 0026 0E94 0000 		call sync_send
 562               	.LVL51:
 376:keyboards/lily58/serial.c ****   }
 563               		.loc 1 376 0 discriminator 3
 564 002a 68E0      		ldi r22,lo8(8)
 565 002c 8F2D      		mov r24,r15
 566 002e 0E94 0000 		call serial_write_chunk
 567               	.LVL52:
 568 0032 00C0      		rjmp .L33
 569               	.LBE174:
 570               	.LBE175:
 571               		.cfi_endproc
 572               	.LFE20:
 574               		.section	.text.__vector_3,"ax",@progbits
 575               	.global	__vector_3
 577               	__vector_3:
 578               	.LFB25:
 392:keyboards/lily58/serial.c **** 
 393:keyboards/lily58/serial.c **** inline static
 394:keyboards/lily58/serial.c **** void change_sender2reciver(void) {
 395:keyboards/lily58/serial.c ****     sync_send();          //0
 396:keyboards/lily58/serial.c ****     serial_delay_half1(); //1
 397:keyboards/lily58/serial.c ****     serial_low();         //2
 398:keyboards/lily58/serial.c ****     serial_input_with_pullup(); //2
 399:keyboards/lily58/serial.c ****     serial_delay_half1(); //3
 400:keyboards/lily58/serial.c **** }
 401:keyboards/lily58/serial.c **** 
 402:keyboards/lily58/serial.c **** inline static
 403:keyboards/lily58/serial.c **** void change_reciver2sender(void) {
 404:keyboards/lily58/serial.c ****     sync_recv();     //0
 405:keyboards/lily58/serial.c ****     serial_delay();  //1
 406:keyboards/lily58/serial.c ****     serial_low();    //3
 407:keyboards/lily58/serial.c ****     serial_output(); //3
 408:keyboards/lily58/serial.c ****     serial_delay_half1(); //4
 409:keyboards/lily58/serial.c **** }
 410:keyboards/lily58/serial.c **** 
 411:keyboards/lily58/serial.c **** static inline uint8_t nibble_bits_count(uint8_t bits)
 412:keyboards/lily58/serial.c **** {
 413:keyboards/lily58/serial.c ****     bits = (bits & 0x5) + (bits >> 1 & 0x5);
 414:keyboards/lily58/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 415:keyboards/lily58/serial.c ****     return bits;
 416:keyboards/lily58/serial.c **** }
 417:keyboards/lily58/serial.c **** 
 418:keyboards/lily58/serial.c **** // interrupt handle to be used by the target device
 419:keyboards/lily58/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 579               		.loc 1 419 0
 580               		.cfi_startproc
 581 0000 1F92      		push r1
 582               	.LCFI13:
 583               		.cfi_def_cfa_offset 3
 584               		.cfi_offset 1, -2
 585 0002 0F92      		push r0
 586               	.LCFI14:
 587               		.cfi_def_cfa_offset 4
 588               		.cfi_offset 0, -3
 589 0004 0FB6      		in r0,__SREG__
 590 0006 0F92      		push r0
 591 0008 1124      		clr __zero_reg__
 592 000a 0F93      		push r16
 593               	.LCFI15:
 594               		.cfi_def_cfa_offset 5
 595               		.cfi_offset 16, -4
 596 000c 1F93      		push r17
 597               	.LCFI16:
 598               		.cfi_def_cfa_offset 6
 599               		.cfi_offset 17, -5
 600 000e 2F93      		push r18
 601               	.LCFI17:
 602               		.cfi_def_cfa_offset 7
 603               		.cfi_offset 18, -6
 604 0010 3F93      		push r19
 605               	.LCFI18:
 606               		.cfi_def_cfa_offset 8
 607               		.cfi_offset 19, -7
 608 0012 4F93      		push r20
 609               	.LCFI19:
 610               		.cfi_def_cfa_offset 9
 611               		.cfi_offset 20, -8
 612 0014 5F93      		push r21
 613               	.LCFI20:
 614               		.cfi_def_cfa_offset 10
 615               		.cfi_offset 21, -9
 616 0016 6F93      		push r22
 617               	.LCFI21:
 618               		.cfi_def_cfa_offset 11
 619               		.cfi_offset 22, -10
 620 0018 7F93      		push r23
 621               	.LCFI22:
 622               		.cfi_def_cfa_offset 12
 623               		.cfi_offset 23, -11
 624 001a 8F93      		push r24
 625               	.LCFI23:
 626               		.cfi_def_cfa_offset 13
 627               		.cfi_offset 24, -12
 628 001c 9F93      		push r25
 629               	.LCFI24:
 630               		.cfi_def_cfa_offset 14
 631               		.cfi_offset 25, -13
 632 001e AF93      		push r26
 633               	.LCFI25:
 634               		.cfi_def_cfa_offset 15
 635               		.cfi_offset 26, -14
 636 0020 BF93      		push r27
 637               	.LCFI26:
 638               		.cfi_def_cfa_offset 16
 639               		.cfi_offset 27, -15
 640 0022 EF93      		push r30
 641               	.LCFI27:
 642               		.cfi_def_cfa_offset 17
 643               		.cfi_offset 30, -16
 644 0024 FF93      		push r31
 645               	.LCFI28:
 646               		.cfi_def_cfa_offset 18
 647               		.cfi_offset 31, -17
 648 0026 CF93      		push r28
 649               	.LCFI29:
 650               		.cfi_def_cfa_offset 19
 651               		.cfi_offset 28, -18
 652 0028 DF93      		push r29
 653               	.LCFI30:
 654               		.cfi_def_cfa_offset 20
 655               		.cfi_offset 29, -19
 656 002a 1F92      		push __zero_reg__
 657               	.LCFI31:
 658               		.cfi_def_cfa_offset 21
 659 002c CDB7      		in r28,__SP_L__
 660 002e DEB7      		in r29,__SP_H__
 661               	.LCFI32:
 662               		.cfi_def_cfa_register 28
 663               	/* prologue: Signal */
 664               	/* frame size = 1 */
 665               	/* stack size = 20 */
 666               	.L__stack_usage = 20
 420:keyboards/lily58/serial.c **** 
 421:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 422:keyboards/lily58/serial.c ****   serial_low();
 423:keyboards/lily58/serial.c ****   serial_output();
 424:keyboards/lily58/serial.c ****   SSTD_t *trans = Transaction_table;
 425:keyboards/lily58/serial.c **** #else
 426:keyboards/lily58/serial.c ****   // recive transaction table index
 427:keyboards/lily58/serial.c ****   uint8_t tid, bits;
 428:keyboards/lily58/serial.c ****   uint8_t pecount = 0;
 667               		.loc 1 428 0
 668 0030 1982      		std Y+1,__zero_reg__
 429:keyboards/lily58/serial.c ****   sync_recv();
 669               		.loc 1 429 0
 670 0032 0E94 0000 		call sync_recv
 671               	.LVL53:
 430:keyboards/lily58/serial.c ****   bits = serial_read_chunk(&pecount,7);
 672               		.loc 1 430 0
 673 0036 67E0      		ldi r22,lo8(7)
 674 0038 CE01      		movw r24,r28
 675 003a 0196      		adiw r24,1
 676 003c 0E94 0000 		call serial_read_chunk
 677               	.LVL54:
 431:keyboards/lily58/serial.c ****   tid = bits>>3;
 678               		.loc 1 431 0
 679 0040 082F      		mov r16,r24
 680 0042 0695      		lsr r16
 681 0044 0695      		lsr r16
 682 0046 0695      		lsr r16
 683               	.LVL55:
 684               	.LBB199:
 685               	.LBB200:
 413:keyboards/lily58/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 686               		.loc 1 413 0
 687 0048 982F      		mov r25,r24
 688 004a 9295      		swap r25
 689 004c 9570      		andi r25,lo8(5)
 690 004e 202F      		mov r18,r16
 691 0050 2570      		andi r18,lo8(5)
 692 0052 920F      		add r25,r18
 693               	.LVL56:
 414:keyboards/lily58/serial.c ****     return bits;
 694               		.loc 1 414 0
 695 0054 292F      		mov r18,r25
 696 0056 2370      		andi r18,lo8(3)
 697 0058 9695      		lsr r25
 698 005a 9695      		lsr r25
 699               	.LVL57:
 700               	.LBE200:
 701               	.LBE199:
 432:keyboards/lily58/serial.c ****   bits = (bits&7) != nibble_bits_count(tid);
 433:keyboards/lily58/serial.c ****   if( bits || pecount> 0 || tid > Transaction_table_size ) {
 702               		.loc 1 433 0
 703 005c 8770      		andi r24,lo8(7)
 704               	.LBB202:
 705               	.LBB201:
 414:keyboards/lily58/serial.c ****     return bits;
 706               		.loc 1 414 0
 707 005e 920F      		add r25,r18
 708               	.LBE201:
 709               	.LBE202:
 710               		.loc 1 433 0
 711 0060 8913      		cpse r24,r25
 712 0062 00C0      		rjmp .L35
 713               		.loc 1 433 0 is_stmt 0 discriminator 1
 714 0064 8981      		ldd r24,Y+1
 715 0066 8111      		cpse r24,__zero_reg__
 716 0068 00C0      		rjmp .L35
 717               		.loc 1 433 0 discriminator 2
 718 006a 8091 0000 		lds r24,Transaction_table_size
 719 006e 8017      		cp r24,r16
 720 0070 00F0      		brlo .L35
 721               	.LVL58:
 722               	.LBB203:
 723               	.LBB204:
 724               	.LBB205:
 725               		.loc 2 276 0 is_stmt 1
 726 0072 20E1      		ldi r18,lo8(16)
 727 0074 2A95      	1:	dec r18
 728 0076 01F4      		brne 1b
 729               	.LVL59:
 730               	.LBE205:
 731               	.LBE204:
 732               	.LBE203:
 733               	.LBB206:
 734               	.LBB207:
 274:keyboards/lily58/serial.c **** }
 735               		.loc 1 274 0
 736 0078 5A9A      		sbi 0xb,2
 737               	.LBE207:
 738               	.LBE206:
 739               	.LBB208:
 740               	.LBB209:
 248:keyboards/lily58/serial.c **** }
 741               		.loc 1 248 0
 742 007a 529A      		sbi 0xa,2
 743               	.LBE209:
 744               	.LBE208:
 434:keyboards/lily58/serial.c ****       return;
 435:keyboards/lily58/serial.c ****   }
 436:keyboards/lily58/serial.c ****   serial_delay_half1();
 437:keyboards/lily58/serial.c **** 
 438:keyboards/lily58/serial.c ****   serial_high(); // response step1 low->high
 439:keyboards/lily58/serial.c ****   serial_output();
 440:keyboards/lily58/serial.c ****   _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT*SLAVE_INT_ACK_WIDTH);
 745               		.loc 1 440 0
 746 007c 82E0      		ldi r24,lo8(2)
 747 007e 8A95      	1:	dec r24
 748 0080 01F4      		brne 1b
 749 0082 00C0      		rjmp .
 441:keyboards/lily58/serial.c ****   SSTD_t *trans = &Transaction_table[tid];
 750               		.loc 1 441 0
 751 0084 A8E0      		ldi r26,lo8(8)
 752 0086 0A9F      		mul r16,r26
 753 0088 C001      		movw r24,r0
 754 008a 1124      		clr __zero_reg__
 755 008c 0091 0000 		lds r16,Transaction_table
 756 0090 1091 0000 		lds r17,Transaction_table+1
 757               	.LVL60:
 758 0094 080F      		add r16,r24
 759 0096 191F      		adc r17,r25
 760               	.LVL61:
 761               	.LBB210:
 762               	.LBB211:
 268:keyboards/lily58/serial.c **** }
 763               		.loc 1 268 0
 764 0098 5A98      		cbi 0xb,2
 765               	.LBE211:
 766               	.LBE210:
 442:keyboards/lily58/serial.c ****   serial_low(); // response step2 ack high->low
 443:keyboards/lily58/serial.c **** #endif
 444:keyboards/lily58/serial.c **** 
 445:keyboards/lily58/serial.c ****   // target send phase
 446:keyboards/lily58/serial.c ****   if( trans->target2initiator_buffer_size > 0 )
 767               		.loc 1 446 0
 768 009a F801      		movw r30,r16
 769 009c 6581      		ldd r22,Z+5
 770 009e 6623      		tst r22
 771 00a0 01F0      		breq .L37
 447:keyboards/lily58/serial.c ****       serial_send_packet((uint8_t *)trans->target2initiator_buffer,
 772               		.loc 1 447 0
 773 00a2 8681      		ldd r24,Z+6
 774 00a4 9781      		ldd r25,Z+7
 775 00a6 0E94 0000 		call serial_send_packet
 776               	.LVL62:
 777               	.L37:
 778               	.LBB212:
 779               	.LBB213:
 395:keyboards/lily58/serial.c ****     serial_delay_half1(); //1
 780               		.loc 1 395 0
 781 00aa 0E94 0000 		call sync_send
 782               	.LVL63:
 783               	.LBB214:
 784               	.LBB215:
 785               	.LBB216:
 786               		.loc 2 276 0
 787 00ae F0E1      		ldi r31,lo8(16)
 788 00b0 FA95      	1:	dec r31
 789 00b2 01F4      		brne 1b
 790               	.LVL64:
 791               	.LBE216:
 792               	.LBE215:
 793               	.LBE214:
 794               	.LBB217:
 795               	.LBB218:
 268:keyboards/lily58/serial.c **** }
 796               		.loc 1 268 0
 797 00b4 5A98      		cbi 0xb,2
 798               	.LBE218:
 799               	.LBE217:
 800               	.LBB219:
 801               	.LBB220:
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 802               		.loc 1 255 0
 803 00b6 5298      		cbi 0xa,2
 256:keyboards/lily58/serial.c **** }
 804               		.loc 1 256 0
 805 00b8 5A9A      		sbi 0xb,2
 806               	.LVL65:
 807               	.LBE220:
 808               	.LBE219:
 809               	.LBB221:
 810               	.LBB222:
 811               	.LBB223:
 812               		.loc 2 276 0
 813 00ba 20E1      		ldi r18,lo8(16)
 814 00bc 2A95      	1:	dec r18
 815 00be 01F4      		brne 1b
 816               	.LVL66:
 817               	.LBE223:
 818               	.LBE222:
 819               	.LBE221:
 820               	.LBE213:
 821               	.LBE212:
 448:keyboards/lily58/serial.c ****                          trans->target2initiator_buffer_size);
 449:keyboards/lily58/serial.c ****   // target switch to input
 450:keyboards/lily58/serial.c ****   change_sender2reciver();
 451:keyboards/lily58/serial.c **** 
 452:keyboards/lily58/serial.c ****   // target recive phase
 453:keyboards/lily58/serial.c ****   if( trans->initiator2target_buffer_size > 0 ) {
 822               		.loc 1 453 0
 823 00c0 D801      		movw r26,r16
 824 00c2 1296      		adiw r26,2
 825 00c4 6C91      		ld r22,X
 826 00c6 1297      		sbiw r26,2
 827 00c8 6623      		tst r22
 828 00ca 01F0      		breq .L38
 454:keyboards/lily58/serial.c ****       if (serial_recive_packet((uint8_t *)trans->initiator2target_buffer,
 829               		.loc 1 454 0
 830 00cc 1396      		adiw r26,3
 831 00ce 8D91      		ld r24,X+
 832 00d0 9C91      		ld r25,X
 833 00d2 0E94 0000 		call serial_recive_packet
 834               	.LVL67:
 835 00d6 D801      		movw r26,r16
 836 00d8 ED91      		ld r30,X+
 837 00da FC91      		ld r31,X
 838 00dc 8823      		tst r24
 839 00de 01F0      		breq .L39
 840               	.L45:
 455:keyboards/lily58/serial.c ****                                trans->initiator2target_buffer_size) ) {
 456:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_ACCEPTED;
 457:keyboards/lily58/serial.c ****       } else {
 458:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_DATA_ERROR;
 459:keyboards/lily58/serial.c ****       }
 460:keyboards/lily58/serial.c ****   } else {
 461:keyboards/lily58/serial.c ****       *trans->status = TRANSACTION_ACCEPTED;
 841               		.loc 1 461 0
 842 00e0 88E0      		ldi r24,lo8(8)
 843 00e2 00C0      		rjmp .L46
 844               	.L39:
 458:keyboards/lily58/serial.c ****       }
 845               		.loc 1 458 0
 846 00e4 82E0      		ldi r24,lo8(2)
 847               	.L46:
 848               		.loc 1 461 0
 849 00e6 8083      		st Z,r24
 462:keyboards/lily58/serial.c ****   }
 463:keyboards/lily58/serial.c **** 
 464:keyboards/lily58/serial.c ****   sync_recv(); //weit initiator output to high
 850               		.loc 1 464 0
 851 00e8 0E94 0000 		call sync_recv
 852               	.LVL68:
 853               	.L35:
 854               	/* epilogue start */
 465:keyboards/lily58/serial.c **** }
 855               		.loc 1 465 0
 856 00ec 0F90      		pop __tmp_reg__
 857 00ee DF91      		pop r29
 858 00f0 CF91      		pop r28
 859 00f2 FF91      		pop r31
 860 00f4 EF91      		pop r30
 861 00f6 BF91      		pop r27
 862 00f8 AF91      		pop r26
 863 00fa 9F91      		pop r25
 864 00fc 8F91      		pop r24
 865 00fe 7F91      		pop r23
 866 0100 6F91      		pop r22
 867 0102 5F91      		pop r21
 868 0104 4F91      		pop r20
 869 0106 3F91      		pop r19
 870 0108 2F91      		pop r18
 871 010a 1F91      		pop r17
 872 010c 0F91      		pop r16
 873 010e 0F90      		pop r0
 874 0110 0FBE      		out __SREG__,r0
 875 0112 0F90      		pop r0
 876 0114 1F90      		pop r1
 877 0116 1895      		reti
 878               	.LVL69:
 879               	.L38:
 461:keyboards/lily58/serial.c ****   }
 880               		.loc 1 461 0
 881 0118 ED91      		ld r30,X+
 882 011a FC91      		ld r31,X
 883 011c 00C0      		rjmp .L45
 884               		.cfi_endproc
 885               	.LFE25:
 887               		.section	.text.soft_serial_transaction,"ax",@progbits
 888               	.global	soft_serial_transaction
 890               	soft_serial_transaction:
 891               	.LFB26:
 466:keyboards/lily58/serial.c **** 
 467:keyboards/lily58/serial.c **** /////////
 468:keyboards/lily58/serial.c **** //  start transaction by initiator
 469:keyboards/lily58/serial.c **** //
 470:keyboards/lily58/serial.c **** // int  soft_serial_transaction(int sstd_index)
 471:keyboards/lily58/serial.c **** //
 472:keyboards/lily58/serial.c **** // Returns:
 473:keyboards/lily58/serial.c **** //    TRANSACTION_END
 474:keyboards/lily58/serial.c **** //    TRANSACTION_NO_RESPONSE
 475:keyboards/lily58/serial.c **** //    TRANSACTION_DATA_ERROR
 476:keyboards/lily58/serial.c **** // this code is very time dependent, so we need to disable interrupts
 477:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 478:keyboards/lily58/serial.c **** int  soft_serial_transaction(void) {
 479:keyboards/lily58/serial.c ****   SSTD_t *trans = Transaction_table;
 480:keyboards/lily58/serial.c **** #else
 481:keyboards/lily58/serial.c **** int  soft_serial_transaction(int sstd_index) {
 892               		.loc 1 481 0
 893               		.cfi_startproc
 894               	.LVL70:
 895 0000 0F93      		push r16
 896               	.LCFI33:
 897               		.cfi_def_cfa_offset 3
 898               		.cfi_offset 16, -2
 899 0002 1F93      		push r17
 900               	.LCFI34:
 901               		.cfi_def_cfa_offset 4
 902               		.cfi_offset 17, -3
 903 0004 CF93      		push r28
 904               	.LCFI35:
 905               		.cfi_def_cfa_offset 5
 906               		.cfi_offset 28, -4
 907 0006 DF93      		push r29
 908               	.LCFI36:
 909               		.cfi_def_cfa_offset 6
 910               		.cfi_offset 29, -5
 911               	/* prologue: function */
 912               	/* frame size = 0 */
 913               	/* stack size = 4 */
 914               	.L__stack_usage = 4
 482:keyboards/lily58/serial.c ****   if( sstd_index > Transaction_table_size )
 915               		.loc 1 482 0
 916 0008 2091 0000 		lds r18,Transaction_table_size
 917 000c 2817      		cp r18,r24
 918 000e 1906      		cpc __zero_reg__,r25
 919 0010 04F4      		brge .+2
 920 0012 00C0      		rjmp .L56
 483:keyboards/lily58/serial.c ****       return TRANSACTION_TYPE_ERROR;
 484:keyboards/lily58/serial.c ****   SSTD_t *trans = &Transaction_table[sstd_index];
 921               		.loc 1 484 0
 922 0014 8C01      		movw r16,r24
 923 0016 93E0      		ldi r25,3
 924               		1:
 925 0018 000F      		lsl r16
 926 001a 111F      		rol r17
 927 001c 9A95      		dec r25
 928 001e 01F4      		brne 1b
 929 0020 C091 0000 		lds r28,Transaction_table
 930 0024 D091 0000 		lds r29,Transaction_table+1
 931 0028 C00F      		add r28,r16
 932 002a D11F      		adc r29,r17
 933               	.LVL71:
 485:keyboards/lily58/serial.c **** #endif
 486:keyboards/lily58/serial.c ****   cli();
 934               		.loc 1 486 0
 935               	/* #APP */
 936               	 ;  486 "keyboards/lily58/serial.c" 1
 937 002c F894      		cli
 938               	 ;  0 "" 2
 939               	/* #NOAPP */
 940               	.LBB262:
 941               	.LBB263:
 248:keyboards/lily58/serial.c **** }
 942               		.loc 1 248 0
 943 002e 529A      		sbi 0xa,2
 944               	.LBE263:
 945               	.LBE262:
 946               	.LBB264:
 947               	.LBB265:
 268:keyboards/lily58/serial.c **** }
 948               		.loc 1 268 0
 949 0030 5A98      		cbi 0xb,2
 950               	.LVL72:
 951               	.LBE265:
 952               	.LBE264:
 953               	.LBB266:
 954               	.LBB267:
 955               		.loc 2 276 0
 956 0032 25E0      		ldi r18,lo8(5)
 957 0034 2A95      	1:	dec r18
 958 0036 01F4      		brne 1b
 959 0038 0000      		nop
 960               	.LVL73:
 961               	.LBE267:
 962               	.LBE266:
 963               	.LBB268:
 964               	.LBB269:
 413:keyboards/lily58/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 965               		.loc 1 413 0
 966 003a 982F      		mov r25,r24
 967 003c 9695      		lsr r25
 968 003e 9570      		andi r25,lo8(5)
 969 0040 8570      		andi r24,lo8(5)
 970               	.LVL74:
 971 0042 980F      		add r25,r24
 972               	.LVL75:
 414:keyboards/lily58/serial.c ****     return bits;
 973               		.loc 1 414 0
 974 0044 892F      		mov r24,r25
 975 0046 8370      		andi r24,lo8(3)
 976 0048 9695      		lsr r25
 977 004a 9695      		lsr r25
 978               	.LVL76:
 979 004c 980F      		add r25,r24
 980               	.LBE269:
 981               	.LBE268:
 487:keyboards/lily58/serial.c **** 
 488:keyboards/lily58/serial.c ****   // signal to the target that we want to start a transaction
 489:keyboards/lily58/serial.c ****   serial_output();
 490:keyboards/lily58/serial.c ****   serial_low();
 491:keyboards/lily58/serial.c ****   _delay_us(SLAVE_INT_WIDTH_US);
 492:keyboards/lily58/serial.c **** 
 493:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 494:keyboards/lily58/serial.c ****   // wait for the target response
 495:keyboards/lily58/serial.c ****   serial_input_with_pullup();
 496:keyboards/lily58/serial.c ****   _delay_us(SLAVE_INT_RESPONSE_TIME);
 497:keyboards/lily58/serial.c **** 
 498:keyboards/lily58/serial.c ****   // check if the target is present
 499:keyboards/lily58/serial.c ****   if (serial_read_pin()) {
 500:keyboards/lily58/serial.c ****     // target failed to pull the line low, assume not present
 501:keyboards/lily58/serial.c ****     serial_output();
 502:keyboards/lily58/serial.c ****     serial_high();
 503:keyboards/lily58/serial.c ****     *trans->status = TRANSACTION_NO_RESPONSE;
 504:keyboards/lily58/serial.c ****     sei();
 505:keyboards/lily58/serial.c ****     return TRANSACTION_NO_RESPONSE;
 506:keyboards/lily58/serial.c ****   }
 507:keyboards/lily58/serial.c **** 
 508:keyboards/lily58/serial.c **** #else
 509:keyboards/lily58/serial.c ****   // send transaction table index
 510:keyboards/lily58/serial.c ****   int tid = (sstd_index<<3) | (7 & nibble_bits_count(sstd_index));
 982               		.loc 1 510 0
 983 004e 092B      		or r16,r25
 511:keyboards/lily58/serial.c ****   sync_send();
 984               		.loc 1 511 0
 985 0050 0E94 0000 		call sync_send
 986               	.LVL77:
 512:keyboards/lily58/serial.c ****   _delay_sub_us(TID_SEND_ADJUST);
 987               		.loc 1 512 0
 988 0054 00C0      		rjmp .
 513:keyboards/lily58/serial.c ****   serial_write_chunk(tid, 7);
 989               		.loc 1 513 0
 990 0056 67E0      		ldi r22,lo8(7)
 991 0058 802F      		mov r24,r16
 992 005a 0E94 0000 		call serial_write_chunk
 993               	.LVL78:
 994               	.LBB270:
 995               	.LBB271:
 996               	.LBB272:
 997               		.loc 2 276 0
 998 005e 80E1      		ldi r24,lo8(16)
 999 0060 8A95      	1:	dec r24
 1000 0062 01F4      		brne 1b
 1001               	.LVL79:
 1002               	.LBE272:
 1003               	.LBE271:
 1004               	.LBE270:
 1005               	.LBB273:
 1006               	.LBB274:
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 1007               		.loc 1 255 0
 1008 0064 5298      		cbi 0xa,2
 256:keyboards/lily58/serial.c **** }
 1009               		.loc 1 256 0
 1010 0066 5A9A      		sbi 0xb,2
 1011               	.L49:
 1012               	.LBE274:
 1013               	.LBE273:
 514:keyboards/lily58/serial.c ****   serial_delay_half1();
 515:keyboards/lily58/serial.c **** 
 516:keyboards/lily58/serial.c ****   // wait for the target response (step1 low->high)
 517:keyboards/lily58/serial.c ****   serial_input_with_pullup();
 518:keyboards/lily58/serial.c ****   while( !serial_read_pin() ) {
 1014               		.loc 1 518 0
 1015 0068 4A9B      		sbis 0x9,2
 1016 006a 00C0      		rjmp .L50
 1017 006c 87E0      		ldi r24,lo8(7)
 1018 006e 90E0      		ldi r25,0
 1019               	.L51:
 1020               	.LVL80:
 1021               	.LBB275:
 519:keyboards/lily58/serial.c ****       _delay_sub_us(2);
 520:keyboards/lily58/serial.c ****   }
 521:keyboards/lily58/serial.c **** 
 522:keyboards/lily58/serial.c ****   // check if the target is present (step2 high->low)
 523:keyboards/lily58/serial.c ****   for( int i = 0; serial_read_pin(); i++ ) {
 1022               		.loc 1 523 0 discriminator 1
 1023 0070 4A99      		sbic 0x9,2
 1024 0072 00C0      		rjmp .L53
 1025               	.LBE275:
 524:keyboards/lily58/serial.c ****       if (i > SLAVE_INT_ACK_WIDTH + 1) {
 525:keyboards/lily58/serial.c ****           // slave failed to pull the line low, assume not present
 526:keyboards/lily58/serial.c ****           serial_output();
 527:keyboards/lily58/serial.c ****           serial_high();
 528:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_NO_RESPONSE;
 529:keyboards/lily58/serial.c ****           sei();
 530:keyboards/lily58/serial.c ****           return TRANSACTION_NO_RESPONSE;
 531:keyboards/lily58/serial.c ****       }
 532:keyboards/lily58/serial.c ****       _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT);
 533:keyboards/lily58/serial.c ****   }
 534:keyboards/lily58/serial.c **** #endif
 535:keyboards/lily58/serial.c **** 
 536:keyboards/lily58/serial.c ****   // initiator recive phase
 537:keyboards/lily58/serial.c ****   // if the target is present syncronize with it
 538:keyboards/lily58/serial.c ****   if( trans->target2initiator_buffer_size > 0 ) {
 1026               		.loc 1 538 0
 1027 0074 6D81      		ldd r22,Y+5
 1028 0076 6623      		tst r22
 1029 0078 01F0      		breq .L54
 539:keyboards/lily58/serial.c ****       if (!serial_recive_packet((uint8_t *)trans->target2initiator_buffer,
 1030               		.loc 1 539 0
 1031 007a 8E81      		ldd r24,Y+6
 1032 007c 9F81      		ldd r25,Y+7
 1033               	.LVL81:
 1034 007e 0E94 0000 		call serial_recive_packet
 1035               	.LVL82:
 1036 0082 8111      		cpse r24,__zero_reg__
 1037 0084 00C0      		rjmp .L54
 1038               	.LBB280:
 1039               	.LBB281:
 248:keyboards/lily58/serial.c **** }
 1040               		.loc 1 248 0
 1041 0086 529A      		sbi 0xa,2
 1042               	.LBE281:
 1043               	.LBE280:
 1044               	.LBB282:
 1045               	.LBB283:
 274:keyboards/lily58/serial.c **** }
 1046               		.loc 1 274 0
 1047 0088 5A9A      		sbi 0xb,2
 1048               	.LBE283:
 1049               	.LBE282:
 540:keyboards/lily58/serial.c ****                                 trans->target2initiator_buffer_size) ) {
 541:keyboards/lily58/serial.c ****           serial_output();
 542:keyboards/lily58/serial.c ****           serial_high();
 543:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_DATA_ERROR;
 1050               		.loc 1 543 0
 1051 008a E881      		ld r30,Y
 1052 008c F981      		ldd r31,Y+1
 1053 008e 82E0      		ldi r24,lo8(2)
 1054 0090 8083      		st Z,r24
 544:keyboards/lily58/serial.c ****           sei();
 1055               		.loc 1 544 0
 1056               	/* #APP */
 1057               	 ;  544 "keyboards/lily58/serial.c" 1
 1058 0092 7894      		sei
 1059               	 ;  0 "" 2
 545:keyboards/lily58/serial.c ****           return TRANSACTION_DATA_ERROR;
 1060               		.loc 1 545 0
 1061               	/* #NOAPP */
 1062 0094 82E0      		ldi r24,lo8(2)
 1063 0096 90E0      		ldi r25,0
 1064 0098 00C0      		rjmp .L47
 1065               	.L50:
 519:keyboards/lily58/serial.c ****   }
 1066               		.loc 1 519 0
 1067 009a 00C0      		rjmp .
 1068 009c 00C0      		rjmp .L49
 1069               	.LVL83:
 1070               	.L53:
 1071 009e 0197      		sbiw r24,1
 1072               	.LVL84:
 1073               	.LBB284:
 524:keyboards/lily58/serial.c ****           // slave failed to pull the line low, assume not present
 1074               		.loc 1 524 0
 1075 00a0 01F4      		brne .L52
 1076               	.LBB276:
 1077               	.LBB277:
 248:keyboards/lily58/serial.c **** }
 1078               		.loc 1 248 0
 1079 00a2 529A      		sbi 0xa,2
 1080               	.LBE277:
 1081               	.LBE276:
 1082               	.LBB278:
 1083               	.LBB279:
 274:keyboards/lily58/serial.c **** }
 1084               		.loc 1 274 0
 1085 00a4 5A9A      		sbi 0xb,2
 1086               	.LBE279:
 1087               	.LBE278:
 528:keyboards/lily58/serial.c ****           sei();
 1088               		.loc 1 528 0
 1089 00a6 E881      		ld r30,Y
 1090 00a8 F981      		ldd r31,Y+1
 1091 00aa 81E0      		ldi r24,lo8(1)
 1092               	.LVL85:
 1093 00ac 8083      		st Z,r24
 529:keyboards/lily58/serial.c ****           return TRANSACTION_NO_RESPONSE;
 1094               		.loc 1 529 0
 1095               	/* #APP */
 1096               	 ;  529 "keyboards/lily58/serial.c" 1
 1097 00ae 7894      		sei
 1098               	 ;  0 "" 2
 530:keyboards/lily58/serial.c ****       }
 1099               		.loc 1 530 0
 1100               	/* #NOAPP */
 1101 00b0 81E0      		ldi r24,lo8(1)
 1102 00b2 90E0      		ldi r25,0
 1103               	.LVL86:
 1104               	.L47:
 1105               	/* epilogue start */
 1106               	.LBE284:
 546:keyboards/lily58/serial.c ****       }
 547:keyboards/lily58/serial.c ****    }
 548:keyboards/lily58/serial.c **** 
 549:keyboards/lily58/serial.c ****   // initiator switch to output
 550:keyboards/lily58/serial.c ****   change_reciver2sender();
 551:keyboards/lily58/serial.c **** 
 552:keyboards/lily58/serial.c ****   // initiator send phase
 553:keyboards/lily58/serial.c ****   if( trans->initiator2target_buffer_size > 0 ) {
 554:keyboards/lily58/serial.c ****       serial_send_packet((uint8_t *)trans->initiator2target_buffer,
 555:keyboards/lily58/serial.c ****                          trans->initiator2target_buffer_size);
 556:keyboards/lily58/serial.c ****   }
 557:keyboards/lily58/serial.c **** 
 558:keyboards/lily58/serial.c ****   // always, release the line when not in use
 559:keyboards/lily58/serial.c ****   sync_send();
 560:keyboards/lily58/serial.c **** 
 561:keyboards/lily58/serial.c ****   *trans->status = TRANSACTION_END;
 562:keyboards/lily58/serial.c ****   sei();
 563:keyboards/lily58/serial.c ****   return TRANSACTION_END;
 564:keyboards/lily58/serial.c **** }
 1107               		.loc 1 564 0
 1108 00b4 DF91      		pop r29
 1109 00b6 CF91      		pop r28
 1110 00b8 1F91      		pop r17
 1111 00ba 0F91      		pop r16
 1112 00bc 0895      		ret
 1113               	.LVL87:
 1114               	.L52:
 1115               	.LBB285:
 532:keyboards/lily58/serial.c ****   }
 1116               		.loc 1 532 0 discriminator 2
 1117 00be 00C0      		rjmp .
 1118               	.LVL88:
 1119 00c0 00C0      		rjmp .L51
 1120               	.LVL89:
 1121               	.L54:
 1122               	.LBE285:
 1123               	.LBB286:
 1124               	.LBB287:
 404:keyboards/lily58/serial.c ****     serial_delay();  //1
 1125               		.loc 1 404 0
 1126 00c2 0E94 0000 		call sync_recv
 1127               	.LVL90:
 1128               	.LBB288:
 1129               	.LBB289:
 1130               	.LBB290:
 1131               		.loc 2 276 0
 1132 00c6 20E2      		ldi r18,lo8(32)
 1133 00c8 2A95      	1:	dec r18
 1134 00ca 01F4      		brne 1b
 1135               	.LVL91:
 1136               	.LBE290:
 1137               	.LBE289:
 1138               	.LBE288:
 1139               	.LBB291:
 1140               	.LBB292:
 268:keyboards/lily58/serial.c **** }
 1141               		.loc 1 268 0
 1142 00cc 5A98      		cbi 0xb,2
 1143               	.LBE292:
 1144               	.LBE291:
 1145               	.LBB293:
 1146               	.LBB294:
 248:keyboards/lily58/serial.c **** }
 1147               		.loc 1 248 0
 1148 00ce 529A      		sbi 0xa,2
 1149               	.LVL92:
 1150               	.LBE294:
 1151               	.LBE293:
 1152               	.LBB295:
 1153               	.LBB296:
 1154               	.LBB297:
 1155               		.loc 2 276 0
 1156 00d0 80E1      		ldi r24,lo8(16)
 1157 00d2 8A95      	1:	dec r24
 1158 00d4 01F4      		brne 1b
 1159               	.LVL93:
 1160               	.LBE297:
 1161               	.LBE296:
 1162               	.LBE295:
 1163               	.LBE287:
 1164               	.LBE286:
 553:keyboards/lily58/serial.c ****       serial_send_packet((uint8_t *)trans->initiator2target_buffer,
 1165               		.loc 1 553 0
 1166 00d6 6A81      		ldd r22,Y+2
 1167 00d8 6623      		tst r22
 1168 00da 01F0      		breq .L55
 554:keyboards/lily58/serial.c ****                          trans->initiator2target_buffer_size);
 1169               		.loc 1 554 0
 1170 00dc 8B81      		ldd r24,Y+3
 1171 00de 9C81      		ldd r25,Y+4
 1172 00e0 0E94 0000 		call serial_send_packet
 1173               	.LVL94:
 1174               	.L55:
 559:keyboards/lily58/serial.c **** 
 1175               		.loc 1 559 0
 1176 00e4 0E94 0000 		call sync_send
 1177               	.LVL95:
 561:keyboards/lily58/serial.c ****   sei();
 1178               		.loc 1 561 0
 1179 00e8 E881      		ld r30,Y
 1180 00ea F981      		ldd r31,Y+1
 1181 00ec 1082      		st Z,__zero_reg__
 562:keyboards/lily58/serial.c ****   return TRANSACTION_END;
 1182               		.loc 1 562 0
 1183               	/* #APP */
 1184               	 ;  562 "keyboards/lily58/serial.c" 1
 1185 00ee 7894      		sei
 1186               	 ;  0 "" 2
 563:keyboards/lily58/serial.c **** }
 1187               		.loc 1 563 0
 1188               	/* #NOAPP */
 1189 00f0 90E0      		ldi r25,0
 1190 00f2 80E0      		ldi r24,0
 1191 00f4 00C0      		rjmp .L47
 1192               	.LVL96:
 1193               	.L56:
 483:keyboards/lily58/serial.c ****   SSTD_t *trans = &Transaction_table[sstd_index];
 1194               		.loc 1 483 0
 1195 00f6 84E0      		ldi r24,lo8(4)
 1196 00f8 90E0      		ldi r25,0
 1197               	.LVL97:
 1198 00fa 00C0      		rjmp .L47
 1199               		.cfi_endproc
 1200               	.LFE26:
 1202               		.section	.text.soft_serial_get_and_clean_status,"ax",@progbits
 1203               	.global	soft_serial_get_and_clean_status
 1205               	soft_serial_get_and_clean_status:
 1206               	.LFB27:
 565:keyboards/lily58/serial.c **** 
 566:keyboards/lily58/serial.c **** #ifdef SERIAL_USE_MULTI_TRANSACTION
 567:keyboards/lily58/serial.c **** int soft_serial_get_and_clean_status(int sstd_index) {
 1207               		.loc 1 567 0
 1208               		.cfi_startproc
 1209               	.LVL98:
 1210               	/* prologue: function */
 1211               	/* frame size = 0 */
 1212               	/* stack size = 0 */
 1213               	.L__stack_usage = 0
 568:keyboards/lily58/serial.c ****     SSTD_t *trans = &Transaction_table[sstd_index];
 1214               		.loc 1 568 0
 1215 0000 23E0      		ldi r18,3
 1216               		1:
 1217 0002 880F      		lsl r24
 1218 0004 991F      		rol r25
 1219 0006 2A95      		dec r18
 1220 0008 01F4      		brne 1b
 1221               	.LVL99:
 1222 000a E091 0000 		lds r30,Transaction_table
 1223 000e F091 0000 		lds r31,Transaction_table+1
 1224 0012 E80F      		add r30,r24
 1225 0014 F91F      		adc r31,r25
 1226               	.LVL100:
 569:keyboards/lily58/serial.c ****     cli();
 1227               		.loc 1 569 0
 1228               	/* #APP */
 1229               	 ;  569 "keyboards/lily58/serial.c" 1
 1230 0016 F894      		cli
 1231               	 ;  0 "" 2
 570:keyboards/lily58/serial.c ****     int retval = *trans->status;
 1232               		.loc 1 570 0
 1233               	/* #NOAPP */
 1234 0018 0190      		ld __tmp_reg__,Z+
 1235 001a F081      		ld r31,Z
 1236 001c E02D      		mov r30,__tmp_reg__
 1237               	.LVL101:
 1238 001e 8081      		ld r24,Z
 1239               	.LVL102:
 1240 0020 90E0      		ldi r25,0
 1241               	.LVL103:
 571:keyboards/lily58/serial.c ****     *trans->status = 0;;
 1242               		.loc 1 571 0
 1243 0022 1082      		st Z,__zero_reg__
 572:keyboards/lily58/serial.c ****     sei();
 1244               		.loc 1 572 0
 1245               	/* #APP */
 1246               	 ;  572 "keyboards/lily58/serial.c" 1
 1247 0024 7894      		sei
 1248               	 ;  0 "" 2
 1249               	/* epilogue start */
 573:keyboards/lily58/serial.c ****     return retval;
 574:keyboards/lily58/serial.c **** }
 1250               		.loc 1 574 0
 1251               	/* #NOAPP */
 1252 0026 0895      		ret
 1253               		.cfi_endproc
 1254               	.LFE27:
 1256               		.section	.bss.Transaction_table_size,"aw",@nobits
 1259               	Transaction_table_size:
 1260 0000 00        		.zero	1
 1261               		.section	.bss.Transaction_table,"aw",@nobits
 1264               	Transaction_table:
 1265 0000 0000      		.zero	2
 1266               		.text
 1267               	.Letext0:
 1268               		.file 3 "/usr/local/Cellar/avr-gcc@7/7.4.0/avr/include/stdint.h"
 1269               		.file 4 "keyboards/lily58/serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
/var/tmp//ccdhIkdj.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//ccdhIkdj.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//ccdhIkdj.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//ccdhIkdj.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//ccdhIkdj.s:6      *ABS*:0000000000000001 __zero_reg__
/var/tmp//ccdhIkdj.s:12     .text.sync_recv:0000000000000000 sync_recv
/var/tmp//ccdhIkdj.s:49     .text.sync_send:0000000000000000 sync_send
/var/tmp//ccdhIkdj.s:90     .text.serial_read_chunk:0000000000000000 serial_read_chunk
/var/tmp//ccdhIkdj.s:216    .text.serial_recive_packet:0000000000000000 serial_recive_packet
/var/tmp//ccdhIkdj.s:315    .text.soft_serial_initiator_init:0000000000000000 soft_serial_initiator_init
/var/tmp//ccdhIkdj.s:1264   .bss.Transaction_table:0000000000000000 Transaction_table
/var/tmp//ccdhIkdj.s:1259   .bss.Transaction_table_size:0000000000000000 Transaction_table_size
/var/tmp//ccdhIkdj.s:350    .text.soft_serial_target_init:0000000000000000 soft_serial_target_init
/var/tmp//ccdhIkdj.s:391    .text.serial_write_chunk:0000000000000000 serial_write_chunk
/var/tmp//ccdhIkdj.s:502    .text.serial_send_packet:0000000000000000 serial_send_packet
/var/tmp//ccdhIkdj.s:577    .text.__vector_3:0000000000000000 __vector_3
/var/tmp//ccdhIkdj.s:890    .text.soft_serial_transaction:0000000000000000 soft_serial_transaction
/var/tmp//ccdhIkdj.s:1205   .text.soft_serial_get_and_clean_status:0000000000000000 soft_serial_get_and_clean_status

UNDEFINED SYMBOLS
__do_clear_bss
